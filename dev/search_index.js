var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"Battelino, P. M.; Grebogi, C.; Ott, E.; Yorke, J. A. and Yorke, E. D. (1988). Multiple coexisting attractors, basin boundaries and basic sets. Physica D: Nonlinear Phenomena 32, 296–305.\n\n\n\nDatseris, G. (2025). Sensitivity of stratocumulus–cumulus transitions in a cloudy energy balance model. ESS Open Archive.\n\n\n\nDatseris, G.; Rossi, K. L. and Wagemakers, A. (2023). Framework for global stability analysis of dynamical systems. Chaos: An Interdisciplinary Journal of Nonlinear Science 33.\n\n\n\nDatseris, G. and Wagemakers, A. (2022). Effortless estimation of basins of attraction. Chaos: An Interdisciplinary Journal of Nonlinear Science 32, 023104.\n\n\n\nDaza, A.; Wagemakers, A.; Georgeot, B.; Guéry-Odelin, D. and Sanjuán, M. A. (2016). Basin entropy: a new tool to analyze uncertainty in dynamical systems. Scientific Reports 6.\n\n\n\nDaza, A.; Wagemakers, A. and Sanjuán, M. A. (2018). Ascertaining when a basin is Wada: the merging method. Scientific Reports 8, 9954.\n\n\n\nEster, M.; Kriegel, H.-P.; Sander, J. and Xu, X. (1996). A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise. In: Proceedings of the Second International Conference on Knowledge Discovery and Data Mining, KDD'96 (AAAI Press); pp. 226–231.\n\n\n\nGelbrecht, M.; Kurths, J. and Hellmann, F. (2020). Monte Carlo basin bifurcation analysis. New Journal of Physics 22, 033032.\n\n\n\nGrebogi, C.; McDonald, S. W.; Ott, E. and Yorke, J. A. (1983). Final state sensitivity: An obstruction to predictability. Physics Letters A 99, 415–418.\n\n\n\nHalekotte, L. and Feudel, U. (2020). Minimal fatal shocks in multistable complex networks. Scientific Reports 10.\n\n\n\nKaszás, B.; Feudel, U. and Tél, T. (2019). Tipping phenomena in typical dynamical systems subjected to parameter drift. Scientific Reports 9.\n\n\n\nKlinshov, V. V.; Nekorkin, V. I. and Kurths, J. (2015). Stability threshold approach for complex dynamical systems. New J. Phys. 18, 013004.\n\n\n\nKrakovská, H.; Kuehn, C. and Longo, I. P. (2024). Resilience of Dynamical Systems. European Journal of Applied Mathematics 35, 155–200.\n\n\n\nLucarini, V. and Bódai, T. (2017). Edge states in the climate system: exploring global instabilities and critical transitions. Nonlinearity 30, R32.\n\n\n\nMehling, O.; Börner, R. and Lucarini, V. (2024). Limits to predictability of the asymptotic state of the Atlantic Meridional Overturning Circulation in a conceptual climate model. Physica D: Nonlinear Phenomena 459, 134043.\n\n\n\nMenck, P. J.; Heitzig, J.; Marwan, N. and Kurths, J. (2013). How basin stability complements the linear-stability paradigm. Nature Physics 9, 89–92.\n\n\n\nMorr, A.; Kuehn, C. and Datseris, G. (2025). Numerically Estimating Resilience Measures in Dynamical Systems, to be published 1, 1.\n\n\n\nPuy, A.; Daza, A.; Wagemakers, A. and Sanjuán, M. A. (2021). A test for fractal boundaries based on the basin entropy. Communications in Nonlinear Science and Numerical Simulation 95, 105588.\n\n\n\nRitchie, P. D.; Alkhayuon, H.; Cox, P. M. and Wieczorek, S. (2023). Rate-induced tipping in natural and human systems. Earth System Dynamics 14, 669–683.\n\n\n\nSala, M.; Leitão, J. C. and Altmann, E. G. (2016). Searching chaotic saddles in high dimensions. Chaos: An Interdisciplinary Journal of Nonlinear Science 26.\n\n\n\nSchneider, T. M.; Gibson, J. F.; Lagha, M.; De Lillo, F. and Eckhardt, B. (2008). Laminar-turbulent boundary in plane Couette flow. Physical Review E 78, 037301.\n\n\n\nSchubert, E.; Sander, J.; Ester, M.; Kriegel, H. P. and Xu, X. (2017). DBSCAN Revisited,  Revisited. ACM Transactions on Database Systems 42, 1–21.\n\n\n\nSkufca, J. D.; Yorke, J. A. and Eckhardt, B. (2006). Edge of chaos in a parallel shear flow. Physical review letters 96, 174101.\n\n\n\nStender, M. and Hoffmann, N. (2021), bSTAB: an open-source software for computing the basin stability of multi-stable dynamical systems. Nonlinear Dynamics 107, 1451–1468.\n\n\n\nSweet, D.; Nusse, H. E. and Yorke, J. A. (2001). Stagger-and-step method: Detecting and computing chaotic saddles in higher dimensions. Physical Review Letters 86, 2261.\n\n\n\nWagemakers, A.; Daza, A. and Sanjuán, M. A. (2020). The saddle-straddle method to test for Wada basins. Communications in Nonlinear Science and Numerical Simulation 84, 105167.\n\n\n\n","category":"section"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Finding-attractors","page":"API","title":"Finding attractors","text":"Attractors.jl defines a generic interface for finding attractors of dynamical systems. One first decides the instance of DynamicalSystem they need. Then, an instance of AttractorMapper is created from this dynamical system. This mapper instance can be used to compute e.g., basins_of_attraction, and the output can be further analyzed to get e.g., the basin_entropy.","category":"section"},{"location":"api/#Recurrences","page":"API","title":"Recurrences","text":"","category":"section"},{"location":"api/#Proximity","page":"API","title":"Proximity","text":"","category":"section"},{"location":"api/#Featurizing","page":"API","title":"Featurizing","text":"","category":"section"},{"location":"api/#Grouping-configurations","page":"API","title":"Grouping configurations","text":"Grouping configurations that can be given to AttractorsViaFeaturizing are part of a generic and extendable interface based on the group_features function. The grouping configuration sets how the features describing the trajectories will be grouped together. Nevertheless, this grouping infrastructure can also be used and extended completely independently of finding attractors of dynamical systems!","category":"section"},{"location":"api/#Grouping-interface","page":"API","title":"Grouping interface","text":"","category":"section"},{"location":"api/#Grouping-types","page":"API","title":"Grouping types","text":"","category":"section"},{"location":"api/#Grouping-utils","page":"API","title":"Grouping utils","text":"","category":"section"},{"location":"api/#Basins-of-attraction","page":"API","title":"Basins of attraction","text":"The basins of attraction are often represented as an array or vector. We also provide a convenient extendable structure that contains the basins themselves, attractors, and the domains on which the basins are defined. All standard basin-related  functions are compatible with this alternate representation.\n\nThe map_to_basin function provides simple interpolation of a point in state space to determine which basin of attraction it is likely to belong to:\n\nCalculating basins of attraction, or their state space fractions, can be done with the functions:\n\nbasins_fractions\nbasins_of_attraction","category":"section"},{"location":"api/#Convergence-times","page":"API","title":"Convergence times","text":"","category":"section"},{"location":"api/#Final-state-sensitivity-/-fractal-boundaries","page":"API","title":"Final state sensitivity / fractal boundaries","text":"Several functions are provided related with analyzing the fractality of the boundaries of the basins of attraction:\n\nbasins_fractal_dimension\nbasin_entropy\nbasins_fractal_test\nuncertainty_exponent\ntest_wada_merge","category":"section"},{"location":"api/#Edge-tracking,-edge-states-and-chaotic-saddles","page":"API","title":"Edge tracking, edge states and chaotic saddles","text":"The edge tracking algorithm allows to locate and construct so-called edge states (also referred to as Melancholia states) embedded in the basin boundary separating different basins of attraction. These could be saddle points, unstable periodic orbits or chaotic saddles. The general idea is that these sets can be found because they act as attractors when restricting to the basin boundary. Another technique to get a pseudo trajectory close to a saddle is the stagger-and-step method that requires little information on the dynamical system.","category":"section"},{"location":"api/#Tipping-points","page":"API","title":"Tipping points","text":"This page discusses functionality related with tipping points in dynamical systems with known rule. If instead you are interested in identifying tipping points in measured timeseries, have a look at TransitionIndicators.jl.","category":"section"},{"location":"api/#Minimal-Critical-Shock","page":"API","title":"Minimal Critical Shock","text":"The algorithm to find minimal perturbation for arbitrary initial condition u0 which will kick the system into different from the current basin.","category":"section"},{"location":"api/#Global-continuation","page":"API","title":"Global continuation","text":"","category":"section"},{"location":"api/#General-seeding-based-continuation","page":"API","title":"General seeding-based continuation","text":"","category":"section"},{"location":"api/#Recurrences-continuation","page":"API","title":"Recurrences continuation","text":"","category":"section"},{"location":"api/#Aggregating-attractors-and-fractions","page":"API","title":"Aggregating attractors and fractions","text":"","category":"section"},{"location":"api/#Grouping-continuation","page":"API","title":"Grouping continuation","text":"","category":"section"},{"location":"api/#Matching-attractors","page":"API","title":"Matching attractors","text":"Matching attractors follow an extendable interface based on IDMatcher. The available matchers are:","category":"section"},{"location":"api/#Matching-interface","page":"API","title":"Matching interface","text":"","category":"section"},{"location":"api/#Low-level-distance-functions","page":"API","title":"Low-level distance functions","text":"","category":"section"},{"location":"api/#Dict-utils","page":"API","title":"Dict utils","text":"","category":"section"},{"location":"api/#Stability-measures","page":"API","title":"Stability measures","text":"","category":"section"},{"location":"api/#Visualization-utilities","page":"API","title":"Visualization utilities","text":"Several plotting utility functions have been created to make the visualization of the output of Attractors.jl seamless. See the examples page for usage of all these plotting functions.\n\nNote that all functions have an out-of-place and an in-place form, the in-place form always taking as a first input a pre-initialized Axis to plot in while the out-of-place creates and returns a new figure object.\n\nE.g.,\n\nfig = heatmap_basins_attractors(grid, basins, attractors; kwargs...)\nheatmap_basins_attractors!(ax, grid, basins, attractors; kwargs...)","category":"section"},{"location":"api/#common_plot_kwargs","page":"API","title":"Common plotting keywords","text":"Common keywords for plotting functions in Attractors.jl are:\n\nukeys: the basin ids (unique keys, vector of integers) to use. By default all existing keys are used.\naccess = [1, 2]: indices of which dimensions of an attractor to select and visualize in a two-dimensional plot (as in animate_attractors_continuation).\ncolors: a dictionary mapping basin ids (i.e., including the -1 key) to a color. By default the JuliaDynamics colorscheme is used if less than 7 ids are present, otherwise random colors from the :darktest colormap.\nmarkers: dictionary mapping attractor ids to markers they should be plotted as\nlabels = Dict(ukeys .=> ukeys): how to label each attractor.\nadd_legend = length(ukeys) < 7: whether to add a legend mapping colors to labels.","category":"section"},{"location":"api/#Basins-related","page":"API","title":"Basins related","text":"","category":"section"},{"location":"api/#Continuation-related","page":"API","title":"Continuation related","text":"","category":"section"},{"location":"api/#Video-output","page":"API","title":"Video output","text":"","category":"section"},{"location":"api/#Attractors.AttractorMapper","page":"API","title":"Attractors.AttractorMapper","text":"AttractorMapper(ds::DynamicalSystem, args...; kwargs...) → mapper\n\nSubtypes of AttractorMapper are structures that map initial conditions of ds to attractors. The found attractors are stored inside the mapper, and can be obtained by calling attractors = extract_attractors(mapper).\n\nCurrently available mapping methods:\n\nAttractorsViaProximity\nAttractorsViaRecurrences\nAttractorsViaFeaturizing\n\nAll AttractorMapper subtypes can be used with basins_fractions or basins_of_attraction.\n\nIn addition, some mappers can be called as a function of an initial condition:\n\nlabel = mapper(u0)\n\nand this will on the fly compute and return the label of the attractor u0 converges at. The mappers that can do this are:\n\nAttractorsViaProximity\nAttractorsViaRecurrences\nAttractorsViaFeaturizing with the GroupViaHistogram configuration.\n\nSee also StabilityMeasuresAccumulator that extends this interface to accelerate estimation of stability measures.\n\nFor developers\n\nAttractorMapper defines an extendable interface. A new type needs to subtype AttractorMapper and implement extract_attractors, id = mapper(u0) and the internal function Attractors.referenced_dynamical_system(mapper). From these, everything else in the entire rest of the library just works! If it is not possible to implement id = mapper(u0), then instead extend basins_fractions(mapper, ics) with ics a vector of initial conditions.\n\n\n\n\n\n","category":"type"},{"location":"api/#Attractors.extract_attractors","page":"API","title":"Attractors.extract_attractors","text":"extract_attractors(mapper::AttractorsMapper) → attractors\n\nReturn a dictionary mapping label IDs to attractors found by the mapper. This function should be called after calling basins_fractions with the given mapper so that the attractors have actually been found first.\n\nFor developing a new mapper: extend the internal function _extract_attractors.\n\n\n\n\n\nextract_attractors(BoA::BasinsOfAttraction) → attractors\n\nReturns the attractors component of a BasinsOfAttraction object. Which is a dictionary mapping attractor labels to attractors represented as StateSpaceSet's.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.AttractorsViaRecurrences","page":"API","title":"Attractors.AttractorsViaRecurrences","text":"AttractorsViaRecurrences(ds::DynamicalSystem, grid; kwargs...)\n\nMap initial conditions of ds to attractors by identifying attractors on the fly based on recurrences in the state space, as outlined in (Datseris and Wagemakers, 2022). However, the Description section below for has a more accurate (and simpler) exposition to the algorithm than the paper.\n\ngrid is instructions for partitioning the state space into finite-sized cells so that a finite state machine can operate on top of it. Possibilities are:\n\nA tuple of sorted AbstractRanges for a regular grid.\n\nExample is grid = (xg, yg) where xg = yg = range(-5, 5; length = 100)   for a two-dimensional system.\n\nA tuple of sorted AbstractVectors for an irregular grid, for example\n\ngrid = (xg, yg) with xg = range(0, 10.0^(1/2); length = 200).^2,   yg = range(-5, 5; length = 100).\n\nAn instance of the special grid type\n\nSubdivisionBasedGrid, which can be created either manually or by using   subdivision_based_grid.   This automatically analyzes and adapts grid discretization   levels in accordance with state space flow speed in different regions.\n\nThe grid has to be the same dimensionality as the state space, use a ProjectedDynamicalSystem if you want to search for attractors in a lower dimensional subspace.\n\nKeyword arguments\n\nsparse = true: control the storage type of the state space grid. If true,  uses a sparse array, whose memory usage is in general more efficient than a regular  array obtained with sparse=false. In practice, the sparse representation should  always be preferred when searching for basins_fractions. Only for very low  dimensional systems and for computing the full basins_of_attraction the  non-sparse version should be used.\n\nTime evolution configuration\n\nTtr = 0: Skip a transient before the recurrence routine begins.\nΔt: Approximate integration time step (second argument of the step! function). The keyword Dt can also be used instead if Δ (\\Delta) is not accessible. It is 1 for discrete time systems. For continuous systems, an automatic value is calculated using automatic_Δt_basins. For very fine grids, this can become very small, much smaller than the typical integrator internal step size in case of adaptive integrators. In such cases, use stop_at_Δt = true.\nstop_at_Δt = false: Only used if the input dynamical system is CoupledODEs. It is given as a third input to step!. Value true is useful in (1) very fine grids, and (2) if some of the attractors are limit cycles. We have noticed that in this case the integrator timestep becomes commensurate with the limit cycle period, leading to incorrectly counting the limit cycle as more than one attractor. stop_at_Δt = true should also be used if you want an accurate estimate of convergence_time.\n\nFinite state machine configuration\n\nconsecutive_recurrences = 100: Number of consecutive visits to previously visited unlabeled cells (i.e., recurrences) required before declaring we have converged to a new attractor. This number tunes the accuracy of converging to attractors and should generally be high (and even higher for chaotic systems).\nattractor_locate_steps = 1000: Number of subsequent steps taken to locate accurately the new attractor after the convergence phase is over. Once attractor_locate_steps steps have been taken, the new attractor has been identified with sufficient accuracy and iteration stops. This number can be very high without much impact to overall performance.\nstore_once_per_cell = true: Control if multiple points in state space that belong to the same cell are stored or not in the attractor, when a new attractor is found. If true, each visited cell will only store a point once, which is desirable for fixed points and limit cycles. If false then attractor_locate_steps points are stored per attractor, leading to more densely stored attractors, which may be desirable for instance in chaotic attractors.\nconsecutive_attractor_steps = 2: Μaximum checks of consecutives hits of an existing attractor cell before declaring convergence to that existing attractor.\nconsecutive_basin_steps = 10: Number of consecutive visits of the same basin of attraction required before declaring convergence to an existing attractor. This is ignored if sparse = true, as basins are not stored internally in that case.\nconsecutive_lost_steps = 20: Maximum check of iterations outside the defined grid before we declare the orbit lost outside and hence assign it label -1.\nhorizon_limit = 1e6: If the norm of the integrator state reaches this limit we declare that the orbit diverged to infinity.\nmaximum_iterations = Int(1e6): A safety counter that is always increasing for each initial condition. Once exceeded, the algorithm assigns -1 and throws a warning. This clause exists to stop the algorithm never halting for inappropriate grids. It may happen when a newly found attractor orbit intersects in the same cell of a previously found attractor (which leads to infinite resetting of all counters).\n\nDescription\n\nAn initial condition given to an instance of AttractorsViaRecurrences is iterated based on the integrator corresponding to ds. Enough recurrences in the state space (i.e., a trajectory visited a region it has visited before) means that the trajectory has converged to an attractor. This is the basis for finding attractors.\n\nA finite state machine (FSM) follows the trajectory in the state space, and constantly maps it to a cell in the given grid. The grid cells store information: they are empty, visited, basins, or attractor cells. The state of the FSM is decided based on the cell type and the previous state of the FSM. Whenever the FSM recurs its state, its internal counter is increased, otherwise it is reset to 0. Once the internal counter reaches a threshold, the FSM terminates or changes its state. The possibilities for termination are the following:\n\nThe trajectory hits consecutive_recurrences times in a row previously visited cells:  it is considered that an attractor is found and is labelled with a new ID. Then,  iteration continues for attractor_locate_steps steps. Each cell visited in this period stores  the \"attractor\" information. Then iteration terminates and the initial condition is  numbered with the attractor's ID.\nThe trajectory hits an already identified attractor consecutive_attractor_steps consecutive times:  the initial condition is numbered with the attractor's basin ID.\nThe trajectory hits a known basin consecutive_basin_steps times in a row: the initial condition  belongs to that basin and is numbered accordingly. Notice that basins are stored and  used only when sparse = false otherwise this clause is ignored.\nThe trajectory spends consecutive_lost_steps steps outside the defined grid or the norm  of the dynamical system state becomes > than horizon_limit: the initial  condition is labelled -1.\nIf none of the above happens, the initial condition is labelled -1 after  maximum_iterations steps.\n\nThere are some special internal optimizations and details that we do not describe here but can be found in comments in the source code. (E.g., a special timer exists for the \"lost\" state which does not interrupt the main timer of the FSM.)\n\nA video illustrating how the algorithm works can be found in the online documentation, under the recurrences animation page.\n\n\n\n\n\n","category":"type"},{"location":"api/#Attractors.automatic_Δt_basins","page":"API","title":"Attractors.automatic_Δt_basins","text":"automatic_Δt_basins(ds::DynamicalSystem, grid; N = 5000) → Δt\n\nCalculate an optimal Δt value for basins_of_attraction. This is done by evaluating the dynamic rule f (vector field) at N randomly chosen points within the bounding box of the grid. The average f is then compared with the average diagonal length of a grid cell and their ratio provides Δt.\n\nNotice that Δt should not be too small which happens typically if the grid resolution is high. It is okay if the trajectory skips a few cells. Also, Δt that is smaller than the internal step size of the integrator will cause a performance drop.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.SubdivisionBasedGrid","page":"API","title":"Attractors.SubdivisionBasedGrid","text":"SubdivisionBasedGrid(grid::NTuple{D, <:AbstractRange}, lvl_array::Array{Int, D})\n\nGiven a coarse grid tesselating the state space, construct a SubdivisionBasedGrid based on the given level array lvl_array that should have the same dimension as grid. The level array has non-negative integer values, with 0 meaning that the corresponding cell of the coarse grid should not be subdivided any further. Value n > 0 means that the corresponding cell will be subdivided in total 2^n times (along each dimension), resulting in finer cells within the original coarse cell.\n\n\n\n\n\n","category":"type"},{"location":"api/#Attractors.subdivision_based_grid","page":"API","title":"Attractors.subdivision_based_grid","text":"subdivision_based_grid(ds::DynamicalSystem, grid; maxlevel = 4, q = 0.99)\n\nConstruct a grid structure SubdivisionBasedGrid that can be directly passed as a grid to AttractorsViaRecurrences. The input grid is an originally coarse grid (a tuple of AbstractRanges). The state space speed is evaluate in all cells of the grid. Cells with small speed (when compared to the \"max\" speed) resultin in this cell being subdivided more. To avoid problems with spikes in the speed, the q-th quantile of the velocities is used as the \"max\" speed (use q = 1 for true maximum). The subdivisions in the resulting grid are clamped to at most value maxlevel.\n\nThis approach is designed for continuous time systems in which different areas of the state space flow may have significantly different velocity. In case of originally coarse grids, this may lead AttractorsViaRecurrences being stuck in some state space regions with a small motion speed and false identification of attractors.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.AttractorsViaProximity","page":"API","title":"Attractors.AttractorsViaProximity","text":"AttractorsViaProximity(ds::DynamicalSystem, attractors::Dict; kwargs...)\n\nMap initial conditions to attractors based on whether the trajectory reaches ε-distance close to any of the user-provided attractors, which have to be in a form of a dictionary mapping attractor labels to StateSpaceSets containing the attractors.\n\nKeywords\n\nε = nothing: Distance below which a trajectory has converged to an attractor, see below. Type \\varepsilon<TAB> to input ε.\nTtr = 0: Transient time to first evolve the system for before checking for proximity.\nΔt = 1: Step time given to step!.\nstop_at_Δt = false: Third argument given to step!.\nhorizon_limit = 1e3: If the maximum distance of the trajectory from any of the given attractors exceeds this limit, it is assumed that the trajectory diverged (gets labelled as -1).\nconsecutive_lost_steps = 10000: If the ds has been stepped this many times without coming ε-near to any attractor,  it is assumed that the trajectory diverged (gets labelled as -1).\ndistance = StrictlyMinimumDistance(): Distance function for evaluating the distance between the trajectory end-point and the given attractors. Can be anything given to set_distance.\n\nDescription\n\nThe system gets stepped, and at each step the distance of the current state to all attractors is computed via set_distance using the distance keyword. If any of these distances is < ε, then the label of the nearest attractor is returned.\n\nattractors do not have to be \"true\" attractors. Any arbitrary sets in the state space can be provided.\n\nIf an ε::Real is not provided by the user, a value is computed automatically as 1/10th of the minimum distance between all attractors. This operation can be expensive for large StateSpaceSets. If length(attractors) == 1, then ε becomes 1/10 of the diagonal of the box containing the attractor. If length(attractors) == 1 and the attractor is a single point, an error is thrown.\n\nThe convergence_time is Inf if an initial condition has not converged. As such, the convergence time is always a float type even for discrete time systems.\n\n\n\n\n\n","category":"type"},{"location":"api/#Attractors.AttractorsViaFeaturizing","page":"API","title":"Attractors.AttractorsViaFeaturizing","text":"AttractorsViaFeaturizing(\n    ds::DynamicalSystem, featurizer::Function,\n    grouping_config = GroupViaClustering(); kwargs...\n)\n\nInitialize a mapper that maps initial conditions to attractors using a featurizing and grouping approach. This is a supercase of the featurizing and clustering approach that is utilized by bSTAB (Stender and Hoffmann, 2021) and MCBB (Gelbrecht et al., 2020). See AttractorMapper for how to use the mapper. This mapper also allows the syntax mapper(u0) but only if the grouping_config is not GroupViaClustering.\n\nfeaturizer is a function f(A, t) that takes as an input an integrated trajectory A::StateSpaceSet and the corresponding time vector t and returns a vector v of features describing the trajectory. For better performance, it is strongly recommended that v isa SVector{<:Real}.\n\ngrouping_config is an instance of any subtype of GroupingConfig and decides how features will be grouped into attractors, see below.\n\nSee also the intermediate functions extract_features and group_features, which can be utilized when wanting to work directly with features.\n\nKeyword arguments\n\nT=100, Ttr=100, Δt=1: Propagated to DynamicalSystems.trajectory for integrating an initial condition to yield A, t.\nthreaded = true: Whether to run the generation of features over threads by integrating trajectories in parallel.\n\nDescription\n\nThe trajectory X of an initial condition is transformed into features. Each feature is a number useful in characterizing the attractor the initial condition ends up at, and distinguishing it from other attractors. Example features are the mean or standard deviation of some the dimensions of the trajectory, the entropy of some of the dimensions, the fractal dimension of X, or anything else you may fancy.\n\nAll feature vectors (each initial condition = 1 feature vector) are then grouped using one of the sevaral available grouping configurations. Each group is assumed to be a unique attractor, and hence each initial condition is labelled according to the group it is part of. The method thus relies on the user having at least some basic idea about what attractors to expect in order to pick the right features, and the right way to group them, in contrast to AttractorsViaRecurrences.\n\nAttractors are stored and can be accessed with extract_attractors, however it should be clear that this mapper never actually finds attractors. They way we store attractors is by picking the first initial condition that belongs to the corresponding \"attractor group\", and then recording its trajectory with the same arguments T, Ttr, Δt. This is stored as the attractor, but of course there is no guarantee that this is actually an attractor.\n\n\n\n\n\n","category":"type"},{"location":"api/#Attractors.group_features","page":"API","title":"Attractors.group_features","text":"group_features(features, group_config::GroupingConfig) → labels\n\nGroup the given iterable of \"features\" (anything that can be grouped, typically vectors of real numbers) according to the configuration and return the labels (vector of equal length as features). See GroupingConfig for possible grouping configuration configurations.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.GroupingConfig","page":"API","title":"Attractors.GroupingConfig","text":"GroupingConfig\n\nSupertype for configuration structs on how to group features together. Used in several occasions such as AttractorsViaFeaturizing or aggregate_attractor_fractions.\n\nCurrently available grouping configurations are:\n\nGroupViaClustering\nGroupViaNearestFeature\nGroupViaHistogram\nGroupViaPairwiseComparison\n\nFor developers\n\nGroupingConfig defines an extendable interface. The only thing necessary for a new grouping configuration is to:\n\nMake a new type and subtype GroupingConfig.\nIf the grouping allows for mapping individual features to group index, then instead extend the internal function feature_to_group(feature, config). This will also allow doing id = mapper(u0) with AttractorsViaFeaturizing.\nElse, extend the function group_features(features, config). You could still extend group_features even if (2.) is satisfied, if there are any performance benefits.\nInclude the new grouping file in the grouping/all_grouping_configs.jl and list it in this documentation string.\n\n\n\n\n\n","category":"type"},{"location":"api/#Attractors.GroupViaClustering","page":"API","title":"Attractors.GroupViaClustering","text":"GroupViaClustering(; kwargs...)\n\nInitialize a struct that contains instructions on how to group features in AttractorsViaFeaturizing. GroupViaClustering clusters features into groups using DBSCAN, similar to the original work by bSTAB (Stender and Hoffmann, 2021) and MCBB (Gelbrecht et al., 2020). Several options on clustering are available, see keywords below.\n\nThe defaults are a significant improvement over existing literature, see Description.\n\nKeyword arguments\n\nclust_distance_metric = Euclidean(): A metric to be used in the clustering. It can be any function f(a, b) that returns the distance between real-valued vectors a, b. All metrics from Distances.jl can be used here.\nrescale_features = true: if true, rescale each dimension of the extracted features separately into the range [0,1]. This typically leads to more accurate clustering.\nmin_neighbors = 10: minimum number of neighbors (i.e. of similar features) each feature needs to have, including counting its own self, in order to be considered in a cluster (fewer than this, it is labeled as an outlier, -1).\nuse_mmap = false: whether to use an on-disk map for creating the distance matrix of the features. Useful when the features are so many where a matrix with side their length would not fit to memory.\n\nKeywords for optimal radius estimation\n\noptimal_radius_method::Union{Real, String} = \"silhouettes_optim\": if a real number, it is the radius used to cluster features. Otherwise, it determines the method used to automatically determine that radius. Possible values are:\n\"silhouettes\": Performs a linear (sequential) search for the radius that maximizes a   statistic of the silhouette values of clusters (typically the mean). This can be chosen   with silhouette_statistic. The linear search may take some time to finish. To   increase speed, the number of radii iterated through can be reduced by decreasing   num_attempts_radius (see its entry below).\n\"silhouettes_optim\": Same as \"silhouettes\" but performs an optimized search via   Optim.jl. It's faster than \"silhouettes\", with typically the same accuracy (the   search here is not guaranteed to always find the global maximum, though it typically   gets close).\n\"knee\": chooses the the radius according to the knee (a.k.a. elbow,   highest-derivative method) and is quicker, though generally leading to much worse   clustering. It requires that min_neighbors > 1.\nnum_attempts_radius = 100: number of radii that the optimal_radius_method will try out in its iterative procedure. Higher values increase the accuracy of clustering, though not necessarily much, while always reducing speed.\nsilhouette_statistic::Function = mean: statistic (e.g. mean or minimum) of the silhouettes that is maximized in the \"optimal\" clustering. The original implementation in (Stender and Hoffmann, 2021) used the minimum of the silhouettes, and typically performs less accurately than the mean.\nmax_used_features = 0: if not 0, it should be an Int denoting the max amount of features to be used when finding the optimal radius. Useful when clustering a very large number of features (e.g., high accuracy estimation of fractions of basins of attraction).\n\nDescription\n\nThe DBSCAN clustering algorithm is used to automatically identify clusters of similar features. Each feature vector is a point in a feature space. Each cluster then basically groups points that are closely packed together. Closely packed means that the points have at least min_neighbors inside a ball of radius optimal_radius centered on them. This method typically works well if the radius is chosen well, which is not necessarily an easy task. Currently, three methods are implemented to automatically estimate an \"optimal\" radius.\n\nEstimating the optimal radius\n\nThe default method is the silhouettes method, which includes keywords silhouette and silhouette_optim. Both of them search for the radius that optimizes the clustering, meaning the one that maximizes a statistic silhouette_statistic (e.g. mean value) of a quantifier for the quality of each cluster. This quantifier is the silhouette value of each identified cluster. A silhouette value measures how similar a point is to the cluster it currently belongs to, compared to the other clusters, and ranges from -1 (worst matching) to +1 (ideal matching). If only one cluster is found, the assigned silhouette is zero. So for each attempted radius in the search the clusters are computed, their silhouettes calculated, and the statistic of these silhouettes computed. The algorithm then finds the radius that leads to the maximum such statistic. For optimal_radius_method = \"silhouettes\", the search is done linearly, from a minimum to a maximum candidate radius for optimal_radius_method = \"silhouettes\"; optimal_radius_method = silhouettes_optim, it is done via an optimized search performed by Optim.jl which is typically faster and with similar accuracy. A third alternative is the\"elbow\" method, which works by calculating the distance of each point to its k-nearest-neighbors (with k=min_neighbors) and finding the distance corresponding to the highest derivative in the curve of the distances, sorted in ascending order. This distance is chosen as the optimal radius. It is described in (Ester et al., 1996) and (Schubert et al., 2017). It typically performs considerably worse than the \"silhouette\" methods.\n\n\n\n\n\n","category":"type"},{"location":"api/#Attractors.GroupViaHistogram","page":"API","title":"Attractors.GroupViaHistogram","text":"GroupViaHistogram(binning::FixedRectangularBinning)\n\nInitialize a struct that contains instructions on how to group features in AttractorsViaFeaturizing. GroupViaHistogram performs a histogram in feature space. Then, all features that are in the same histogram bin get the same label. The binning is an instance of FixedRectangularBinning from ComplexityMeasures.jl. (the reason to not allow RectangularBinning is because during continuation we need to ensure that bins remain identical).\n\n\n\n\n\n","category":"type"},{"location":"api/#Attractors.GroupViaNearestFeature","page":"API","title":"Attractors.GroupViaNearestFeature","text":"GroupViaNearestFeature(templates; kwargs...)\n\nInitialize a struct that contains instructions on how to group features in AttractorsViaFeaturizing. GroupViaNearestFeature accepts a template, which is a vector of features. Then, generated features from initial conditions in AttractorsViaFeaturizing are labelled according to the feature in templates that is closest (the label is the index of the closest template).\n\ntemplates can be a vector or dictionary mapping keys to templates. Internally all templates are converted to SVector for performance. Hence, it is strongly recommended that both templates and the output of the featurizer function in AttractorsViaFeaturizing return SVector types.\n\nKeyword arguments\n\nmetric = Euclidean(): metric to be used to quantify distances in the feature space.\nmax_distance = Inf: Maximum allowed distance between a feature and its nearest template for it to be assigned to that template. By default, Inf guarantees that a feature is assigned to its nearest template regardless of the distance. Features that exceed max_distance to their nearest template get labelled -1.\n\n\n\n\n\n","category":"type"},{"location":"api/#Attractors.GroupViaPairwiseComparison","page":"API","title":"Attractors.GroupViaPairwiseComparison","text":"GroupViaPairwiseComparison <: GroupingConfig\nGroupViaPairwiseComparison(; threshold::Real, metric...)\n\nInitialize a struct that contains instructions on how to group features in AttractorsViaFeaturizing. GroupViaPairwiseComparison groups features and identifies clusters by considering the pairwise distance between features. It can be used as an alternative to the clustering method in GroupViaClustering, having the advantage that it is simpler, typically faster and uses less memory.\n\nKeyword arguments\n\nthreshold = 0.1: A real number defining the maximum distance two features can have to be considered in the same cluster - above the threshold, features are different. This value simply needs to be large enough to differentiate clusters. A good value for threshold depends on the feature variability within a cluster the chosen metric, and whether features are rescaled. See description below for more.\nmetric = Euclidean(): A function metric(a, b) that returns the distance between two features a and b, outputs of featurizer. Any Metric from Distances.jl can be used here.\nrescale_features = true: if true, rescale each dimension of the extracted features separately into the range [0, 1]. This typically leads to more accurate grouping for the default metric. threshold, however, it should be avoid for when there is only one attractor for the system, because it leads to it being wrongly classified as many different attractors at the same location).\n\nDescription\n\nThis algorithm assumes that the features are well-separated into distinct clouds, with the maximum radius of the cloud controlled by threshold. Since the systems are deterministic, this is achievable with a good-enough featurizer function, by removing transients, and running the trajectories for sufficiently long. It then considers that features belong to the same attractor when their pairwise distance, computed using metric, is smaller than or equal to threshold, and that they belong to different attractors when the distance is bigger. Attractors correspond to each grouping of similar features. In this way, the key parameter threshold is basically the amount of variation permissible in the features belonging to the same attractor. If they are well-chosen, the value can be relatively small and does not need to be fine tuned.\n\nThe threshold should achieve a balance: one one hand, it should be large enough to account for variations in the features from the same attractor - if it's not large enough, the algorithm will find duplicate attractors. On the other hand, it should be small enough to not group together features from distinct attractors. This requires some knowledge of how spread the features are. If it's too big, the algorithm will miss some attractors, as it groups 2+ distinct attractors together. Therefore, as a rule of thumb, one can repeat the procedure a few times, starting with a relatively large value and reducing it until no more attractors are found and no duplicates appear.\n\nThe method scales as O(N) in memory and performance with N the number of features. This is a huge difference versus the O(N^2) of GroupViaClustering.\n\n\n\n\n\n","category":"type"},{"location":"api/#Attractors.extract_features","page":"API","title":"Attractors.extract_features","text":"extract_features(mapper, ics; N = 1000, show_progress = true)\n\nReturn a vector of the features of each initial condition in ics (as in basins_fractions), using the configuration of mapper::AttractorsViaFeaturizing. Keyword N is ignored if ics isa StateSpaceSet.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.BasinsOfAttraction","page":"API","title":"Attractors.BasinsOfAttraction","text":"BasinsOfAttraction\n\nA subtype of BasinsOfAttraction is a convenient structure that stores a representation of the basins of attraction, their associated attractors, and a representation of the domain over which the basin is defined. For example, this domain could be a Grid subtype matching the size of the basins as an array or a set of points sampled from the state space. These fields  can be accessed using the extract_basins, extract_attractors, and extract_domain functions respectively.\n\nCurrently available subtypes:\n\nArrayBasinsOfAttraction\nSampledBasinsOfAttraction\n\nAll BasinsOfAttraction subtypes can be used with basins_fractions provided that the basins are represented as subtypes of AbstractArray. Additionally, all  BasinsOfAttraction subtypes are iterable in the sense: basins, attractors = BoA, this  was done to ensure backwards compatibility for functions whose original return format was basins, attractors but has since been replaced with a BasinsOfAttraction type.\n\nThe map_to_basin function provides simple interpolation of a point in state space  to determine which basin of attraction it is likely to belong to.\n\n\n\n\n\n","category":"type"},{"location":"api/#Attractors.ArrayBasinsOfAttraction","page":"API","title":"Attractors.ArrayBasinsOfAttraction","text":"ArrayBasinsOfAttraction(basins, attractors, grid)\n\nA subtype of BasinsOfAttraction whose basins of attraction are represented by an  array::AbstractArray, that has D number of dimensions. The attractors take the form of a  dictionary mapping attractor labels to StateSpaceSet's with the points of each set being of  length D. The grid represents the spatial domain, and can be anything given to AttractorsViaRecurrences as a grid, i.e., a tuple of ranges or a Grid type.\n\n\n\n\n\n","category":"type"},{"location":"api/#Attractors.SampledBasinsOfAttraction","page":"API","title":"Attractors.SampledBasinsOfAttraction","text":"SampledBasinsOfAttraction(basins, attractors, sampled_points)\n\nA subtype of BasinsOfAttraction whose basins of attraction are represented by a vector::AbstractVector.  The attractors take the form of a dictionary mapping attractor labels to StateSpaceSet's with  the points of each set being of equal length. The spatial domain of this basin type is sampled_points which  can be a StateSpaceSet with the same dimensionality, element type, and vector type as those  used to represent the attractors or alternatively a vector of points with the aforementioned requirements. \n\nAdditional keyword arguments may be specified for use in the construction of a search structure which map_to_basin uses to interpolate state space points to their nearest basin. These arguments are:\n\ntree: search tree constructor (e.g. KDTree, BallTree)\nmetric: distance metric (e.g. Euclidean(), Chebyshev())\nsearchstructure_kwargs...: additional keyword arguments passed to searchstructure\n\n\n\n\n\n","category":"type"},{"location":"api/#Attractors.map_to_basin","page":"API","title":"Attractors.map_to_basin","text":"map_to_basin(BoA::BasinOfAttraction, point; kwargs...) → id\n\nGiven a point, map_to_basin interpolates to which basin it should belong.\n\nFor ArrayBasinsOfAttraction this finds the label of the closest grid cell. \n\nFor SampledBasinsOfAttraction this finds the label corresponding to the  nearest neighbor using Neighborhood.jl\n\nFor developing a new BasinOfAttraction subtype extend the internal function map_to_domain, and ensure that the basins can be indexed by the returned value.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.basins_fractions","page":"API","title":"Attractors.basins_fractions","text":"basins_fractions(\n    mapper::AttractorMapper,\n    ics::Union{AbstractVector, Function};\n    kwargs...\n)\n\nApproximate the state space fractions fs of the basins of attraction of a dynamical system by mapping initial conditions to attractors using mapper (which contains a reference to a DynamicalSystem). The fractions are simply the ratios of how many initial conditions ended up at each attractor.\n\nInitial conditions to use are defined by ics. It can be:\n\nan AbstractVector of initial conditions, in which case all are used. Typically this is a StateSpaceSet.\na 0-argument function ics() that spits out random initial conditions. Then N random initial conditions are chosen. See statespace_sampler to generate such functions.\n\nReturn\n\nThe function will always return fractions, which is a dictionary whose keys are the labels given to each attractor (always integers enumerating the different attractors), and whose values are the respective basins fractions. The label -1 is given to any initial condition where mapper could not match to an attractor (this depends on the mapper type).\n\nIf ics is a StateSpaceSet the function will also return labels, which is a vector, of equal length to ics, that contains the label each initial condition was mapped to.\n\nSee AttractorMapper for all possible mapper types, and use extract_attractors (after calling basins_fractions) to extract the stored attractors from the mapper. See also convergence_and_basins_fractions.\n\nKeyword arguments\n\nN = 1000: Number of random initial conditions to generate in case ics is a function.\nshow_progress = true: Display a progress bar of the process.\n\n\n\n\n\nbasins_fractions(BoA::BasinsOfAttraction [,ids]) → fs::Dict\nbasins_fractions(basins::AbstractArray [,ids]) → fs::Dict\n\nCalculate the state space fraction of the basins of attraction encoded in basins. The elements of basins are integers, enumerating the attractor that the entry of basins converges to (i.e., like the output of basins_of_attraction). Return a dictionary that maps attractor IDs to their relative fractions. Optionally you may give a vector of ids to calculate the fractions of only the chosen ids (by default ids = unique(basins)).\n\nThe second function signature exists for backwards compatibility. \n\nIn (Menck et al., 2013) the authors use these fractions to quantify the stability of a basin of attraction, and specifically how it changes when a parameter is changed. For this, see global_continuation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.basins_of_attraction","page":"API","title":"Attractors.basins_of_attraction","text":"basins_of_attraction(mapper::AttractorsViaRecurrences; show_progress = true) → boa\n\nThis is a special method of basins_of_attraction that using recurrences does exactly what is described in the paper by Datseris & Wagemakers (Datseris and Wagemakers, 2022). By enforcing that the internal grid of mapper is the same as the grid of initial conditions to map to attractors, the method can further utilize found exit and attraction basins, making the computation faster as the grid is processed more and more.\n\nThe return has type ArrayBasinsOfAttraction, but may be decomposed as basins, attractors = boa ensuring backwards compatibility with the previous return format.\n\n\n\n\n\nbasins_of_attraction(mapper::AttractorMapper, grid::Tuple) → boa\n\nCompute the full basins of attraction as identified by the given mapper, which includes a reference to a DynamicalSystem and return them along with (perhaps approximated) found attractors contained within the  ArrayBasinsOfAttraction structure. \n\ngrid is a tuple of ranges defining the grid of initial conditions that partition the state space into boxes with size the step size of each range. For example, grid = (xg, yg) where xg = yg = range(-5, 5; length = 100). The grid has to be the same dimensionality as the state space expected by the integrator/system used in mapper. E.g., a ProjectedDynamicalSystem could be used for lower dimensional projections, etc. A special case here is a PoincareMap with plane being Tuple{Int, <: Real}. In this special scenario the grid can be one dimension smaller than the state space, in which case the partitioning happens directly on the hyperplane the Poincaré map operates on.\n\nbasins_of_attraction function is a convenience 5-lines-of-code wrapper which uses the labels returned by basins_fractions and simply assigns them to a full array corresponding to the state space partitioning indicated by grid.\n\nNote that, to ensure backwards compatibility the return type can be decomposed such that  basins, attractors = boa.\n\nSee also convergence_and_basins_of_attraction.\n\n\n\n\n\nbasins_of_attraction(mapper::AttractorMapper, ics; kwargs...) → boa\n\nCompute the full basins of attraction as identified by the given mapper, which includes a reference to a DynamicalSystem and return them along with (perhaps approximated) found attractors contained within a  SampledBasinsOfAttraction object.\n\nThe initial conditions ics, and the keyword arguments kwargs are the same as in basins_fractions with the same function signature. This function is a small convenience wrapper which uses the sampled initial conditions and their  corresponding labels, from basins_fractions, to construct a SampledBasinsOfAttraction\n\nNote that, as with the other basins_of_attraction function, the return can be decomposed:  basins, attractors = boa.\n\n\n\n\n\n","category":"function"},{"location":"api/#StateSpaceSets.statespace_sampler","page":"API","title":"StateSpaceSets.statespace_sampler","text":"statespace_sampler(region [, seed = 42]) → sampler, isinside\n\nA function that facilitates sampling points randomly and uniformly in a state space region. It generates two functions:\n\nsampler is a 0-argument function that when called generates a random point inside a state space region. The point is always a Vector for type stability irrespectively of dimension. Generally, the generated point should be copied if it needs to be stored. (i.e., calling sampler() utilizes a shared vector) sampler is a thread-safe function.\nisinside is a 1-argument function that returns true if the given state space point is inside the region.\n\nThe region can be an instance of any of the following types (input arguments if not specified are vectors of length D, with D the state space dimension):\n\nHSphere(radius::Real, center): points inside the hypersphere (boundary excluded). Convenience method HSphere(radius::Real, D::Int) makes the center a D-long vector of zeros.\nHSphereSurface(radius, center): points on the hypersphere surface. Same convenience method as above is possible.\nHRectangle(mins, maxs): points in [min, max) for the bounds along each dimension.\n\nThe random number generator is always Xoshiro with the given seed.\n\n\n\n\n\nstatespace_sampler(grid::NTuple{N, AbstractRange} [, seed])\n\nIf given a grid that is a tuple of AbstractVectors, the minimum and maximum of the vectors are used to make an HRectangle region.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.convergence_and_basins_fractions","page":"API","title":"Attractors.convergence_and_basins_fractions","text":"convergence_and_basins_fractions(mapper::AttractorMapper, ics)\n\nAn extension of basins_fractions. Return fs, labels, convergence. The first two are as in basins_fractions, and convergence is a vector containing the time each initial condition took to converge to its attractor. Only usable with mappers that support id = mapper(u0).\n\nSee also convergence_time.\n\nKeyword arguments\n\nshow_progress = true: show progress bar.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.convergence_and_basins_of_attraction","page":"API","title":"Attractors.convergence_and_basins_of_attraction","text":"convergence_and_basins_of_attraction(mapper::AttractorMapper, grid)\n\nAn extension of basins_of_attraction. Return basins, attractors, convergence, with basins, attractors as in basins_of_attraction, and convergence being an array with same shape as basins. It contains the time each initial condition took to converge to its attractor. It is useful to give to shaded_basins_heatmap.\n\nSee also convergence_time. Note that this function is not able to be updated with a BasinsOfAttraction return type as the return is an iterable also contains iterations, but array_basins, iterations breaks backwards compatibility.\n\nKeyword arguments\n\nshow_progress = true: show progress bar.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.convergence_time","page":"API","title":"Attractors.convergence_time","text":"convergence_time(mapper::AttractorMapper) → t\n\nReturn the approximate time the mapper took to converge to an attractor. This function should be called just right after mapper(u0) was called with u0 the initial condition of interest. Hence it is only valid with AttractorMapper subtypes that support this syntax.\n\nObtaining the convergence time is computationally free, so that convergence_and_basins_fractions can always be used instead of basins_fractions.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.basins_fractal_dimension","page":"API","title":"Attractors.basins_fractal_dimension","text":"basins_fractal_dimension(BoA::ArrayBasinsOfAttraction; kwargs...) -> V_ε, N_ε, d\nbasins_fractal_dimension(basins; kwargs...) -> V_ε, N_ε, d\n\nEstimate the fractal dimension d of the boundary between basins of attraction using a box-counting algorithm for the boxes that contain at least two different basin IDs.\n\nThe second function signature exists for backwards compatibility. \n\nKeyword arguments\n\nrange_ε = 2:maximum(size(basins))÷20 is the range of sizes of the box to test (in pixels).\n\nDescription\n\nThe output N_ε is a vector with the number of the balls of radius ε (in pixels) that contain at least two initial conditions that lead to different attractors. V_ε is a vector with the corresponding size of the balls. The output d is the estimation of the box-counting dimension of the boundary by fitting a line in the log.(N_ε) vs log.(1/V_ε) curve. However it is recommended to analyze the curve directly for more accuracy.\n\nIt is the implementation of the popular algorithm of the estimation of the box-counting dimension. The algorithm search for a covering the boundary with N_ε boxes of size ε in pixels.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.basin_entropy","page":"API","title":"Attractors.basin_entropy","text":"basin_entropy(BoA::ArrayBasinsOfAttraction{Integer}, ε = size(BoA.basins, 1)÷10) -> Sb, Sbb\nbasin_entropy(basins::Array{Integer}, ε = size(basins, 1)÷10) -> Sb, Sbb\n\nReturn the basin entropy (Daza et al., 2016) Sb and basin boundary entropy Sbb of the given basins of attraction by considering ε-sized boxes along each dimension.\n\nThe second function signature exists for backwards compatibility. \n\nDescription\n\nFirst, the n-dimensional input basins is divided regularly into n-dimensional boxes of side ε. If ε is an integer, the same size is used for all dimensions, otherwise ε can be a tuple with the same size as the dimensions of basins. The size of the basins has to be divisible by ε.\n\nAssuming that there are N ε-boxes that cover the basins, the basin entropy is estimated as (Daza et al., 2016)\n\nS_b = tfrac1Nsum_i=1^Nsum_j=1^m_i-p_ijlog(p_ij)\n\nwhere m_i is the number of unique IDs (integers of basins) in box i and p_ij is the relative frequency (probability) to obtain ID j in the i box (simply the count of IDs j divided by the total in the box).\n\nSbb is the boundary basin entropy. This follows the same definition as S_b, but now averaged over only only boxes that contains at least two different basins, that is, for the boxes on the boundaries.\n\nThe basin entropy is a measure of the uncertainty on the initial conditions of the basins. It is maximum at the value log(n_att) being n_att the number of unique IDs in basins. In this case the boundary is intermingled: for a given initial condition we can find another initial condition that lead to another basin arbitrarily close. It provides also a simple criterion for fractality: if the boundary basin entropy Sbb is above log(2) then we have a fractal boundary. It doesn't mean that basins with values below cannot have a fractal boundary, for a more precise test see basins_fractal_test. An important feature of the basin entropy is that it allows comparisons between different basins using the same box size ε.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.basins_fractal_test","page":"API","title":"Attractors.basins_fractal_test","text":"basin_entropy(BoA::ArrayBasinsOfAttraction, ε = 20, Ntotal = 1000) -> test_res, Sbb\nbasins_fractal_test(basins; ε = 20, Ntotal = 1000) -> test_res, Sbb\n\nPerform an automated test to decide if the boundary of the basins has fractal structures based on the method of Puy et al. (Puy et al., 2021). Return test_res (:fractal or :smooth) and the mean basin boundary entropy.\n\nThe second function signature exists for backwards compatibility. \n\nKeyword arguments\n\nε = 20: size of the box to compute the basin boundary entropy.\nNtotal = 1000: number of balls to test in the boundary for the computation of Sbb\n\nDescription\n\nThe test \"looks\" at the basins with a magnifier of size ε at random. If what we see in the magnifier looks like a smooth boundary (onn average) we decide that the boundary is smooth. If it is not smooth we can say that at the scale ε we have structures, i.e., it is fractal.\n\nIn practice the algorithm computes the boundary basin entropy Sbb basin_entropy for Ntotal random boxes of radius ε. If the computed value is equal to theoretical value of a smooth boundary (taking into account statistical errors and biases) then we decide that we have a smooth boundary. Notice that the response test_res may depend on the chosen ball radius ε. For larger size, we may observe structures for smooth boundary and we obtain a different answer.\n\nThe output test_res is a symbol describing the nature of the basin and the output Sbb is the estimated value of the boundary basin entropy with the sampling method.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.uncertainty_exponent","page":"API","title":"Attractors.uncertainty_exponent","text":"uncertainty_exponent(BoA::ArrayBasinsOfAttraction; kwargs...) -> ε, N_ε, α\nuncertainty_exponent(basins; kwargs...) -> ε, N_ε, α\n\nEstimate the uncertainty exponent(Grebogi et al., 1983) of the basins of attraction. This exponent is related to the final state sensitivity of the trajectories in the phase space. An exponent close to 1 means basins with smooth boundaries whereas an exponent close to 0 represent completely fractalized basins, also called riddled basins.\n\nThe output N_ε is a vector with the number of the balls of radius ε (in pixels) that contain at least two initial conditions that lead to different attractors. The output α is the estimation of the uncertainty exponent using the box-counting dimension of the boundary by fitting a line in the log.(N_ε) vs log.(1/ε) curve. However it is recommended to analyze the curve directly for more accuracy.\n\nThe second function signature exists for backwards compatibility. \n\nKeyword arguments\n\nrange_ε = 2:maximum(size(basins))÷20 is the range of sizes of the ball to test (in pixels).\n\nDescription\n\nA phase space with a fractal boundary may cause a uncertainty on the final state of the dynamical system for a given initial condition. A measure of this final state sensitivity is the uncertainty exponent. The algorithm probes the basin of attraction with balls of size ε at random. If there are a least two initial conditions that lead to different attractors, a ball is tagged \"uncertain\". f_ε is the fraction of \"uncertain balls\" to the total number of tries in the basin. In analogy to the fractal dimension, there is a scaling law between, f_ε ~ ε^α. The number that characterizes this scaling is called the uncertainty exponent α.\n\nNotice that the uncertainty exponent and the box counting dimension of the boundary are related. We have Δ₀ = D - α where Δ₀ is the box counting dimension computed with basins_fractal_dimension and D is the dimension of the phase space. The algorithm first estimates the box counting dimension of the boundary and returns the uncertainty exponent.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.test_wada_merge","page":"API","title":"Attractors.test_wada_merge","text":"test_wada_merge(BoA::ArrayBasinsOfAttraction,r) -> p\ntest_wada_merge(basins, r) -> p\n\nTest if the 2D array basins has the Wada property using the merging technique of (Daza et al., 2018).\n\nThe second function signature exists for backwards compatibility. \n\nDescription\n\nThe technique consists in computing the generalized basins of each attractor. These new basins are formed with on of the basins and the union of the other basins. A new boundary is defined by these two objects. The algorithm then computes the distance between each boundaries of these basins pairwise. If all the boundaries are within some distance r, there is a unique boundary separating the basins and we have the wada property. The algorithm returns the maximum proportion of pixels of a boundary with distance strictly greater than r from another boundary.\n\nIf p == 0,  we have the Wada property for this value of r. If p > 0, the criteria to decide if the basins are Wada is left to the user. Numerical inaccuracies may be responsible for a small percentage of points with distance larger than r\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.edgetracking","page":"API","title":"Attractors.edgetracking","text":"edgetracking(ds::DynamicalSystem, attractors::Dict; kwargs...)\n\nTrack along a basin boundary in a dynamical system ds with two or more attractors in order to find an edge state. Results are returned in the form of EdgeTrackingResults, which contains the pseudo-trajectory edge representing the track on the basin boundary, along with additional output (see below).\n\nThe system's attractors are specified as a Dict of StateSpaceSets, as in AttractorsViaProximity or the output of extract_attractors. By default, the algorithm is initialized from the first and second attractor in attractors. Alternatively, the initial states can be set via keyword arguments u1, u2 (see below). Note that the two initial states must belong to different basins of attraction.\n\nKeyword arguments\n\nbisect_thresh = 1e-7: distance threshold for bisection.\ndiverge_thresh = 1e-6: distance threshold for parallel integration.\nu1: first initial state (defaults to first point in first entry of attractors).\nu2: second initial state (defaults to first point in second entry of attractors).\nmaxiter = 100: maximum number of iterations before the algorithm stops.\nabstol = 1e-9: distance threshold for convergence of the updated edge state.\nT_transient = 0.0: transient time before the algorithm starts saving the edge track.\ntmax = Inf: maximum integration time of parallel trajectories until re-bisection.\nΔt = 0.01: time step passed to step! when evolving the two trajectories.\nshow_progress = true: if true, shows progress bar and information while running.\nverbose = true: if false, silences print output and warnings while running.\nkw...: additional keyword arguments to be passed to AttractorsViaProximity. We strongly recommend to either pass in a high Ttr, or a very small ε, (smaller than the default estimated by AttractorsViaProximity) to avoid transient parts of trajectories wrongly being classified as having converged.\n\nDescription\n\nThe edge tracking algorithm is a numerical method to find an edge state or (possibly chaotic) saddle on the boundary between two basins of attraction. Introduced by (Battelino et al., 1988) and further described by (Skufca et al., 2006), the algorithm has been applied to, e.g., the laminar-turbulent boundary in plane Couette flow (Schneider et al., 2008), Wada basins (Wagemakers et al., 2020), as well as Melancholia states in conceptual (Mehling et al., 2024) and intermediate-complexity (Lucarini and Bódai, 2017) climate models. Relying only on forward integration of the system, it works even in high-dimensional systems with complicated fractal basin boundary structures.\n\nThe algorithm consists of two main steps: bisection and tracking. First, it iteratively bisects along a straight line in state space between the intial states u1 and u2 to find the separating basin boundary. The bisection stops when the two updated states are less than bisect_thresh (Euclidean distance in state space) apart from each other. Next, a ParallelDynamicalSystem is initialized from these two updated states and integrated forward until the two trajectories diverge from each other by more than diverge_thresh (Euclidean distance). The two final states of the parallel integration are then used as new states u1 and u2 for a new bisection, and so on, until a stopping criterion is fulfilled.\n\nTwo stopping criteria are implemented via the keyword arguments maxiter and abstol. Either the algorithm stops when the number of iterations reaches maxiter, or when the state space position of the updated edge point changes by less than abstol (in Euclidean distance) compared to the previous iteration. Convergence below abstol happens after sufficient iterations if the edge state is a saddle point. However, the edge state may also be an unstable limit cycle or a chaotic saddle. In these cases, the algorithm will never actually converge to a point but (after a transient period) continue populating the set constituting the edge state by tracking along it.\n\nA central idea behind this algorithm is that basin boundaries are typically the stable manifolds of unstable sets, namely edge states or saddles. The flow along the basin boundary will thus lead to these sets, and the iterative bisection neutralizes the unstable direction of the flow away from the basin boundary. If the system possesses multiple edge states, the algorithm will find one of them depending on where the initial bisection locates the boundary.\n\nOutput\n\nReturns a data type EdgeTrackingResults containing the results.\n\nSometimes, the AttractorMapper used in the algorithm may erroneously identify both states u1 and u2 with the same basin of attraction due to being very close to the basin boundary. If this happens, a warning is raised and EdgeTrackingResults.success = false.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.EdgeTrackingResults","page":"API","title":"Attractors.EdgeTrackingResults","text":"EdgeTrackingResults(edge, track1, track2, time, bisect_idx)\n\nData type that stores output of the edgetracking algorithm.\n\nFields\n\nedge::StateSpaceSet: the pseudo-trajectory representing the tracked edge segment (given by the average in state space between track1 and track2)\ntrack1::StateSpaceSet: the pseudo-trajectory tracking the edge within basin 1\ntrack2::StateSpaceSet: the pseudo-trajectory tracking the edge within basin 2\ntime::Vector: time points of the above StateSpaceSets\nbisect_idx::Vector: indices of time at which a re-bisection occurred\nsuccess::Bool: indicates whether the edge tracking has been successful or not\n\n\n\n\n\n","category":"type"},{"location":"api/#Attractors.bisect_to_edge","page":"API","title":"Attractors.bisect_to_edge","text":"bisect_to_edge(pds::ParallelDynamicalSystem, mapper::AttractorMapper; kwargs...) -> u1, u2\n\nFinds the basin boundary between two states u1, u2 = current_states(pds) by bisecting along a straight line in phase space. The states u1 and u2 must belong to different basins.\n\nReturns a triple u1, u2, success, where u1, u2 are two new states located on either side of the basin boundary that lie less than bisect_thresh (Euclidean distance in state space) apart from each other, and success is a Bool indicating whether the bisection was successful (it may fail if the mapper maps both states to the same basin of attraction, in which case a warning is raised).\n\nKeyword arguments\n\nbisect_thresh = 1e-7: The maximum (Euclidean) distance between the two returned states.\n\nDescription\n\npds is a ParallelDynamicalSystem with two states. The mapper must be an AttractorMapper of subtype AttractorsViaProximity or AttractorsViaRecurrences.\n\ninfo: Info\nIf the straight line between u1 and u2 intersects the basin boundary multiple times, the method will find one of these intersection points. If more than two attractors exist, one of the two returned states may belong to a different basin than the initial conditions u1 and u2. A warning is raised if the bisection involves a third basin.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.stagger_and_step","page":"API","title":"Attractors.stagger_and_step","text":"stagger_and_step(ds::DynamicalSystem, x0, N::Int, \n    isinside::Function; kwargs...) -> trajectory\n\nImplement the stagger-and-step method  (Sweet et al., 2001) and (Sala et al., 2016) to approximate the invariant  non-attracting set governing the chaotic transient dynamics  of a system, namely the stable manifold of a chaotic saddle. \n\nGiven the dynamical system ds and a initial guess x0 in a  region with no attractors defined by the membership function  isinside, the algorithm returns a StateSpaceState named trajectory  of N points from the phase space close to the stable manifold.  If we set one of this point as an initial condition of ds,  the trajectory escape from the region after at least Tm  steps of ds. The search is stochastic and depends on the  parameter δ defining a (small) neighborhood of search. \n\nThe function isinside(x) must return true if the point x is  inside the chosen bounded region and false otherwise. See  statespace_sampler as a helper to construct this  function.\n\nKeyword arguments\n\nδ = 1e-10: A small number constraining the random search around a particular point. The interpretation of this  number will depend on the probability distribution chosen  for the sampling (see stagger_mode).\nTm = 30: The minimum number of steps of ds before  the trajectory escapes from the bounding box defined by isinside. \nmax_steps = 10^5: The search for a new candidate point may  fail at some point. If the search fails after max_steps,  a new initial point is set and the method starts from a new point.\nmax_escape_time = 10000: If the trajectory stays in the  defined region after max_escape_time steps, there is probably an attractor in the region and the algorithm will throw an error. \nstagger_mode = :exp: There are several ways to produce  candidate points x to fulfill the condition T(x) > Tm.  The available methods are: \n:exp: A candidate is sampled from a truncated exponential  distribution in a random direction u around the current x such that x_c = x + u*r. r = 10^-s with s taken from a uniform distribution in [-15, δ]. \n:unif: The next candidate is x_c = x + u*r with r  taken from a uniform distribution [0,δ] and u a random  direction around x. \n:adaptive: The next candidate is x_c = x + u*r with  r drawn from a gaussian distribution with variance  δ  and mean zero. The variance is adapted according to a free parameter γ such that: δ = δ/γ if no candidate is found and δ = δ*γ when it succeeds. \nγ = 1.1: It is free parameter for the adaptive stagger method :adaptive. \nδ₀ = 1.0: This is the radius for the first stagger  trajectory search. The algorithm looks for a point  sufficiently close to the saddle before switching to the  stagger-and-step routine. The search radius must be large  enough to find a suitable initial candidate.  To type δ₀ use \\delta<TAB>\\_0<TAB>.\nrng::AbstractRNG = Xoshiro():  Random number generator. Use this for reproducibility.\n\nDescription\n\nThe method relies on the stagger-and-step algorithm that  searches initial conditions close to the saddle with escapes time  T(x_n) > Tm. The function T represents the time at which the trajectory with initial condition x_n steps out  from a region defined by the user (see the argument isinside). This time is a discrete or continuous variable depending on  the dynamical system ds.\n\nGiven the dynamical mapping F, if the step x_{n+1} =  F(x_n) fulfills the condition T(x_{n+1}) > Tm we accept  this next point, this is the step part of the method. If  not, the method search randomly the next point in a  neighborhood following a given probability distribution, this  is the stagger part. The stagger process sometimes fails to find  a new candidate and a new starting point of the trajectory is chosen  within the defined region. See the keyword argument  stagger_mode for the different available methods.   \n\nThe method produces a pseudo-trajectory of N points δ-close to the stable manifold of the chaotic saddle. \n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.tipping_probabilities","page":"API","title":"Attractors.tipping_probabilities","text":"tipping_probabilities(BoA_before::ArrayBasinsOfAttraction, BoA_after::ArrayBasinsOfAttraction) → P\ntipping_probabilities(basins_before, basins_after) → P\n\nReturn the tipping probabilities of the computed basins before and after a change in the system parameters (or time forcing), according to the definition of (Kaszás et al., 2019).\n\nThe input basins are integer-valued arrays, where the integers enumerate the attractor, e.g. the output of basins_of_attraction.\n\nThe second function signature exists for backwards compatibility. \n\nDescription\n\nLet mathcalB_i(p) denote the basin of attraction of attractor A_i at parameter(s) p. Kaszás et al (Kaszás et al., 2019) define the tipping probability from A_i to A_j, given a parameter change in the system of p_- to p_+, as\n\nP(A_i to A_j  p_- to p_+) =\nfracmathcalB_j(p_+) cap mathcalB_i(p_-)mathcalB_i(p_-)\n\nwhere cdot is simply the volume of the enclosed set. The value of P(A_i to A_j  p_- to p_+) is P[i, j]. The equation describes something quite simple: what is the overlap of the basin of attraction of A_i at p_- with that of the attractor A_j at p_+. If basins_before, basins_after contain values of -1, corresponding to trajectories that diverge, this is considered as the last attractor of the system in P.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.minimal_critical_shock","page":"API","title":"Attractors.minimal_critical_shock","text":"minimal_critical_shock(mapper::AttractorMapper, u0, search_area, algorithm; kw...)\n\nReturn the minimal critical shock for the initial point u0 according to the specified algorithm given a mapper that satisfies the id = mapper(u0) interface (see AttractorMapper if you are not sure which mappers do that). The output mfs is a vector like u0.\n\nThe mapper contains a reference to a DynamicalSystem. The options for algorithm are: MCSBruteForce or MCSBlackBoxOptim. For high dimensional systems MCSBlackBoxOptim is likely more accurate.\n\nThe search_area dictates the state space range for the search of the mfs. It can be a 2-tuple of (min, max) values, in which case the same values are used for each dimension of the system in mapper. Otherwise, it can be a vector of 2-tuples, each for each dimension of the system. The search area is defined w.r.t. to u0 (i.e., it is the search area for perturbations of u0).\n\nAn alias to minimal_critical_shock is excitability_threshold. Other names for the concept are or stability threshold or minimal fatal shock.\n\nKeyword arguments\n\nmetric = LinearAlgebra.norm: a metric function that gives the norm of a perturbation vector. This keyword is ignored for the MCSBruteForce algorithm.\ntarget_id = nothing: when not nothing, it should be an integer or a vector of integers corresponding to target attractor label(s). Then, the MFS is estimated based only on perturbations that lead to the target attractor(s).\n\nDescription\n\nThe minimal critical shock is defined as the smallest-norm perturbation of the initial point u0 that will lead it a different basin of attraction than the one it was originally in. This alternative basin is not returned, do mapper(u0 .+ mfs) if you need the ID.\n\nThe minimal critical shock has many names. Many papers computed this quantity without explicitly naming it, or naming it something simple like \"distance to the threshold\". The first work that proposed the concept as a nonlocal stability quantifier was by (Klinshov et al., 2015) with the name \"stability threshold\". Here we use the name of (Halekotte and Feudel, 2020).\n\nOur implementation is generic and works for any dynamical system, using either black box optimization or brute force searching approaches and the unique interface of Attractors.jl for mapping initial conditions to attractors. In contrast to (Klinshov et al., 2015) or (Halekotte and Feudel, 2020), our implementation does not place any assumptions on the nature of the dynamical system, or whether the basin boundaries are smooth.\n\nThe excitability threshold is a concept nearly identical, however, instead of looking for a perturbation that simply brings us out of the basin, we look for the smallest perturbation that brings us into specified basin(s). This is enabled via the keyword target_id.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.MCSBlackBoxOptim","page":"API","title":"Attractors.MCSBlackBoxOptim","text":"MCSBlackBoxOptim(; kwargs...)\n\nThe black box derivative-free optimization algorithm used in minimal_critical_shock.\n\nKeyword arguments\n\nguess = nothing: a initial guess for the minimal critical shock given to the optimization algorithm. If not nothing, random_algo below is ignored.\nmax_steps = 10000: maximum number of steps for the optimization algorithm.\npenalty = 1000.0: penalty value for the objective function for perturbations that do not lead to a different basin of attraction. This value is added to the norm of the perturbation and its value should be much larger than the typical sizes of the basins of attraction.\nprint_info: boolean value, if true, the optimization algorithm will print information on the evaluation steps of objective function, default = false.\nrandom_algo = MCSBruteForce(100, 100, 0.99): an instance of MCSBruteForce that can be used to provide an initial guess.\nbbkwargs = NamedTuple(): additional keyword arguments propagated to BlackBoxOptim.bboptimize for selecting solver, accuracy, and more.\n\nDescription\n\nThe algorithm uses BlackBoxOptim.jl and a penalized objective function to minimize. y function used as a constraint function. So, if we hit another basin during the search we encourage the algorithm otherwise we punish it with some penalty. The function to minimize is (besides some details):\n\nfunction mfs_objective(perturbation, u0, mapper, penalty)\n    dist = norm(perturbation)\n    if mapper(u0 + perturbation) == mapper(u0)\n        # penalize if we stay in the same basin:\n        return dist + penalty\n    else\n        return dist\n    end\nend\n\nUsing an initial guess can be beneficial to both performance and accuracy, which is why the output of a crude MCSBruteForce is used to provide a guess. This can be disabled by either passing a guess vector explicitly or by giving nothing as random_algo.\n\n\n\n\n\n","category":"type"},{"location":"api/#Attractors.MCSBruteForce","page":"API","title":"Attractors.MCSBruteForce","text":"MCSBruteForce(; kwargs...)\n\nThe brute force randomized search algorithm used in minimal_critical_shock.\n\nIt consists of two steps: random initialization and sphere radius reduction. On the first step, the algorithm generates random perturbations within the search area and records the perturbation that leads to a different basin but with the smallest magnitude. With this obtained perturbation it proceeds to the second step. On the second step, the algorithm generates random perturbations on the surface of the hypersphere with radius equal to the norm of the perturbation found in the first step. It reduces the radius of the hypersphere and continues searching for the better result with a smaller radius. Each time a better result is found, the radius is reduced further.\n\nThe algorithm records the perturbation with smallest radius that leads to a different basin.\n\nBecause this algorithm is based on hyperspheres, it assumes the Euclidean norm as the metric.\n\nKeyword arguments\n\ninitial_iterations = 10000: number of random perturbations to try in the first step of the algorithm.\nsphere_iterations = 10000: number of steps while initializing random points on hypersphere and decreasing its radius.\nsphere_decrease_factor = 0.999: factor by which the radius of the hypersphere is decreased (at each step the radius is multiplied by this number). Number closer to 1 means more refined accuracy.\nseed = rand(1:10000): seed for the random number generator used when sampling random perturbations.\n\n\n\n\n\n","category":"type"},{"location":"api/#Attractors.global_continuation","page":"API","title":"Attractors.global_continuation","text":"global_continuation(gca::GlobalContinuationAlgorithm, prange, pidx, ics; kwargs...)\nglobal_continuation(gca::GlobalContinuationAlgorithm, pcurve, ics; kwargs...)\n\nFind and continue attractors (or representations of attractors) and the fractions of their basins of attraction across a parameter curve pcurve by sampling given initial conditions ics according to algorithm gca.\n\nPossible subtypes of a GlobalContinuationAlgorithm are:\n\nAttractorSeedContinueMatch\nFeaturizeGroupAcrossParameter\n\nics are the initial conditions to use when sampling the state space. They can be specified in one of three ways:\n\nA set vector of initial conditions (vector of vectors).\nA 0-argument function that generates random initial conditions.\nThe special type PerParameterInitialConditions that allows different initial conditions for different parameter values.\n\nReturn:\n\nfractions_cont::Vector{Dict{Int, Float64}}. The fractions of basins of attraction. fractions_cont[i] is a dictionary mapping attractor IDs to their basin fraction at the i-th parameter combination.\nThis output is different if you are using StabilityMeasuresAccumulator  in combination with AttractorSeedContinueMatch. See the docstring  of StabilityMeasuresAccumulator for more details.\nattractors_cont::Vector{Dict{Int, <:Any}}. The continued attractors. attractors_cont[i] is a dictionary mapping attractor ID to the attractor set at the i-th parameter combination.\n\nSee the function continuation_series if you wish to transform the output to an alternative format.\n\nKeyword arguments\n\nshow_progress = true: display a progress bar of the computation.\nsamples_per_parameter = 100: amount of initial conditions sampled at each parameter combination from ics if ics is a function instead of set initial conditions.\n\nDescription\n\nglobal_continuation is the central function of the framework for global stability analysis illustrated in (Datseris et al., 2023).\n\nThe global continuation algorithm typically references an AttractorMapper which is used to find the attractors and basins of a dynamical system. Additional arguments that control how to continue/track/match attractors across a parameter range are given when creating gca.\n\nThe basin fractions and the attractors (or some representation of them) are continued across the parameter range prange, for the parameter of the system with index pidx (any index valid in DynamicalSystems.set_parameter! can be used). In contrast to traditional continuation (see online Tutorial for a comparison), global continuation can be performed over arbitrary user-defined curves in parameter space. The second call signature with pcurve allows for this possibility. In this case pcurve is a vector of iterables, where each iterable maps parameter indices to parameter values. These iterables can be dictionaries, named tuples, Vector{Pair}, anything that can be given in set_parameters!. The sequence of the iterables defines a curve in parameter space. In fact, the version with prange, pidx simply defines pcurve = [[pidx => p] for p in prange] and calls the second method.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.GlobalContinuationAlgorithm","page":"API","title":"Attractors.GlobalContinuationAlgorithm","text":"GlobalContinuationAlgorithm\n\nSupertype of all algorithms used in global_continuation. Each algorithm typically references an AttractorMapper, as well as contains more information for how to continue/track/match attractors across a parameter range.\n\nSee global_continuation for more.\n\n\n\n\n\n","category":"type"},{"location":"api/#Attractors.continuation_series","page":"API","title":"Attractors.continuation_series","text":"continuation_series(continuation_info, fillval = NaN)\n\nTransform a continuation quantity (a vector of dictionaries, each dictionary mapping attractor IDs to values of same type as fillval) to a dictionary of vectors where the k dictionary entry is the series of the continuation quantity corresponding to attractor with ID k. fillval denotes the value to assign in the series if the attractor with ID k does not exist at this particular series index.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.AttractorSeedContinueMatch","page":"API","title":"Attractors.AttractorSeedContinueMatch","text":"AttractorSeedContinueMatch(mapper, matcher = MatchBySSSetDistance(); seeding)\n\nA global continuation method for global_continuation. mapper is any subtype of AttractorMapper which implements extract_attractors, i.e., it finds the actual attractors. matcher is a configuration of how to match attractor IDs, see IDMatcher for more options.\n\nDescription\n\nThis is a general/composable global continuation method based on a 4-step process:\n\nSeed initial conditions from previously found attractors\nPropagate those forwards to \"continue\" previous attractors\nEstimate basin fractions and potentially find new attractors\nMatch attractors\n\nStep 0 - Finding initial attractors\n\nAt the first parameter slice of the global continuation process, attractors and their fractions are found using the given mapper and basins_fractions. See the mapper documentation and AttractorMapper for details on how this works. Then, from the second parameter onwards the continuation occurs.\n\nStep 1 - Seeding initial conditions\n\nInitial conditions can be seeded from previously found attractors. This is controlled by the seeding keyword, which must be a function that given a StateSpaceSet (an attractor), it returns an iterator of initial conditions. By default the first point of an attractor is provided as the only seed.\n\nSeeding can be turned off by providing the dummy function seeding = A -> [], i.e., it always returns an empty iterator and hence no seeds and we skip to step 2.\n\nStep 2 - Continuing the seeds\n\nThe dynamical system referenced by the mapper is now set to the new parameter value. The seeds are run through the mapper to converge to attractors at the new parameter value. Seeding initial conditions close to previous attractors increases the probability that if an attractor continues to exist in the new parameter, it is found. Additionally, for some mappers this seeding process improves the accuracy as well as performance of finding attractors, see e.g. discussion in (Datseris et al., 2023).\n\nThis seeding works for any mapper, regardless of if they can map individual initial conditions with the mapper(u0) syntax! If this syntax isn't supported, steps 2 and 3 are done together.\n\nStep 3 - Estimate basins fractions\n\nAfter the special seeded initial conditions are mapped to attractors, attractor basin fractions are computed by sampling additional initial conditions using the provided ics in global_continuation. I.e., exactly as in basins_fractions. Naturally, during this step new attractors may be found, besides those found using the \"seeding from previous attractors\".\n\nStep 4 - Matching\n\nNormally the ID an attractor gets assigned is somewhat a random integer. Therefore, to ensure a logical output of the global continuation process, attractors need to be \"matched\". This means: attractor and fractions must have their IDs changed, so that attractors that are \"similar\" to those at a previous parameter get assigned the same ID.\n\nWhat is \"similar enough\" is controlled by the matcher input. The default matcher MatchBySSSetDistance matches sets which have small distance in state space. The matching algorithm itself can be quite involved, so read the documentation of the matcher for how matching works.\n\nA note on matching: the MatchBySSSetDistance can also be used after the continuation is completed, as it only requires as input the state space sets (attractors), without caring at which parameter each attractor exists at. If you don't like the final matching output, you may use a different instance of MatchBySSSetDistance and call match_sequentially! again on the output, without having to recompute the whole global continuation!\n\nStep 5 - Finish\n\nAfter matching the parameter(s) is incremented. Steps 1-4 repeat until all parameter values are exhausted.\n\nFurther note\n\nThis global continuation method is a generalization of the \"RAFM\" continuation described in (Datseris et al., 2023). This continuation method is still exported as RecurrencesFindAndMatch.\n\n\n\n\n\n","category":"type"},{"location":"api/#Attractors.RecurrencesFindAndMatch","page":"API","title":"Attractors.RecurrencesFindAndMatch","text":"RecurrencesFindAndMatch <: GlobalContinuationAlgorithm\nRecurrencesFindAndMatch(mapper::AttractorsViaRecurrences; kwargs...)\n\nA method for global_continuation as in (Datseris et al., 2023) that is based on the recurrences algorithm for finding attractors (AttractorsViaRecurrences) and then matching them according to their state space distance.\n\nKeyword arguments\n\ndistance = Centroid(), threshold = Inf: passed to MatchBySSSetDistance.\nseeds_from_attractor: A function that takes as an input an attractor and returns an iterator of initial conditions to be seeded from the attractor for the next parameter slice. By default, we sample only the first stored point on the attractor.\n\nDescription\n\nRecurrencesFindAndMatch is a wrapper type. It is has been generalized by AttractorSeedContinueMatch. It is still exported for backwards compatibility and to have a clear reference to the original algorithm developed in (Datseris et al., 2023).\n\nThe source code of RecurrencesFindAndMatch is trival: it takes the given mapper, it initializes a MatchBySSSetDistance, and along with seeds_from_attractor it makes the AttractorSeedContinueMatch instance. This is the process described in (Datseris et al., 2023), whereby attractors are found using the recurrences algorithm AttractorsViaRecurrences and they are then matched by their distance in state space MatchBySSSetDistance.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.aggregate_attractor_fractions","page":"API","title":"Attractors.aggregate_attractor_fractions","text":"aggregate_attractor_fractions(\n    fractions_cont, attractors_cont, featurizer, group_config [, info_extraction]\n)\n\nAggregate the already-estimated curves of fractions of basins of attraction of similar attractors using the same pipeline used by GroupingConfig. The most typical application of this function is to transform the output of a global_continuation with RecurrencesFindAndMatch so that similar attractors, even across parameter space, are grouped into one \"attractor\". Thus, the fractions of their basins are aggregated.\n\nYou could also use this function to aggregate attractors and their fractions even in a single parameter configuration, i.e., using the output of basins_fractions.\n\nThis function is useful in cases where you want the accuracy and performance of AttractorsViaRecurrences, but you also want the convenience of \"grouping\" similar attractrors like in AttractorsViaFeaturizing for presentation or analysis purposes. For example, a high dimensional model of competition dynamics across multispecies may have extreme multistability. After finding this multistability however, one may care about aggregating all attractors into two groups: where a given species is extinct or not. This is the example highlighted in our documentation, in Extinction of a species in a multistable competition model.\n\nInput\n\nfractions_cont: a vector of dictionaries mapping labels to basin fractions.\nattractors_cont: a vector of dictionaries mapping labels to attractors. 1st and 2nd argument are exactly like the return values of global_continuation with RecurrencesFindAndMatch (or, they can be the return of basins_fractions).\nfeaturizer: a 1-argument function to map an attractor into an appropriate feature to be grouped later. Features expected by GroupingConfig are SVector.\ngroup_config: a subtype of GroupingConfig.\ninfo_extraction: a function accepting a vector of features and returning a description of the features. I.e., exactly as in FeaturizeGroupAcrossParameter. The 5th argument is optional and defaults to the centroid of the features.\n\nReturn\n\naggregated_fractions: same as fractions_cont but now contains the fractions of the aggregated attractors.\naggregated_info: dictionary mapping the new labels of aggregated_fractions to the extracted information using info_extraction.\n\nClustering attractors directly\n\n(this is rather advanced)\n\nYou may also use the DBSCAN clustering approach here to group attractors based on their state space distance (the set_distance) by making a distance matrix as expected by the DBSCAN implementation. For this, use identity as featurizer, and choose GroupViaClustering as the group_config with clust_distance_metric = set_distance and provide a numerical value for optimal_radius_method when initializing the GroupViaClustering, and also, for the info_extraction argument, you now need to provide a function that expects a vector of StateSpaceSets and outputs a descriptor. E.g., info_extraction = vector -> mean(mean(x) for x in vector).\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.FeaturizeGroupAcrossParameter","page":"API","title":"Attractors.FeaturizeGroupAcrossParameter","text":"FeaturizeGroupAcrossParameter <: GlobalContinuationAlgorithm\nFeaturizeGroupAcrossParameter(mapper::AttractorsViaFeaturizing; kwargs...)\n\nA method for global_continuation. It uses the featurizing approach discussed in AttractorsViaFeaturizing and hence requires an instance of that mapper as an input. When used in global_continuation, features are extracted and then grouped across a parameter range. Said differently, all features of all initial conditions across all parameter values are put into the same \"pool\" and then grouped as dictated by the group_config of the mapper. After the grouping is finished the feature label fractions are distributed to each parameter value they came from.\n\nThis continuation method is based on, but strongly generalizes, the approaches in the papers (Gelbrecht et al., 2020) and (Stender and Hoffmann, 2021).\n\nKeyword arguments\n\ninfo_extraction::Function a function that takes as an input a vector of feature-vectors (corresponding to a cluster) and returns a description of the cluster. By default, the centroid of the cluster is used. This is what the attractors_cont contains in the return of global_continuation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Attractors.MatchBySSSetDistance","page":"API","title":"Attractors.MatchBySSSetDistance","text":"MatchBySSSetDistance(; distance = Centroid(), threshold = Inf, use_vanished = false)\n\nA matcher type that matches IDs by the distance of their corresponding state space sets.\n\nKeyword arguments\n\ndistance = Centroid(): distance to match by, given to setsofsets_distances.\nthreshold = Inf: sets with distance larger than the threshold are guaranteed to not be mapped to each other.\nuse_vanished = !isinf(threshold): value of the keyword use_vanished when used in match_sequentially!.\n\nDescription\n\nIn this matcher the values compared are StateSpaceSets which in most cases represent attractors in the state space, but may also represent any other set such as a group of features.\n\nHere is how this matcher works: (recall in this conversation that sets/attractors are stored in dictionaries, mapping keys/IDs to the sets, and we want to match keys in the \"new\" dictionary (a₊) to those in the \"old\" dictionary (a₋)).\n\nThe distance between all possible pairs of sets between the \"old\" sets and \"new\" sets is computed as a formal distance between sets. This is controlled by the distance option, itself given to the lower-level setsofsets_distances function, so distance can be whatever that function accepts. That is, one of Centroid, Hausdorff, StrictlyMinimumDistance, or any arbitrary user-provided function f that given two sets f(A, B) it returns a positive number (their distance).\n\nSets (in particular, their corresponding IDs) are then matched according to this distance. First, all possible ID pairs (old, new) are sorted according to the distance of their corresponding sets. The pair with smallest distance is matched. IDs in matched pairs are removed from the matching pool to ensure a unique mapping. Then, the next pair with least remaining distance is matched, and the process repeats until all pairs are exhausted.\n\nAdditionally, you can provide a threshold value. If the distance between two sets is larger than this threshold, then it is guaranteed that the two sets will get assigned different ID in the replacement map, and hence, the set in a₊ gets the next available integer as its ID.\n\n\n\n\n\n","category":"type"},{"location":"api/#Attractors.MatchByBasinEnclosure","page":"API","title":"Attractors.MatchByBasinEnclosure","text":"MatchByBasinEnclosure(; kw...) <: IDMatcher\n\nA matcher that matches attractors by whether they are enclosed in the basin of a new attractor or not.\n\nKeyword arguments\n\nε = nothing: distance threshold given to AttractorsViaProximity. If nothing, it is estimated as a quarter of the minimum distance of centroids (in contrast to the default more accurate estimation in AttractorsViaProximity).\nΔt = 1, consecutive_lost_steps = 1000: also given to AttractorsViaProximity. We have not yet decided what should happen to attractors that did not converge to one of the current attractors within this number of steps. At the moment they get assigned the next available free ID but this may change in future releases.\ndistance = Centroid(): metric to estimate distances between state space sets in case there are co-flowing attractors, see below.\nseeding = A -> A[end]: how to select a point from the attractor to see if it is enclosed in the basin of a new attractor.\n\nDescription\n\nAn attractor A₋ is a set in a state space that occupies a particular region (or, a single point, if it is a fixed point). This region is always within the basin of attraction of said attractor. When the parameter of the dynamical system is incremented, the attractors A₊ in the new parameter have basins that may have changed in shape and size.\n\nThe new attractor A₊ is \"matched\" (i.e., has its ID changed) to the old attractor A₋ attractor if A₋ is located inside the basin of attraction of A₊. To see if A₋ is in the basin of A₊, we first pick a point from A₋ using the seeding keyword argument. By default this is the last point on the attractor, but it could be anything else, including the centroid of the attractor (mean(A)). This point is given as an initial condition to an AttractorsViaProximity mapper that maps initial conditions to the ₊ attractors when the trajectories from the initial conditions are ε-close to the ₊ attractors.\n\nThere can be the situation where multiple ₋ attractors converge to the same ₊ attractor, which we call \"coflowing attractors\". In this scenario matching is prioritized for the ₋ attractor that is closest to the ₊ in terms of state space set distance, which is estimated with the distance keyword, which can be anything MatchBySSSetDistance accepts. The closest ₊ attractor gets the ID of the ₋ closest attractor that converge to it.\n\nBasin enclosure is a concept similar to \"basin (in)stability\" in (Ritchie et al., 2023): attractors that quantify as \"basin stable\" are matched.\n\n\n\n\n\n","category":"type"},{"location":"api/#Attractors.MatchByBasinOverlap","page":"API","title":"Attractors.MatchByBasinOverlap","text":"MatchByBasinOverlap(threshold = Inf)\n\nA matcher that matches IDs given full basins of attraction.\n\nDescription\n\nThis matcher cannot be used in with the generic global continuation method of AttractorSeedContinueMatch. This matcher matches IDs of attractors whose basins of attraction before and after b₋, b₊ have the most overlap (in pixels). This overlap is normalized in 0-1 (with 1 meaning 100% of a basin in b₋ is overlaping with some other basin in b₊). Therefore, the values this matcher compares are full basins of attraction, not attractors themselves (hence why it can't be given to AttractorSeedContinueMatch). Rather, you may use this matcher with matching_map.\n\nThe threshold can dissallow matching between basins that do not have enough overlap. Basins whose overlap is less than 1/threshold are guaranteed to get assined different IDs. For example: for threshold = 2 basins that have ≤ 50% overlap get different IDs guaranteed. By default, there is no threshold.\n\nThe information of the basins of attraction is typically an Array, or  a ArrayBasinsOfAttraction type , i.e. the direct output of basins_of_attraction. For convenience, as well as backwards compatibility, when using matching_map with this mapper you may provide two Arrays b₊, b₋ representing basins of attraction after and before, and the conversion to dictionaries will happen internally as it is supposed to. Similarly two ArrayBasinsOfAttraction types  for before and after can be used, BoA₊ and BoA₋. To replace the IDs in b₊ given the replacement map just call replace!(b₊, rmap...), or equivalently replace!(BoA₊.basins, rmap...), or use the in-place version matching_map! directly.\n\nA lower-level input for this matcher in matching_map can be dictionaries mapping IDs to vectors of cartesian indices, where the indices mean which parts of the state space belong to which ID\n\n\n\n\n\n","category":"type"},{"location":"api/#Attractors.IDMatcher","page":"API","title":"Attractors.IDMatcher","text":"IDMatcher\n\nSupertype of all \"matchers\" that match can IDs labelling attractors. Currently available matchers:\n\nMatchBySSSetDistance\nMatchByBasinEnclosure\nMatchByBasinOverlap\n\nMatchers implement an extendable interface based on the function matching_map. This function is used by the higher level function match_sequentially!, which can be called after any call to a global continuation to match attractors differently, if the matching used originally during the continuation was not the best.\n\n\n\n\n\n","category":"type"},{"location":"api/#Attractors.matching_map","page":"API","title":"Attractors.matching_map","text":"matching_map(\n    a₊::Dict, a₋::Dict, matcher;\n    ds::DynamicalSystem, p, pprev, next_id\n) → rmap\n\nGiven dictionaries a₊, a₋ mapping IDs to values, return a replacement map: a dictionary mapping the IDs (keys) in dictionary a₊ to IDs (keys) in dictionary a₋, so that so that values in a₊ that are the \"closest\" to values in a₋ get assigned the same key as in a₋. In this way keys of a₊ are \"matched\" to keys of a₋. Use swap_dict_keys to apply rmap to a₊ or to other dictionaries with same keys as a₊.\n\nHow matching happens, i.e., how \"closeness\" is defined, depends on the algorithm matcher.\n\nThe values contained in a₊, a₋ can be anything supported by matcher. Within Attractors.jl they are typically StateSpaceSets representing attractors. Typically the +,- mean after and before some change of parameter of a dynamical system.\n\nmatching_map always returns an empty dictionary of either a₊, a₋ is empty.\n\nKeyword arguments\n\nds: the dynamical system that generated a₊, a₋.\np, pprev: the parameters corresponding to a₊, a₋. Both need to be iterables mapping parameter index to parameter value (such as Dict, Vector{Pair}, etc., so whatever can be given as input to DynamicalSystems.set_parameters!).\nnext_id = next_free_id(a₊, a₋): the ID to give to values of  a₊ that cannot be matched to a₋ and hence must obtain a new unique ID.\n\nSome matchers like MatchBySSSetDistance do not utilize ds, p, pprev in any way while other matchers like MatchByBasinEnclosure do, and those require expliticly giving values to ds, p, pprev as their default values is just nothing.\n\n\n\n\n\nmatching_map(BoA₊::ArrayBasinsOfAttraction, BoA₋::ArrayBasinsOfAttraction, matcher::MatchByBasinOverlap)\nmatching_map(b₊::AbstractArray, b₋::AbstractArray, matcher::MatchByBasinOverlap)\n\nSpecial case of matching_map where instead of having as input dictionaries mapping IDs to values, we have Arrays which represent basins of attraction and whose elements are the IDs.\n\nThe second function signature exists for backwards compatibility. \n\nSee MatchByBasinOverlap for how matching works.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.matching_map!","page":"API","title":"Attractors.matching_map!","text":"matching_map!(a₊, a₋, matcher; kw...) → rmap\n\nConvenience function that first calls matching_map and then replaces the IDs in a₊ with this rmap.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.match_sequentially!","page":"API","title":"Attractors.match_sequentially!","text":"match_sequentially!(dicts::Vector{Dict{Int, Any}}, matcher::IDMatcher; kw...)\n\nMatch the dicts, a vector of dictionaries mapping IDs (integers) to values, according to the given matcher by sequentially applying the matching_map function to all elements of dicts besides the first one.\n\nIn the context of Attractors.jl dicts are typically dictionaries mapping IDs to attractors (StateSpaceSets), however the function is generic and would work for any values that matcher works with.\n\nReturn rmaps, which is a vector of dictionaries. rmaps[i] contains the matching_map for dicts[i+1], i.e., the pairs of old => new IDs.\n\nKeyword arguments\n\npcurve = nothing: the curve of parameters along which the continuation occured, from which to extract the p, pprev values given to matching_map. See global_continuation if you are unsure what this means.\nds = nothing: propagated to matching_map.\nretract_keys::Bool = true: If true at the end the function will \"retract\" keys (i.e., make the integers smaller integers) so that all unique IDs are the 1-incremented positive integers. E.g., if the IDs where 1, 6, 8, they will become 1, 2, 3. The special ID -1 is unaffected by this.\nuse_vanished = false: If use_vanised = true, then IDs (and their corresponding sets) that existed before but have vanished are kept in \"memory\" when it comes to matching: the current dictionary values (the attractor sets) are compared to the latest instance of all values that have ever existed, each with a unique ID, and get matched to their closest ones. The value of this keyword is obtained from the matcher.\n\n\n\n\n\nmatch_sequentially!(continuation_quantity::Vector{Dict}, rmaps::Vector{Dict})\n\nDo the same as in match_sequentially! above, now given the vector of matching maps, and for any arbitrary quantity that has been tracked in the global continuation. continuation_quantity can for example be fractions_cont from global_continuation.\n\n\n\n\n\n","category":"function"},{"location":"api/#StateSpaceSets.Centroid","page":"API","title":"StateSpaceSets.Centroid","text":"Centroid(metric = Euclidean())\n\nA distance that can be used in set_distance. The Centroid method returns the distance (according to metric) between the centroids (a.k.a. centers of mass) of the sets.\n\nmetric can be any function that takes in two static vectors are returns a positive definite number to use as a distance (and typically is a Metric from Distances.jl).\n\n\n\n\n\n","category":"type"},{"location":"api/#StateSpaceSets.Hausdorff","page":"API","title":"StateSpaceSets.Hausdorff","text":"Hausdorff(metric = Euclidean())\n\nA distance that can be used in set_distance. The Hausdorff distance is the greatest of all the distances from a point in one set to the closest point in the other set. The distance is calculated with the metric given to Hausdorff which defaults to Euclidean.\n\nHausdorff is 2x slower than StrictlyMinimumDistance, however it is a proper metric in the space of sets of state space sets.\n\nThis metric only works for StateSpaceSets whose elements are SVectors.\n\nFor developers: set_distance can take keywords tree1, tree2 that are the KDTrees of the first and second sets respectively.\n\n\n\n\n\n","category":"type"},{"location":"api/#StateSpaceSets.StrictlyMinimumDistance","page":"API","title":"StateSpaceSets.StrictlyMinimumDistance","text":"StrictlyMinimumDistance([brute = false,] [metric = Euclidean(),])\n\nA distance that can be used in set_distance. The StrictlyMinimumDistance returns the minimum distance of all the distances from a point in one set to the closest point in the other set. The distance is calculated with the given metric.\n\nThe brute::Bool argument switches the computation between a KDTree-based version, or brute force (i.e., calculation of all distances and picking the smallest one). Brute force performs better for sets that are either large dimensional or have a small amount of points. Deciding a cutting point is not trivial, and is recommended to simply benchmark the set_distance function to make a decision.\n\nIf brute = false this metric only works for StateSpaceSets whose elements are SVectors.\n\nFor developers: set_distance can take a keyword tree2 that is the KDTree of the second set.\n\n\n\n\n\n","category":"type"},{"location":"api/#StateSpaceSets.set_distance","page":"API","title":"StateSpaceSets.set_distance","text":"set_distance(ssset1, ssset2 [, distance])\n\nCalculate a distance between two StateSpaceSets, i.e., a distance defined between sets of points, as dictated by distance.\n\nPossible distance types are:\n\nCentroid, which is the default, and 100s of times faster than the rest\nHausdorff\nStrictlyMinimumDistance\nAny function f(A, B) that returns the distance between two state space sets A, B.\n\n\n\n\n\n","category":"function"},{"location":"api/#StateSpaceSets.setsofsets_distances","page":"API","title":"StateSpaceSets.setsofsets_distances","text":"setsofsets_distances(a₊, a₋ [, distance]) → distances\n\nCalculate distances between sets of StateSpaceSets. Here  a₊, a₋ are containers of StateSpaceSets, and the returned distances are dictionaries of distances. Specifically, distances[i][j] is the distance of the set in the i key of a₊ to the j key of a₋. Distances from a₋ to a₊ are not computed at all, assumming symmetry in the distance function.\n\nThe distance can be anything valid for set_distance.\n\nContainers a₊, a₋ can be empty but they must be concretely typed.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.unique_keys","page":"API","title":"Attractors.unique_keys","text":"unique_keys(v::Iterator{<:AbstractDict})\n\nGiven a vector of dictionaries, return a sorted vector of the unique keys that are present across all dictionaries.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.swap_dict_keys!","page":"API","title":"Attractors.swap_dict_keys!","text":"swap_dict_keys!(d::Dict, matching_map::Dict)\n\nSwap the keys of a dictionary d given a matching_map which maps old keys to new keys. Also ensure that a swap can happen at most once, e.g., if input d has a key 4, and rmap = Dict(4 => 3, 3 => 2), then the key 4 will be transformed to 3 and not further to 2.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.next_free_id","page":"API","title":"Attractors.next_free_id","text":"next_free_id(new::Dict, old::Dict)\n\nReturn the minimum key of the \"new\" dictionary that doesn't exist in the \"old\" dictionary. If one of the two dictionaries are empty, return its maximum key + 1. If both are empty, return 1.\n\nThe function assumes tha the dictionary keys are integers.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.StabilityMeasuresAccumulator","page":"API","title":"Attractors.StabilityMeasuresAccumulator","text":"StabilityMeasuresAccumulator(mapper::AttractorMapper; kwargs...)\n\nA special data structure that allows mapping initial conditions to attractors while at the same time calculating many stability measures in the most efficient way possible. mapper is any instance of an AttractorMapper that implements the id = mapper(u0) syntax. This functionality was developed as part of (Morr et al., 2025). If you use it, cite this paper along with the Attractors.jl publication (Datseris et al., 2023).\n\nStabilityMeasuresAccumulator can be used as any AttractorMapper with library functions such as basins_fractions. After mapping all initial conditions to attractors, the finalize_accumulator function should be called which will return a dictionary of all stability measures estimated by the accumulator. Each dictionary maps the stability measure description (String) to a dictionary mapping attractor IDs to the stability measure value. Calling reset_mapper!(accumulator) cleans up all accumulated measures.\n\nUsing with global_continuation: Since StabilityMeasuresAccumulator is formally an AttractorMapper, it can be used with global_continuation. Simply give it as a mapper input to AttractorSeedContinueMatch and then call global_continuation as normal. The only difference now is that global_continuation will not return just one measure of stability (the basin fraction). Rather, now the first return argument of global_continuation will be a measures_cont, a dictionary mapping stability measures (strings) to vectors of dictionaries. Each vector of dictionaries is similar to fractions_cont of the typical global_continuation: each dictionary maps attractor ID to the corresponding nonlocal stability measure.\n\nUse stability_measures_along_continuation for continuation of stability  measures computed on the basis of an AttractorsViaProximity mapper from already found attractors. This is useful to do for measures related to the convergence time, which is defined more rirogously and is estimated more accurately for a proximity mapper.\n\nKeyword arguments\n\nfinite_time = 1.0: Finite time horizon considered for the computation of the finite_time_basin_stability. Initial coditions with a convergence time larger than finite_time are not considered to be in the respective finite time basin. Convergence time is determined by the mapper.\nweighting_distribution::Distribution: Distribution of uncertain initial conditions used for example in the computation of basin_stability. By default it is a uniform distribution everywhere in the state space.* distance = Centroid(): How to compute the distance between an initial condition u0 and an attractor A. Estimated via set_distance([u0], A, distance).\n\nDescription\n\nStabilityMeasuresAccumulator efficiently uses a single id = mapper(u0) call to accumulate information for many different stability measures corresponding to each attractor of the dynamical system. It accumulates all these different measures when different initial conditions are mapped through it. After enough u0s have been given to the accumulator, they can be finalized (comput maxima or averages) using finalize!(accumulator).\n\nYou can extent this functionality by adding new stability measures as long as their estimation can be done on the basis of the three quantities accumulated: the basin dictionary mapping initial conditions to attractors, the distance of each initial condition to each attractor, and the convergence time of each initial condition.\n\nThe following stability measures are estimated for each attractor (and the returned dictionary maps strings with the names of the measures to the dictionaries containing the measure values for each attractor):\n\nLocal (fixed point) stability measures\n\nThese measures apply only to fixed point attractors. Their value is NaN if an attractor is not a fixed point (length(A) > 1). If an unstable fixed point attractor is recorded (due to an initial condition starting there for example), a value Inf is assigned to all measures. Currently linear measures for discrete time systems are not computed.\n\ncharacteristic_return_time: The reciprocal of the largest real part of the eigenvalues of the Jacobian matrix at the fixed point.\nreactivity: The largest growth rate of the linearized system at the fixed point. See also (Krakovská et al., 2024).\nmaximal_amplification: The maximal (with respect to disturbances) amplification of the linearized system at the attractor over all time.\nmaximal_amplification_time: The time at which the maximal amplification occurs.\n\nNonlocal stability measures\n\nThe information for these nonlocal stability measures is accumulated while initial conditions are mapped to attractors. Afterwards it is aggregated according to the probability density weighting_distribution when calling finalize_accumulator!.\n\nThe word \"distance\" here refers to the distance established by the distance keyword.\n\nmean_convergence_time: The convergence time is determined by the mapper using convergence_time. The mean is computed with respect to the weighting_distribution.\nmaximal_convergence_time: The maximal convergence time of initial conditions to the attractor. Only initial conditions with non-zero probability under weighting_distribution are considered.\nmedian_convergence_time: The median convergence time of initial conditions under the weighting_distribution.\nmean_convergence_pace: The mean convergence pace of initial conditions to the attractor. Similar to the mean convergence time, except that each convergence time is divided by the distance of the respective initial condition to the attractor.\nmaximal_convergence_pace: The maximal convergence pace of initial conditions to the attractor. Only initial conditions with non-zero probability under weighting_distribution are considered.\nmedian_convergence_pace: The median convergence pace of initial conditions under the weighting_distribution.\nminimal_critical_shock_magnitude: The minimal distance of the attractor to the closest non-zero probability point (under weighting_distribution) in a basin of attraction of a different attractor. If only a single attractor exists, the value Inf is assigned.\nmaximal_noncritical_shock_magnitude: The distance of the attractor to the furthest non-zero probability point (under weighting_distribution) of its own basin of attraction. If only a single attractor exists, the value Inf is assigned.\nmean_noncritical_shock_magnitude: same as above but computing the mean under weighting_distribution instead of maximum distance.\nbasin_fraction: The fraction of initial conditions that converge to the attractor.\nbasin_stability: The fraction of initial conditions that converge to the attractor, weighted by weighting_distribution. For the default value of weighting_distribution this is identical to basin_fraction.\nfinite_time_basin_stability: The fraction of initial conditions that converge to the attractor within the time horizon finite_time, weighted by weighting_distribution.\n\n\n\n\n\n","category":"type"},{"location":"api/#Attractors.finalize_accumulator","page":"API","title":"Attractors.finalize_accumulator","text":"finalize_accumulator(accumulator::StabilityMeasuresAccumulator)\n\nReturn a dictionary mapping stability measures (strings) to dictionaries mapping attractor IDs to corresponding measure values. See StabilityMeasuresAccumulator for more.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.stability_measures_along_continuation","page":"API","title":"Attractors.stability_measures_along_continuation","text":"stability_measures_along_continuation(\n    ds::DynamicalSystem, attractors_cont, pcurve, ics;\n    kw...\n)\n\nPerform a global continuation of all stability measures estimated by StabilityMeasuresAccumulator using the found attractors of a previous call to global_continuation using the ds.\n\nThis method is special because it always creates an AttractorsViaProximity mapper for the attractors at a given point along the global continuation, and then estimates the stability measures using StabilityMeasuresAccumulator and the proximity mapper. Realistically you only want to use this method if you are interested in measures related to the convergence time, which is defined more rirogously and is estimated more accurately for a proximity mapper.\n\nKeyword arguments\n\nKeywords ε, finite_time, weighting_distribution are allowed to be Vectors with the same length as pcurve for providing different values for different continuation steps.\n\nε = nothing: given to AttractorsViaProximity.\nproximity_mapper_options = NamedTuple(): extra keywords for AttractorsViaProximity.\ndistance, finite_time, weighting_distribution: given to StabilityMeasuresAccumulator.\nsamples_per_parameter = 1000: how many samples to use when estimating stability measures via StabilityMeasuresAccumulator. Ignored when ics is not a function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.plot_attractors","page":"API","title":"Attractors.plot_attractors","text":"plot_attractors(attractors::Dict{Int, StateSpaceSet}; kwargs...)\n\nPlot the attractors as a scatter plot.\n\nKeyword arguments\n\nAll the common plotting keywords. Particularly important is the access keyword.\nsckwargs = (strokewidth = 0.5, strokecolor = :black,): additional keywords propagated to the Makie.scatter function that plots the attractors.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.heatmap_basins_attractors","page":"API","title":"Attractors.heatmap_basins_attractors","text":"heatmap_basins_attractors(BoA::ArrayBasinsOfAttraction; kwargs...) \nheatmap_basins_attractors(grid, basins, attractors; kwargs...)\n\nPlot a heatmap of found (2-dimensional) basins of attraction and corresponding attractors, i.e., the output of basins_of_attraction.\n\nThe second function signature exists for backwards compatibility\n\nKeyword arguments\n\nAll the common plotting keywords and sckwargs as in plot_attractors.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.shaded_basins_heatmap","page":"API","title":"Attractors.shaded_basins_heatmap","text":"shaded_basins_heatmap(BoA::ArrayBasinsOfAttraction, iterations; kwargs...)\nshaded_basins_heatmap(grid, basins, attractors, iterations; kwargs...)\n\nPlot a heatmap of found (2-dimensional) basins of attraction and corresponding attractors. A matrix iterations with the same size of basins must be provided to shade the color according to the value of this matrix. A small value corresponds to a light color and a large value to a darker tone. This is useful to represent the number of iterations taken for each initial condition to converge. See also convergence_time to store this iteration number.\n\nThe second function signature exists for backwards compatibility\n\nKeyword arguments\n\nshow_attractors = true: shows the attractor on plot\nmaxit = maximum(iterations): clip the values of iterations to\n\nthe value maxit. Useful when there are some very long iterations and keep the range constrained to a given interval.\n\nAll the common plotting keywords.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.plot_basins_curves","page":"API","title":"Attractors.plot_basins_curves","text":"plot_basins_curves(fractions_cont [, prange]; kw...)\n\nPlot the fractions of basins of attraction versus a parameter range/curve, i.e., visualize the output of global_continuation. See also plot_basins_attractors_curves and plot_continuation_curves.\n\nKeyword arguments\n\nstyle = :band: how to visualize the basin fractions. Choices are :band for a band plot with cumulative sum = 1 or :lines for a lines plot of each basin fraction\nseparatorwidth = 1, separatorcolor = \"white\": adds a line separating the fractions if the style is :band\nfiller = NaN: filler value to use for basin fractions for attractor IDs that do not exist at a continuation step when the style is :lines (filler is always 0 for :band style).\naxislegend_kwargs = (position = :lt,): propagated to axislegend if a legend is added\nseries_kwargs = NamedTuple(): propagated to the band or scatterline plot\nAlso all common plotting keywords.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.plot_attractors_curves","page":"API","title":"Attractors.plot_attractors_curves","text":"plot_attractors_curves(attractors_cont, attractor_to_real [, prange]; kw...)\n\nSame as in plot_basins_curves but visualize the attractor dependence on the parameter(s) instead of their basin fraction. The function attractor_to_real takes as input a StateSpaceSet (attractor) and returns a real number so that it can be plotted versus the parameter axis. See also plot_basins_attractors_curves.\n\nSame keywords as plot_continuation_curves.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.plot_basins_attractors_curves","page":"API","title":"Attractors.plot_basins_attractors_curves","text":"plot_basins_attractors_curves(\n    fractions_cont, attractors_cont, a2rs [, prange]\n    kwargs...\n)\n\nConvenience combination of plot_basins_curves and plot_attractors_curves in a multi-panel plot that shares legend, colors, markers, etc. This function allows a2rs to be a Vector of functions, each mapping attractors into real numbers. Below the basins fractions plot, one additional panel is created for each entry in a2rs. a2rs can also be a single function, in which case only one panel is made.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.plot_continuation_curves","page":"API","title":"Attractors.plot_continuation_curves","text":"plot_continuation_curves(continuation_info [, prange]; kwargs...)\n\nSame as in plot_basins_curves but visualize any arbitrary quantity characterizing the continuation. Hence, the continuation_info is of exactly the same format as fractions_cont: a vector of dictionaries, each dictionary mapping attractor IDs to real numbers. continuation_info is meant to accompany attractors_cont in plot_attractors_curves.\n\nTo produce continuation_info from attractors_cont you can do something like:\n\ncontinuation_info = map(attractors_cont) do attractors\n    Dict(k => f(A) for (k, A) in attractors)\nend\n\nwith f your function of interest that returns a real number.\n\nKeyword arguments\n\nseries_kwargs: named tuple of arguments propagated to Makie.scatterlines! that plots the curves.\nAlso all common plotting keywords.\n\n\n\n\n\n","category":"function"},{"location":"api/#Attractors.animate_attractors_continuation","page":"API","title":"Attractors.animate_attractors_continuation","text":"animate_attractors_continuation(\n    ds::DynamicalSystem, attractors_cont, fractions_cont, pcurve; kw...\n)\n\nAnimate how the found system attractors and their corresponding basin fractions change as the system parameter is increased. This function combines the input and output of the global_continuation function into a video output.\n\nThe input dynamical system ds is used to evolve initial conditions sampled from the found attractors, so that the attractors are better visualized. attractors_cont, fractions_cont are the output of global_continuation while ds, pcurve are the input to global_continuation.\n\nKeyword arguments\n\nsavename = \"attracont.mp4\": name of video output file.\nframerate = 4: framerate of video output.\nΔt, T: propagated to trajectory for evolving an initial condition sampled from an attractor.\nAlso all common plotting keywords.\nfigure, axis, fracaxis, legend: named tuples propagated as keyword arguments to the creation of the Figure, the Axis, the \"bar-like\" axis containing the fractions, and the axislegend that adds the legend (if add_legend = true).\nadd_legend = true: whether to display the axis legend.\n\nContinuation plot animation\n\nIn addition to animating the attractors scatterplot, the plot of plot_attractors_curves can be added below the main attractor plot. It is animated by a dashed line that moves as the parameter is changed.\n\nThis is enabled by providing a non-nothing keyword for a2rs, and the behavior of plot is controlled by the following keywords:\n\na2rs: a vector of functions that map attractors to real numbers.\nprange = 1:length(attractors_cont): range of parameter values to plot on the x-axis of the additional plot(s). If given directly to animate_attractors_continuation it is obtained from there.\nseries_kwargs = NamedTuple(): named tuple of arguments propagated to Makie.scatterlines! that plots the curves.\na2rs_ratio = 0.5: the height ratio of the additional plot(s) relative to the main attractor plot.\na2rs_ylabels: vector of y-axis labels for the additional plot(s).\nparameter_name = \"parameter\". Name of the x-axis of the additional plot(s).\nvline_kwargs = (linestyle = :dash, linewidth = 3, color = \"black\"): named tuple of arguments propagated to Makie.vlines! that plots the vertical dashed line moving as the parameter is changed.\n\n\n\n\n\n","category":"function"},{"location":"examples/#examples","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Note that the examples utilize some convenience plotting functions offered by Attractors.jl which come into scope when using Makie (or any of its backends such as CairoMakie), see the visualization utilities for more.","category":"section"},{"location":"examples/#Newton's-fractal-(basins-of-a-2D-map)","page":"Examples for Attractors.jl","title":"Newton's fractal (basins of a 2D map)","text":"using Attractors\nfunction newton_map(z, p, n)\n    z1 = z[1] + im*z[2]\n    dz1 = newton_f(z1, p[1])/newton_df(z1, p[1])\n    z1 = z1 - dz1\n    return SVector(real(z1), imag(z1))\nend\nnewton_f(x, p) = x^p - 1\nnewton_df(x, p)= p*x^(p-1)\n\nds = DiscreteDynamicalSystem(newton_map, [0.1, 0.2], [3.0])\nxg = yg = range(-1.5, 1.5; length = 400)\ngrid = (xg, yg)\n# Use non-sparse for using `basins_of_attraction`\nmapper_newton = AttractorsViaRecurrences(ds, grid;\n    sparse = false, consecutive_lost_steps = 1000\n)\nbasins, attractors = basins_of_attraction(mapper_newton; show_progress = false)\nbasins\n\nattractors\n\nNow let's plot this as a heatmap, and on top of the heatmap, let's scatter plot the attractors. We do this in one step by utilizing one of the pre-defined plotting functions offered by Attractors.jl\n\nusing CairoMakie\nfig = heatmap_basins_attractors(grid, basins, attractors)\n\nInstead of computing the full basins, we could get only the fractions of the basins of attractions using basins_fractions, which is typically the more useful thing to do in a high dimensional system. In such cases it is also typically more useful to define a sampler that generates initial conditions on the fly instead of pre-defining some initial conditions (as is done in basins_of_attraction. This is simple to do:\n\nsampler, = statespace_sampler(grid)\n\nbasins = basins_fractions(mapper_newton, sampler)\n\nin this case, to also get the attractors we simply extract them from the underlying storage of the mapper:\n\nattractors = extract_attractors(mapper_newton)","category":"section"},{"location":"examples/#Shading-basins-according-to-convergence-time","page":"Examples for Attractors.jl","title":"Shading basins according to convergence time","text":"Continuing from above, we can utilize the convergence_and_basins_of_attraction function, and the shaded_basins_heatmap plotting utility function, to shade the basins of attraction based on the convergence time, with lighter colors indicating faster convergence to the attractor.\n\nmapper_newton = AttractorsViaRecurrences(ds, grid;\n    sparse = false, consecutive_lost_steps = 1000\n)\n\nbasins, attractors, iterations = convergence_and_basins_of_attraction(\n    mapper_newton, grid; show_progress = false\n)\n\nshaded_basins_heatmap(grid, basins, attractors, iterations)","category":"section"},{"location":"examples/#Minimal-Critical-Shock","page":"Examples for Attractors.jl","title":"Minimal Critical Shock","text":"Here we find the Minimal Critical Shock (MFS, see minimal_critical_shock) for the attractors (i.e., fixed points) of Newton's fractal\n\nshocks = Dict()\nalgo_bb = Attractors.MCSBlackBoxOptim()\nfor atr in values(attractors)\n    u0 = atr[1]\n    shocks[u0] = minimal_critical_shock(mapper_newton, u0, (-1.5,1.5), algo_bb)\nend\nshocks\n\nTo visualize results we can make use of previously defined heatmap\n\nax =  content(fig[1,1])\nfor (atr, shock) in shocks\n    lines!(ax, [atr, atr + shock]; color = :orange, linewidth = 3)\nend\nfig","category":"section"},{"location":"examples/#Fractality-of-2D-basins-of-the-(4D)-magnetic-pendulum","page":"Examples for Attractors.jl","title":"Fractality of 2D basins of the (4D) magnetic pendulum","text":"In this section we will calculate the basins of attraction of the four-dimensional magnetic pendulum. We know that the attractors of this system are all individual fixed points on the (x, y) plane so we will only compute the basins there. We can also use this opportunity to highlight a different method, the AttractorsViaProximity which works when we already know where the attractors are. Furthermore we will also use a ProjectedDynamicalSystem to project the 4D system onto a 2D plane, saving a lot of computational time!","category":"section"},{"location":"examples/#Computing-the-basins","page":"Examples for Attractors.jl","title":"Computing the basins","text":"First we need to load in the magnetic pendulum from the predefined dynamical systems library\n\nusing Attractors, CairoMakie\nusing PredefinedDynamicalSystems\nds = PredefinedDynamicalSystems.magnetic_pendulum(d=0.2, α=0.2, ω=0.8, N=3)\n\nThen, we create a projected system on the x-y plane\n\npsys = ProjectedDynamicalSystem(ds, [1, 2], [0.0, 0.0])\n\nFor this systems we know the attractors are close to the magnet positions. The positions can be obtained from the equations of the system, provided that one has seen the source code (not displayed here), like so:\n\nattractors = Dict(i => StateSpaceSet([dynamic_rule(ds).magnets[i]]) for i in 1:3)\n\nand then create a\n\nmapper = AttractorsViaProximity(psys, attractors)\n\nand as before, get the basins of attraction\n\nxg = yg = range(-4, 4; length = 201)\ngrid = (xg, yg)\nbasins, = basins_of_attraction(mapper, grid; show_progress = false)\n\nheatmap_basins_attractors(grid, basins, attractors)","category":"section"},{"location":"examples/#Computing-the-uncertainty-exponent","page":"Examples for Attractors.jl","title":"Computing the uncertainty exponent","text":"Let's now calculate the uncertainty_exponent for this system as well. The calculation is straightforward:\n\nusing CairoMakie\nε, f_ε, α = uncertainty_exponent(basins)\nfig, ax = lines(log.(ε), log.(f_ε))\nax.title = \"α = $(round(α; digits=3))\"\nfig\n\nThe actual uncertainty exponent is the slope of the curve (α) and indeed we get an exponent near 0 as we know a-priory the basins have fractal boundaries for the magnetic pendulum.","category":"section"},{"location":"examples/#Computing-the-tipping-probabilities","page":"Examples for Attractors.jl","title":"Computing the tipping probabilities","text":"We will compute the tipping probabilities using the magnetic pendulum's example as the \"before\" state. For the \"after\" state we will change the γ parameter of the third magnet to be so small, its basin of attraction will virtually disappear. As we don't know when the basin of the third magnet will disappear, we switch the attractor finding algorithm back to AttractorsViaRecurrences.\n\nset_parameter!(psys, :γs, [1.0, 1.0, 0.1])\nmapper = AttractorsViaRecurrences(psys, (xg, yg); Δt = 1)\nbasins_after, attractors_after = basins_of_attraction(\n    mapper, (xg, yg); show_progress = false\n)\n# matching attractors is important!\nrmap = match_statespacesets!(attractors_after, attractors)\n# Don't forget to update the labels of the basins as well!\nreplace!(basins_after, rmap...)\n\n# now plot\nheatmap_basins_attractors(grid, basins_after, attractors_after)\n\nAnd let's compute the tipping \"probabilities\":\n\nP = tipping_probabilities(basins, basins_after)\n\nAs you can see P has size 3×2, as after the change only 2 attractors have been identified in the system (3 still exist but our state space discretization isn't fine enough to find the 3rd because it has such a small basin). Also, the first row of P is 50% probability to each other magnet, as it should be due to the system's symmetry.","category":"section"},{"location":"examples/#3D-basins-via-recurrences","page":"Examples for Attractors.jl","title":"3D basins via recurrences","text":"To showcase the true power of AttractorsViaRecurrences we need to use a system whose attractors span higher-dimensional space. An example is\n\nusing Attractors\nusing PredefinedDynamicalSystems\nds = PredefinedDynamicalSystems.thomas_cyclical(b = 0.1665)\n\nwhich, for this parameter, contains 3 coexisting attractors which are entangled periodic orbits that span across all three dimensions.\n\nTo compute the basins we define a three-dimensional grid and call on it basins_of_attraction.\n\n# This computation takes about an hour\nxg = yg = zg = range(-6.0, 6.0; length = 251)\nmapper = AttractorsViaRecurrences(ds, (xg, yg, zg); sparse = false)\nbasins, attractors = basins_of_attraction(mapper)\nattractors\n\nDict{Int16, StateSpaceSet{3, Float64}} with 5 entries:\n  5 => 3-dimensional StateSpaceSet{Float64} with 1 points\n  4 => 3-dimensional StateSpaceSet{Float64} with 379 points\n  6 => 3-dimensional StateSpaceSet{Float64} with 1 points\n  2 => 3-dimensional StateSpaceSet{Float64} with 538 points\n  3 => 3-dimensional StateSpaceSet{Float64} with 537 points\n  1 => 3-dimensional StateSpaceSet{Float64} with 1 points\n\nNote: the reason we have 6 attractors here is because the algorithm also finds 3 unstable fixed points and labels them as attractors. This happens because we have provided initial conditions on the grid xg, yg, zg that start exactly on the unstable fixed points, and hence stay there forever, and hence are perceived as attractors by the recurrence algorithm. As you will see in the video below, they don't have any basin fractions\n\nThe basins of attraction are very complicated. We can try to visualize them by animating the 2D slices at each z value, to obtain:\n\n<video width=\"75%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/attractors/cyclical_basins.mp4?raw=true\" type=\"video/mp4\">\n</video>\n\nThen, we visualize the attractors to obtain:\n\n<video width=\"75%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/attractors/cyclical_attractors.mp4?raw=true\" type=\"video/mp4\">\n</video>\n\nIn the animation above, the scattered points are the attractor values the function AttractorsViaRecurrences found by itself. Of course, for the periodic orbits these points are incomplete. Once the function's logic understood we are on an attractor, it stops computing. However, we also simulated lines, by evolving initial conditions colored appropriately with the basins output.\n\nThe animation was produced with the code:\n\nusing GLMakie\nfig = Figure()\ndisplay(fig)\nax = fig[1,1] = Axis3(fig; title = \"found attractors\")\ncmap = cgrad(:dense, 6; categorical = true)\n\nfor i in keys(attractors)\n    tr = attractors[i]\n    markersize = length(attractors[i]) > 10 ? 2000 : 6000\n    marker = length(attractors[i]) > 10 ? :circle : :rect\n    scatter!(ax, columns(tr)...; markersize, marker, transparency = true, color = cmap[i])\n    j = findfirst(isequal(i), bsn)\n    x = xg[j[1]]\n    y = yg[j[2]]\n    z = zg[j[3]]\n    tr = trajectory(ds, 100, SVector(x,y,z); Ttr = 100)\n    lines!(ax, columns(tr)...; linewidth = 1.0, color = cmap[i])\nend\n\na = range(0, 2π; length = 200) .+ π/4\n\nrecord(fig, \"cyclical_attractors.mp4\", 1:length(a)) do i\n    ax.azimuth = a[i]\nend","category":"section"},{"location":"examples/#Basins-of-attraction-of-a-Poincaré-map","page":"Examples for Attractors.jl","title":"Basins of attraction of a Poincaré map","text":"PoincareMap is just another discrete time dynamical system within the DynamicalSystems.jl ecosystem. With respect to Attractors.jl functionality, there is nothing special about Poincaré maps. You simply initialize one use it like any other type of system. Let's continue from the above example  of the Thomas cyclical system\n\nusing Attractors\nusing PredefinedDynamicalSystems\nds = PredefinedDynamicalSystems.thomas_cyclical(b = 0.1665);\n\nThe three limit cycles attractors we have above become fixed points in the Poincaré map (for appropriately chosen hyperplanes). Since we already know the 3D structure of the basins, we can see that an appropriately chosen hyperplane is just the plane z = 0. Hence, we define a Poincaré map on this plane:\n\nplane = (3, 0.0)\npmap = PoincareMap(ds, plane)\n\nWe define the same grid as before, but now only we only use the x-y coordinates. This is because we can utilize the special reinit! method of the PoincareMap, that allows us to initialize a new state directly on the hyperplane (and then the remaining variable of the dynamical system takes its value from the hyperplane itself).\n\nxg = yg = range(-6.0, 6.0; length = 250)\ngrid = (xg, yg)\nmapper = AttractorsViaRecurrences(pmap, grid; sparse = false)\n\nAll that is left to do is to call basins_of_attraction:\n\nbasins, attractors = basins_of_attraction(mapper; show_progress = false);\n\nheatmap_basins_attractors(grid, basins, attractors)\n\njust like in the example above, there is a fourth attractor with 0 basin fraction. This is an unstable fixed point, and exists exactly because we provided a grid with the unstable fixed point exactly on this grid","category":"section"},{"location":"examples/#Irregular-grid-for-AttractorsViaRecurrences","page":"Examples for Attractors.jl","title":"Irregular grid for AttractorsViaRecurrences","text":"It is possible to provide an irregularly spaced grid to AttractorsViaRecurrences. This can make algorithm performance better for continuous time systems where the state space flow has significantly different speed in some state space regions versus others.\n\nIn the following example the dynamical system has only one attractor: a limit cycle. However, near the origin (0, 0) the timescale of the dynamics becomes very slow. As the trajectory is stuck there for quite a while, the recurrences algorithm may identify this region as an \"attractor\" (incorrectly). The solutions vary and can be to increase drastically the max time checks for finding attractors, or making the grid much more fine. Alternatively, one can provide a grid that is only more fine near the origin and not fine elsewhere.\n\nThe example below highlights that for rather coarse settings of grid and convergence thresholds, using a grid that is finer near (0, 0) gives correct results:\n\nusing Attractors, CairoMakie\n\nfunction predator_prey_fastslow(u, p, t)\n    α, γ, ϵ, ν, h, K, m = p\n    N, P = u\n    du1 = α*N*(1 - N/K) - γ*N*P / (N+h)\n    du2 = ϵ*(ν*γ*N*P/(N+h) - m*P)\n    return SVector(du1, du2)\nend\nγ = 2.5\nh = 1\nν = 0.5\nm = 0.4\nϵ = 1.0\nα = 0.8\nK = 15\nu0 = rand(2)\np0 = [α, γ, ϵ, ν, h, K, m]\nds = CoupledODEs(predator_prey_fastslow, u0, p0)\n\nfig = Figure()\nax = Axis(fig[1,1])\n\n# when pow > 1, the grid is finer close to zero\nfor pow in (1, 2)\n    xg = yg = range(0, 18.0^(1/pow); length = 200).^pow\n    mapper = AttractorsViaRecurrences(ds, (xg, yg);\n        Dt = 0.1, sparse = true,\n        consecutive_recurrences = 10, attractor_locate_steps = 10,\n        maximum_iterations = 1000,\n    )\n\n    # Find attractor and its fraction (fraction is always 1 here)\n    sampler, _ = statespace_sampler(HRectangle(zeros(2), fill(18.0, 2)), 42)\n    fractions = basins_fractions(mapper, sampler; N = 100, show_progress = false)\n    attractors = extract_attractors(mapper)\n    scatter!(ax, vec(attractors[1]); markersize = 16/pow, label = \"pow = $(pow)\")\nend\n\naxislegend(ax)\n\nfig","category":"section"},{"location":"examples/#Subdivision-Based-Grid-for-AttractorsViaRecurrences","page":"Examples for Attractors.jl","title":"Subdivision Based Grid for AttractorsViaRecurrences","text":"To achieve even better results for this kind of problematic systems than with previuosly introduced Irregular Grids  we provide a functionality to construct Subdivision Based Grids in which one can obtain more coarse or dense structure not only along some axis but for a specific regions where the state space flow has significantly different speed. subdivision_based_grid enables automatic evaluation of velocity vectors for regions of originally user specified grid to further treat those areas as having more dense or coarse structure than others.\n\nusing Attractors, CairoMakie\n\nfunction predator_prey_fastslow(u, p, t)\n    α, γ, ϵ, ν, h, K, m = p\n    N, P = u\n    du1 = α*N*(1 - N/K) - γ*N*P / (N+h)\n    du2 = ϵ*(ν*γ*N*P/(N+h) - m*P)\nreturn SVector(du1, du2)\nend\nγ = 2.5\nh = 1\nν = 0.5\nm = 0.4\nϵ = 1.0\nα = 0.8\nK = 15\nu0 = rand(2)\np0 = [α, γ, ϵ, ν, h, K, m]\nds = CoupledODEs(predator_prey_fastslow, u0, p0)\n\nxg = yg = range(0, 18, length = 30)\n# Construct `Subdivision Based Grid`\ngrid = subdivision_based_grid(ds, (xg, yg))\ngrid.lvl_array\n\nThe constructed array corresponds to levels of discretization for specific regions of the grid as a powers of 2, meaning that if area index is assigned to be 3, for example, the algorithm will treat the region as one being 2^3 = 8 times more dense than originally user provided grid (xg, yg).\n\nNow upon the construction of this structure, one can simply pass it into mapper function as usual.\n\nfig = Figure()\nax = Axis(fig[1,1])\n# passing SubdivisionBasedGrid into mapper\nmapper = AttractorsViaRecurrences(ds, grid;\n        Dt = 0.1, sparse = true,\n        consecutive_recurrences = 10, attractor_locate_steps = 10,\n        maximum_iterations = 1000,\n    )\n\n# Find attractor and its fraction (fraction is always 1 here)\nsampler, _ = statespace_sampler(HRectangle(zeros(2), fill(18.0, 2)), 42)\nfractions = basins_fractions(mapper, sampler; N = 100, show_progress = false)\nattractors_SBD = extract_attractors(mapper)\nscatter!(ax, vec(attractors_SBD[1]); label = \"SubdivisionBasedGrid\")\n\n\n# to compare the results we also construct RegularGrid of same length here\nxg = yg = range(0, 18, length = 30)\nmapper = AttractorsViaRecurrences(ds, (xg, yg);\n        Dt = 0.1, sparse = true,\n        consecutive_recurrences = 10, attractor_locate_steps = 10,\n        maximum_iterations = 1000,\n    )\n\nsampler, _ = statespace_sampler(HRectangle(zeros(2), fill(18.0, 2)), 42)\nfractions = basins_fractions(mapper, sampler; N = 100, show_progress = false)\nattractors_reg = extract_attractors(mapper)\nscatter!(ax, vec(attractors_reg[1]); label = \"RegularGrid\")\n\naxislegend(ax)\nfig\n","category":"section"},{"location":"examples/#Basin-fractions-continuation-in-the-magnetic-pendulum","page":"Examples for Attractors.jl","title":"Basin fractions continuation in the magnetic pendulum","text":"Perhaps the simplest application of global_continuation is to produce a plot of how the fractions of attractors change as we continuously change the parameter we changed above to calculate tipping probabilities.","category":"section"},{"location":"examples/#Computing-the-fractions","page":"Examples for Attractors.jl","title":"Computing the fractions","text":"This is what the following code does:\n\n# initialize projected magnetic pendulum\nusing Attractors, PredefinedDynamicalSystems\nusing Random: Xoshiro\nds = Systems.magnetic_pendulum(; d = 0.3, α = 0.2, ω = 0.5)\nxg = yg = range(-3, 3; length = 101)\nds = ProjectedDynamicalSystem(ds, 1:2, [0.0, 0.0])\n# Choose a mapper via recurrences\nmapper = AttractorsViaRecurrences(ds, (xg, yg); Δt = 1.0)\n# What parameter to change, over what range\nγγ = range(1, 0; length = 101)\nprange = [[1, 1, γ] for γ in γγ]\npidx = :γs\n# important to make a sampler that respects the symmetry of the system\nregion = HSphere(3.0, 2)\nsampler, = statespace_sampler(region, 1234)\n# continue attractors and basins:\n# `Inf` threshold fits here, as attractors move smoothly in parameter space\nrsc = RecurrencesFindAndMatch(mapper; threshold = Inf)\nfractions_cont, attractors_cont = global_continuation(\n    rsc, prange, pidx, sampler;\n    show_progress = false, samples_per_parameter = 100\n)\n# Show some characteristic fractions:\nfractions_cont[[1, 50, 101]]","category":"section"},{"location":"examples/#Plotting-the-fractions","page":"Examples for Attractors.jl","title":"Plotting the fractions","text":"We visualize them using a predefined function that you can find in docs/basins_plotting.jl\n\n# careful; `prange` isn't a vector of reals!\nplot_basins_curves(fractions_cont, γγ)","category":"section"},{"location":"examples/#Fixed-point-curves","page":"Examples for Attractors.jl","title":"Fixed point curves","text":"A by-product of the analysis is that we can obtain the curves of the position of fixed points for free. However, only the stable branches can be obtained!\n\nusing CairoMakie\nfig = Figure()\nax = Axis(fig[1,1]; xlabel = L\"\\gamma_3\", ylabel = \"fixed point\")\n# choose how to go from attractor to real number representation\nfunction real_number_repr(attractor)\n    p = attractor[1]\n    return (p[1] + p[2])/2\nend\n\nfor (i, γ) in enumerate(γγ)\n    for (k, attractor) in attractors_cont[i]\n        scatter!(ax, γ, real_number_repr(attractor); color = Cycled(k))\n    end\nend\nfig\n\nas you can see, two of the three fixed points, and their stability, do not depend at all on the parameter value, since this parameter value tunes the magnetic strength of only the third magnet. Nevertheless, the fractions of basin of attraction of all attractors depend strongly on the parameter. This is a simple example that highlights excellently how this new approach we propose here should be used even if one has already done a standard linearized bifurcation analysis.","category":"section"},{"location":"examples/#Extinction-of-a-species-in-a-multistable-competition-model","page":"Examples for Attractors.jl","title":"Extinction of a species in a multistable competition model","text":"In this advanced example we utilize both RecurrencesFindAndMatch and aggregate_attractor_fractions in analyzing species extinction in a dynamical model of competition between multiple species. The final goal is to show the percentage of how much of the state space leads to the extinction or not of a pre-determined species, as we vary a parameter. The model however displays extreme multistability, a feature we want to measure and preserve before aggregating information into \"extinct or not\".\n\nTo measure and preserve this we will apply RecurrencesFindAndMatch as-is first. Then we can aggregate information. First we have\n\nusing Attractors, OrdinaryDiffEqVerner\nusing PredefinedDynamicalSystems\nusing Random: Xoshiro\n# arguments to algorithms\nsamples_per_parameter = 1000\ntotal_parameter_values = 101\ndiffeq = (alg = Vern9(), reltol = 1e-9, abstol = 1e-9, maxiters = Inf)\nrecurrences_kwargs = (; Δt= 1.0, consecutive_recurrences=9, diffeq);\n# initialize dynamical system and sampler\nds = PredefinedDynamicalSystems.multispecies_competition() # 8-dimensional\nds = CoupledODEs(ODEProblem(ds), diffeq)\n# define grid in state space\nxg = range(0, 60; length = 300)\ngrid = ntuple(x -> xg, 8)\nprange = range(0.2, 0.3; length = total_parameter_values)\npidx = :D\nsampler, = statespace_sampler(grid, 1234)\n# initialize mapper\nmapper = AttractorsViaRecurrences(ds, grid; recurrences_kwargs...)\n# perform continuation of attractors and their basins\nalg = RecurrencesFindAndMatch(mapper; threshold = Inf)\nfractions_cont, attractors_cont = global_continuation(\n    alg, prange, pidx, sampler;\n    show_progress = true, samples_per_parameter\n)\nplot_basins_curves(fractions_cont, prange; separatorwidth = 1)\n\n(Image: )\n\nthis example is not actually run when building the docs, because it takes about 60 minutes to complete depending on the computer; we load precomputed results instead\n\nAs you can see, the system has extreme multistability with 64 unique attractors (according to the default matching behavior in RecurrencesFindAndMatch; a stricter matching with less than Inf threshold would generate more \"distinct\" attractors). One could also isolate a specific parameter slice, and do the same as what we do in the Fractality of 2D basins of the (4D) magnetic pendulum example, to prove that the basin boundaries are fractal, thereby indeed confirming the paper title \"Fundamental Unpredictability\".\n\nRegardless, we now want to continue our analysis to provide a figure similar to the above but only with two colors: fractions of attractors where a species is extinct or not. Here's how:\n\nspecies = 3 # species we care about its existence\n\nfeaturizer = (A) -> begin\n    i = isextinct(A, species)\n    return SVector(Int32(i))\nend\nisextinct(A, idx = unitidxs) = all(a -> a <= 1e-2, A[:, idx])\n\n# `minneighbors = 1` is crucial for grouping single attractors\ngroupingconfig = GroupViaClustering(; min_neighbors=1, optimal_radius_method=0.5)\n\naggregated_fractions, aggregated_info = aggregate_attractor_fractions(\n    fractions_cont, attractors_cont, featurizer, groupingconfig\n)\n\nplot_basins_curves(aggregated_fractions, prange;\n    separatorwidth = 1, colors = [\"green\", \"black\"],\n    labels = Dict(1 => \"extinct\", 2 => \"alive\"),\n)\n\n(Image: )\n\n(in hindsight, the labels are reversed; attractor 1 is the alive one, but oh well)","category":"section"},{"location":"examples/#Trivial-featurizing-and-grouping-for-basins-fractions","page":"Examples for Attractors.jl","title":"Trivial featurizing and grouping for basins fractions","text":"This is a rather trivial example showcasing the usage of AttractorsViaFeaturizing. Let us use once again the magnetic pendulum example. For it, we have a really good idea of what features will uniquely describe each attractor: the last points of a trajectory (which should be very close to the magnetic the trajectory converged to). To provide this information to the AttractorsViaFeaturizing we just create a julia function that returns this last point\n\nusing Attractors\nusing PredefinedDynamicalSystems\n\nds = Systems.magnetic_pendulum(d=0.2, α=0.2, ω=0.8, N=3)\npsys = ProjectedDynamicalSystem(ds, [1, 2], [0.0, 0.0])\n\nfunction featurizer(X, t)\n    return X[end]\nend\n\nmapper = AttractorsViaFeaturizing(psys, featurizer; Ttr = 200, T = 1)\n\nxg = yg = range(-4, 4; length = 101)\n\nregion = HRectangle([-4, 4], [4, 4])\nsampler, = statespace_sampler(region)\n\nfs = basins_fractions(mapper, sampler; show_progress = false)\n\nAs expected, the fractions are each about 1/3 due to the system symmetry.","category":"section"},{"location":"examples/#Featurizing-and-grouping-across-parameters-(MCBB)","page":"Examples for Attractors.jl","title":"Featurizing and grouping across parameters (MCBB)","text":"Here we showcase the example of the Monte Carlo Basin Bifurcation publication. For this, we will use FeaturizeGroupAcrossParameter while also providing a par_weight = 1 keyword. However, we will not use a network of 2nd order Kuramoto oscillators (as done in the paper by Gelbrecht et al.) because it is too costly to run on CI. Instead, we will use \"dummy\" system which we know analytically the attractors and how they behave versus a parameter.\n\nthe Henon map and try to group attractors into period 1 (fixed point), period 3, and divergence to infinity. We will also use a pre-determined optimal radius for clustering, as we know a-priory the expected distances of features in feature space (due to the contrived form of the featurizer function below).\n\nusing Attractors, Random\n\nfunction dumb_map(dz, z, p, n)\n    x, y = z\n    r = p[1]\n    if r < 0.5\n        dz[1] = dz[2] = 0.0\n    else\n        if x > 0\n            dz[1] = r\n            dz[2] = r\n        else\n            dz[1] = -r\n            dz[2] = -r\n        end\n    end\n    return\nend\n\nr = 3.833\nds = DiscreteDynamicalSystem(dumb_map, [0., 0.], [r])\n\nsampler, = statespace_sampler(HRectangle([-3.0, -3.0], [3.0, 3.0]), 1234)\n\nrrange = range(0, 2; length = 21)\nridx = 1\n\nfeaturizer(a, t) = a[end]\nclusterspecs = GroupViaClustering(optimal_radius_method = \"silhouettes\", max_used_features = 200)\nmapper = AttractorsViaFeaturizing(ds, featurizer, clusterspecs; T = 20, threaded = true)\ngap = FeaturizeGroupAcrossParameter(mapper; par_weight = 1.0)\nfractions_cont, clusters_info = global_continuation(\n    gap, rrange, ridx, sampler; show_progress = false\n)\nfractions_cont\n\nLooking at the information of the \"attractors\" (here the clusters of the grouping procedure) does not make it clear which label corresponds to which kind of attractor, but we can look at the:\n\nclusters_info","category":"section"},{"location":"examples/#Using-histograms-and-histogram-distances-as-features","page":"Examples for Attractors.jl","title":"Using histograms and histogram distances as features","text":"One of the aspects discussed in the original MCBB paper and implementation was the usage of histograms of the means of the variables of a dynamical system as the feature vector. This is useful in very high dimensional systems, such as oscillator networks, where the histogram of the means is significantly different in synchronized or unsychronized states.\n\nThis is possible to do with current interface without any modifications, by using two more packages: ComplexityMeasures.jl to compute histograms, and Distances.jl for the Kullback-Leibler divergence (or any other measure of distance in the space of probability distributions you fancy).\n\nThe only code we need to write to achieve this feature is a custom featurizer and providing an alternative distance to GroupViaClustering. The code would look like this:\n\nusing Distances: KLDivergence\nusing ComplexityMeasures: ValueHistogram, FixedRectangularBinning, probabilities\n\n# you decide the binning for the histogram, but for a valid estimation of\n# distances, all histograms must have exactly the same bins, and hence be\n# computed with fixed ranges, i.e., using the `FixedRectangularBinning`\n\nfunction histogram_featurizer(A, t)\n    binning = FixedRectangularBinning(range(-5, 5; length = 11))\n    ms = mean.(columns(A)) # vector of mean of each variable\n    p = probabilities(ValueHistogram(binning), ms) # this is the histogram\n    return vec(p) # because Distances.jl doesn't know `Probabilities`\nend\n\ngconfig = GroupViaClustering(;\n    clust_distance_metric = KLDivergence(), # or any other PDF distance\n)\n\nYou can then pass the histogram_featurizer and gconfig to an AttractorsViaFeaturizing and use the rest of the library as usual.","category":"section"},{"location":"examples/#Edge-tracking","page":"Examples for Attractors.jl","title":"Edge tracking","text":"To showcase how to run the edgetracking algorithm, let us use it to find the saddle point of the bistable FitzHugh-Nagumo (FHN) model, a two-dimensional ODE system originally conceived to represent a spiking neuron. We define the system in the following form:\n\nusing OrdinaryDiffEqVerner: Vern9\n\nfunction fitzhugh_nagumo(u,p,t)\n    x, y = u\n    eps, beta = p\n    dx = (x - x^3 - y)/eps\n    dy = -beta*y + x\n    return SVector{2}([dx, dy])\nend\n\nparams = [0.1, 3.0]\nds = CoupledODEs(fitzhugh_nagumo, ones(2), params, diffeq=(;alg = Vern9(), reltol=1e-11))\n\nNow we compute the fixed points and basins of attraction of the FHN model.\n\nxg = yg = range(-1.5, 1.5; length = 201)\ngrid = (xg, yg)\nmapper = AttractorsViaRecurrences(ds, grid; sparse=false)\nbasins, attractors = basins_of_attraction(mapper)\nattractors\n\nThe basins_of_attraction function found three fixed points: the two stable nodes of the system (labelled A and B) and the saddle point at the origin. The saddle is an unstable equilibrium and typically will not be found by basins_of_attraction. Coincidentally here we initialized an initial condition exactly on the saddle, and hence it was found. We can always find saddles with the edgetracking function. For illustration, let us initialize the algorithm from two initial conditions init1 and init2 (which must belong to different basins of attraction, see figure below).\n\nattractors_AB = Dict(1 => attractors[1], 2 => attractors[2])\ninit1, init2 = [-1.0, -1.0], [-1.0, 0.2]\n\nNow, we run the edge tracking algorithm:\n\net = edgetracking(ds, attractors_AB; u1=init1, u2=init2,\n    bisect_thresh = 1e-3, diverge_thresh = 2e-3, Δt = 1e-5, abstol = 1e-3\n)\n\net.edge[end]\n\nThe algorithm has converged to the origin (up to the specified accuracy) where the saddle is located. The figure below shows how the algorithm has iteratively tracked along the basin boundary from the two initial conditions (red points) to the saddle (green square). Points of the edge track (orange) at which a re-bisection occured are marked with a white border. The figure also depicts two trajectories (blue) intialized on either side of the basin boundary at the first bisection point. We see that these trajectories follow the basin boundary for a while but then relax to either attractor before reaching the saddle. By counteracting the instability of the saddle, the edge tracking algorithm instead allows to track the basin boundary all the way to the saddle, or edge state.\n\ntraj1 = trajectory(ds, 2, et.track1[et.bisect_idx[1]], Δt=1e-5)\ntraj2 = trajectory(ds, 2, et.track2[et.bisect_idx[1]], Δt=1e-5)\nfig = Figure()\nax = Axis(fig[1,1], xlabel=\"x\", ylabel=\"y\")\nheatmap_basins_attractors!(ax, grid, basins, attractors, add_legend=false, labels=Dict(1=>\"Attractor A\", 2=>\"Attractor B\", 3=>\"Saddle\"))\nlines!(ax, traj1[1][:,1], traj1[1][:,2], color=:dodgerblue, linewidth=2, label=\"Trajectories\")\nlines!(ax, traj2[1][:,1], traj2[1][:,2], color=:dodgerblue, linewidth=2)\nlines!(ax, et.edge[:,1], et.edge[:,2], color=:orange, linestyle=:dash)\nscatter!(ax, et.edge[et.bisect_idx,1], et.edge[et.bisect_idx,2], color=:white, markersize=15, marker=:circle)\nscatter!(ax, et.edge[:,1], et.edge[:,2], color=:orange, markersize=11, marker=:circle, label=\"Edge track\")\nscatter!(ax, [-1.0,-1.0], [-1.0, 0.2], color=:red, markersize=15, label=\"Initial conditions\")\nxlims!(ax, -1.2, 1.1); ylims!(ax, -1.3, 0.8)\naxislegend(ax, position=:rb)\nfig\n\nIn this simple two-dimensional model, we could of course have found the saddle directly by computing the zeroes of the ODE system. However, the edge tracking algorithm allows finding edge states also in high-dimensional and chaotic systems where a simple computation of unstable equilibria becomes infeasible.","category":"section"},{"location":"examples/#Estimating-(almost)-all-stability-measures-at-a-given-parameter","page":"Examples for Attractors.jl","title":"Estimating (almost) all stability measures at a given parameter","text":"The type StabilityMeasuresAccumulator is showcased in an application of finding all stability measures for the Duffing oscillator.\n\nfunction duffing(u, p, t)\n    x, y = u\n    α, β = p\n    dx = y\n    dy = x - x^3 - α*y + β\n    return SVector(dx, dy)\nend\n\nimport LinearAlgebra: I\nimport Distributions: MvNormal\n\nparams = [0.2, 0.0]\nds = CoupledODEs(duffing, ones(2), params, diffeq=(; reltol=1e-11))\n\nn_grid = 201\ngrid = (range(-2, 2; length = n_grid),range(-2, 2; length = n_grid),)\n\nmapper = AttractorsViaRecurrences(ds, grid; sparse = false, consecutive_recurrences = 1000)\n\naccumulator = StabilityMeasuresAccumulator(mapper, finite_time=50.0, weighting_distribution=MvNormal(zeros(2), 1.0*I))\n\nIf we call this object on some initial conditions and finalize its values, we receive several different stability measures. Their interpretation can be found in the documentation of StabilityMeasuresAccumulator.\n\nA = ics_from_grid(grid)\nfor u0 in A\n    id = accumulator(u0)\nend\nstability_measures = finalize_accumulator(accumulator)","category":"section"},{"location":"examples/#Invariant-saddle-of-a-dynamical-system","page":"Examples for Attractors.jl","title":"Invariant saddle of a dynamical system","text":"The stagger-and-step method approximates the invariant non-attracting set governing the chaotic transient dynamics of a system, namely the stable manifold of a chaotic saddle.\n\nGiven the dynamical system ds and a initial guess x0 in a region with no attractors, the algorithm provides N points close to the  stable manifold that escape from the region after at least Tm steps of ds.\n\nWe first set the dynamical system, in our case we set up two coupled Hénon map that are known to have a chaotic saddle that generates chaotic transients before the trajectories escape:\n\nfunction F!(du, u ,p, n)\n    x,y,u,v = u\n    A = 3; B = 0.3; C = 5.; D = 0.3; k = 0.4;\n    du[1] = A - x^2 + B*y + k*(x-u)\n    du[2] = x\n    du[3] = C - u^2 + D*v + k*(u-x)\n    du[4] = u\n    return\nend\nds = DeterministicIteratedMap(F!, zeros(4))\n\nNext we define a region in the phase space that should not contain attractors. Using this region we also define a sampler and a membership function isinside:\n\nR_min = [-4; -4.; -4.; -4.]\nR_max = [4.; 4.; 4.; 4.]\nsampler, isinside = statespace_sampler(HRectangle(R_min,R_max))\n\nAnd we are ready! We can now call the function stagger_and_step with an initial condition x0:\n\nx0 = sampler()\nv = stagger_and_step(ds, x0, 10000, isinside; stagger_mode = :adaptive, δ = 1e-4, Tm = 10, max_steps = Int(1e5), δ₀ = 2.)\n\nThe stagger_mode keyword select the type of search in the phase space to stick close to the saddle at each step. The mode :adaptive adapts the radius of the stochastic search as a function of the success of the search process.\n\nFinally we can represent a projection of the chaotic saddle found in this example:\n\nfig = Figure()\nax = Axis(fig[1,1], xlabel=\"x\", ylabel=\"y\")\nscatter!(ax, v[:,1], v[:,3]; markersize = 3)\nfig","category":"section"},{"location":"examples/#Matching-limit-cycles-and-fixed-points-in-a-system-with-heterogeneous-state-space","page":"Examples for Attractors.jl","title":"Matching limit cycles and fixed points in a system with heterogeneous state space","text":"This example discusses the situation of a dynamical system that during a global continuation it transitions from a fixed point A to a limit cycle B and then to another fixed point C that is far away (in statespace) from A but very close to B. In the context of this scenario, we do NOT want to match the fixed points with the limit cycle during the continuation. Furthermore, this particular dynamical system has a heterogeneous state space: the different dynamic variables have wildly different units, and there is no sensible transformation that would bring all variables to the same units.\n\nWe will showcase how one can achieve match attractors in this system simply by defining a special distance function that is given to MatchBySSSetDistance. This is:\n\nfunction centroid_and_length(A, B)\n    # first check we are comparing a fixed point and limit cycle. We do this by\n    # checking if the lengths of attractors A and B are different and if one\n    # the two has length 1 (i.e., it is a fixed point)\n    if length(A) != length(B) && any(isequal(1), length.((A, B)))\n        return Inf\n    end\n    # otherwise both sets are similar in nature (both limit cycle or fixed points)\n    # in which case we use a weighted centroid distance\n    scales = (300.0, 1.0, 1200.0, 300.0, 10.0)\n    d = maximum(i -> abs( ( mean(A[:, i]) - mean(B[:, i]) )/scales[i] ), 1:5)\n    return d\nend\n\nmatcher = MatchBySSSetDistance(; distance = centroid_and_length, threshold = 0.2)\n\nWe then provide this matcher to AttractorSeedContinueMatch and perform a global continuation as illustrated in the main Tutorial. This special matcher achieves the following:\n\nDoes not match limit cycles with fixed points no matter what.\nMatches attractors according to their weighted centroid difference. Each dimension of the dynamical system has a typical scale that is characteristic for each dimension. Then the distance between centroids is normalized by this typical size.\nThe maximum of these normalized distances is obtained.\nThe threshold = 0.2 in essence means that if two attractors have a weighted centroid difference of less than 20% of the typical size for each dimension, the attractors are matched!\n\nThis was the matching procedure used in the cloud critical transition model of (Datseris, 2025).","category":"section"},{"location":"bfkit_comparison/#bfkit_comparison","page":"Comparison with traditional local continuation and bifurcation analysis software","title":"Comparison with traditional local continuation and bifurcation analysis software","text":"note: Continues from tutorial\nThis page continues after the end of the main Tutorial! Ensure you have gon through it first!\n\nAs we discussed in the subsection on global continuation, the approach of Attractors.jl is fundamentally different from traditional local continuation and bifurcation analysis software like AUTO, MatCont, or BifurcationKit.jl. Nevertheless in this page we will compare using BifurcationKit.jl to attempt to find and continue the limit cycle of the tutorial modified Lorenz-like system. We forfeit looking for the chaotic attractors, as to our knowledge there exists no software on dynamical systems beyond Attractors.jl can find chaotic attractors.\n\nThe goal of this comparison is to highlight the differences in usage complexity and overall capability when using Attractors.jl or traditional continuation tools to study complex dynamical systems.","category":"section"},{"location":"bfkit_comparison/#BifurcationKit.jl-version","page":"Comparison with traditional local continuation and bifurcation analysis software","title":"BifurcationKit.jl version","text":"To use BifurcationKit.jl (BK) for periodic orbits (POs) we need to choose one of its several Newton-based algorithms for POs, and in addition supply it with both an initial guess for the location of the periodic orbit, as well as a guess for the period. In this example we translate almost verbatim the example of the Periodic predator prey model). from the BK docs. Finding a periodic orbit this way is already considered an advanced use case in BK documentation, requiring \"high level of knowledge of (numerical) bifurcation theory\". For Attractors.jl on the other hand, this is as basic of a use-case as it can get, which highlights the simplicity of our computational approach.\n\nTo use BK we need to import it and initialize various continuation-related structures. The entire input BK requires to find a periodic orbit is:\n\na periodic orbit problem like BK.ShootingProblem or BK.PeriodicOrbitTrapProblem (and its meta parameters)\na BK.BifurcationProblem\na DifferentialEquations.Solution\nan estimate of the period\na BK.ContinuationPar parameter container\na predictor for the continuation\narguments for what aspect of the periodic orbit to record.\n\nSome of this input isn't particularly important, but some of it is can be crucial and the values of the meta-parameters matter for whether the continuation will succeed or not.\n\nLet's start with the bifurcation problem. This is basically the same thing as a DynamicalSystem, but BK does not support efficient StaticVector-based out of place format for low dimensional systems (see main tutorial of DynamicalSystems.jl if you don't understand what this means). So we have to re-create\n\n# BK requires to modify the rule with t=0 as well\nfunction modified_lorenz_rule!(du, u, p, t = 0)\n    x, y, z = u; a, b = p\n    du[1] = y - x\n    du[2] = - x * z + b * abs(z)\n    du[3] = x * y - a\n    return du\nend\nprange = 4.7:0.02:6\npidx = 1\np0 = [5.0, 0.1] # parameters\nu0 = [-4.0, 5, 0] # state\n\nNow we can create the bifurcation problem\n\nimport BifurcationKit as BK\nusing OrdinaryDiffEqVerner\nusing CairoMakie\n\nbf_prob = BK.BifurcationProblem(\n    modified_lorenz_rule!, u0, p0, (BK.@optic _[pidx])\n)\n\nand then a full solution structure from DifferentialEquations.jl, that must start on the periodic orbit. Requiring that the solution starts on the periodic orbit defeats the purpose of \"wanting to find it\", but oh well, we do as we must.\n\n# This guess comes from the Attractors.jl main tutorial\npoint_on_lc = [\n    -1.622956992666447,\n    -4.527917984019188,\n    -5.178825669659272,\n]\n\node_prob = ODEProblem(modified_lorenz_rule!, point_on_lc, (0.0, 50.0), p0)\nsol = OrdinaryDiffEqVerner.solve(ode_prob; alg = Vern9(), abstol = 1.0e-9, reltol = 1.0e-9)\nj = length(sol) ÷ 2\nfig, ax = lines(sol.t[j:end], sol[1, j:end])\nlines!(ax, sol.t[j:end], sol[2, j:end])\nlines!(ax, sol.t[j:end], sol[3, j:end])\nfig\n\nWe need an estimate of the period besides providing the full DifferentialEquations.jl solution. From the figure this appears to be around 20.0 (note: the periodic orbit wraps around four times before repeating exactly).\n\nRight, and lastly we need a continuation parameter container, which has some options regarding convergence and stability that one would need to fine tune to the problem at hand.\n\nopts_br = BK.ContinuationPar(\n    p_min = prange[1], p_max = prange[end],\n    ds = 0.002, dsmax = 0.01, dsmin = 1.0e-6, n_inversion = 6,\n    detect_bifurcation = 3, max_bisection_steps = 50, nev = 4,\n    max_steps = 2000, tol_stability = 1.0e-3,\n)\n\nWe now create a periodic orbit problem type, by choosing a periodic orbit finding algorithm. Here we will use an optimized Jacobian for a collocation problem (advised via BifurcationKit.jl)\n\nperiodic_orbit_algo = BK.PeriodicOrbitOCollProblem(40, 4; jacobian = BK.DenseAnalyticalInplace())\n\nand creating the problem type giving the period guess 19.0\n\nprobpo, cish = BK.generate_ci_problem(\n    periodic_orbit_algo, bf_prob, sol, 19.0\n)\n\nTo call the continuation we need to also tell it what aspects of the periodic orbit to record, so we define\n\nargspo = (\n    record_from_solution = (x, p; k...) -> begin\n        xtt = BK.get_periodic_orbit(p.prob, x, p.p)\n        return (\n            max = maximum(xtt[1, :]),\n            min = minimum(xtt[1, :]),\n            period = BK.getperiod(p.prob, x, p.p),\n            p = p.p,\n        )\n    end,\n)\n\nwe also define the predictor\n\npredictor = BK.PALC(tangent = BK.Bordered())\n\nand finally call the continuation from BK\n\n@time branch = BK.continuation(\n    probpo, cish, predictor, opts_br;\n    verbosity = 0, plot = false,\n    linear_algo = BK.COPBLS(), # faster linear solver\n    argspo...,\n    bothside = true,\n)\n\nThe converges within about 2 seconds, ignoring compilation time. Let's plot the result:\n\nstability = branch.stable\nfig, ax = scatter(\n    branch.branch.p[stability], branch.branch.min[stability];\n    label = \"stable PO\", color = \"black\", marker = :circle\n)\nscatter!(\n    branch.branch.p[.!stability], branch.branch.min[.!stability];\n    label = \"unstable PO\", color = \"red\", marker = :x\n\n)\naxislegend(ax)\nfig\n\nEven the previous version that did work, did not find a stable limit cycle for parameter less than 5.0, In the main Tutorial we see that there is a limit cycle for parameter value down to 4.7. Here we see that the limit cycle is actually unstable. So the attractor found in the main Tutorial could be a weakly chaotic attractor with MLE almost 0. Or maybe it is a quasiperiodic attractor. Or maybe it is an alternative limit cycle close to the one tracked here by BifurcationKit.jl. One needs to analyze further!","category":"section"},{"location":"bfkit_comparison/#Attractors.jl-version","page":"Comparison with traditional local continuation and bifurcation analysis software","title":"Attractors.jl version","text":"We have already seen the code for this version in the main Tutorial, but here we copy it again using exactly the same input as that given to BK. To make the comparison explicit, let's also make an enumerated list for the Attractors.jl info:\n\nA DynamicalSystem,\nan AttractorMapper instance (and its meta parameters). For the mapper used here, AttractorsViaRecurrences, the meta parameters are:\nA state space tesselation\nA recurrence threshold\nA lost iterations threshold\na global continuation algorithm, and optionally a matcher for it.\na sampler to sample initial conditions in the state space.\n\nusing Attractors\nds = CoupledODEs(\n    modified_lorenz_rule!, u0, p0;\n    diffeq = (alg = Vern9(), abstol = 1.0e-9, reltol = 1.0e-9)\n)\n\ngrid = (\n    range(-15.0, 15.0; length = 200), # x\n    range(-20.0, 20.0; length = 200), # y\n    range(-20.0, 20.0; length = 200), # z\n)\n\nmapper = AttractorsViaRecurrences(\n    ds, grid;\n    consecutive_recurrences = 1000,\n    consecutive_lost_steps = 100,\n)\n\nsampler, = statespace_sampler(grid)\n\nalgo = AttractorSeedContinueMatch(mapper)\n\nfractions_cont, attractors_cont = global_continuation(\n    algo, prange, pidx, sampler; samples_per_parameter = 1_000\n)\n\nplot_attractors_curves(\n    attractors_cont, A -> minimum(A[:, 1]), prange,\n)\n\nThis code takes about 15 seconds to run. This number however is for 1000 initial conditions, not one (i.e., the one branch generated during the traditional continuation).","category":"section"},{"location":"bfkit_comparison/#Discussion-and-comparison","page":"Comparison with traditional local continuation and bifurcation analysis software","title":"Discussion and comparison","text":"Attractors.jl found not only a single limit cycle, but also all system attractors, including chaotic or quasiperiodic ones. It didn't require any initial guess regarding the limit cycle or its period, but only a state space box that may contain attractors. Attractors.jl is extremely robust w.r.t. to its input parameters: the state space box can be arbitrarily large, as long as it is large enough. Similarly, all meta parameters of AttractorsViaRecurrences only need to be large enough; the larger, the more accurate the result. These algorithms are also robust in the sense of working well for many different types of dynamical systems, including discrete ones, see (Datseris and Wagemakers, 2022) for a demonstration. And finally, Attractors.jl estimates a more general nonlocal measure of stability, in the sense that if a set is nonlocally stable, it is guaranteed to be locally stable, however the other way around isn't guaranteed. The global continuation of Attractors.jl continues the whole of a multistable state space across an arbitrary parameter curve. It finds all attractors that exist at each parameter combination and matches them to previous ones to establish continuity. It is completely fine for some attractors to stop existing during the global continuation.\n\nLocal continuation tracks a single and specific fixed point or limit cycle within a specified parameter range. The continuation will stop if the object stops existing all-together. But the local continuation can continue to track the object if it becomes unstable. Local continuation also automatically detects and labels local bifurcations. In our experience having the local bifurcations is always useful. Now, whether the unstable branches of a limit cycle are useful or not, depends on the research question and whether the analysis is done for some sort of real world understanding (unstable limit cycles / fixed points don't actually exist in the real world). Beyond this however, BifurcationKit.jl is also optimised for PDE systems, while Attractors.jl isn't.\n\nTo be transparent, the biggest downside of local continuation software (and not a particular downside of BifurcationKit.jl specifically), is that it can take a lot of effort or a lot of expertise to make them work. At least, a lot of effort compared with the effort it took to make the Attractors.jl version work, which was simply \"increase the recurrences threshold\", which is standard practice when dealing with chaotic systems (Datseris and Wagemakers, 2022). For example, any other of the periodic orbit algorithms of BifurcationKit.jl (such as shooting or trapezoid) fails unless its parameters are adjusted. Using alternative specifications for the Jacobian or the linear solving algorithm can also lead to failure. Using an incorrect initial period guess can also lead to failure. We imagine that this sensitivity would apply also to some other of the several meta-parameters that enter a traditional continuation routine, for example the thresholds and accuracy parameters related to Newton convergence, but we didn't check further. This is exactly what we were alluding to in the comparison we did in (Datseris et al., 2023), that traditional local continuation \"requires expertise and constant interventions\". See (Datseris et al., 2023) for a more thorough comparison (that was based on and older and less powerful version of Attractors.jl).","category":"section"},{"location":"recurrences_animation/#recurrences_animation","page":"Animation illustrating AttractorsViaRecurrences","title":"Animation illustrating AttractorsViaRecurrences","text":"The following Julia script inputs a 2D continuous time dynamical system and animates its time evolution while illustrating how AttractorsViaRecurrences works.\n\nusing Attractors, CairoMakie\nusing PredefinedDynamicalSystems\nusing OrdinaryDiffEqVerner\n\n# Set up dynamical system: bi-stable predator pray\nfunction predator_prey_rule(u, p, t)\n    r, c, μ, ν, α, β, χ, δ = p\n    N, P = u\n    common = α*N*P/(β+N)\n    dN = r*N*(1 - (c/r)*N)*((N-μ)/(N+ν)) - common\n    dP = χ*common - δ*P\n    return SVector(dN, dP)\nend\n\nu0 = SVector(8.0, 0.01)\nr = 2.0\n# r, c, μ, ν, α, β, χ, δ = p\np = [r, 0.19, 0.03, 0.003, 800, 1.5, 0.004, 2.2]\n\ndiffeq = (alg = Rodas5P(), abstol = 1e-9, rtol = 1e-9)\nds = CoupledODEs(predator_prey_rule, u0, p; diffeq)\n\nu0s = [ # animation will start from these initial conditions\n    [10, 0.012],\n    [15, 0.02],\n    [12, 0.01],\n    [13, 0.015],\n    [5, 0.02],\n]\n\ndensity = 31\nxg = range(-0.1, 20; length = density)\nyg = range(-0.001, 0.03; length = density)\nΔt = 0.1\ngrid = (xg, yg)\nmapper = AttractorsViaRecurrences(ds, grid;\n    Δt, consecutive_attractor_steps = 10, consecutive_basin_steps = 10, sparse = false,\n    consecutive_recurrences = 100, attractor_locate_steps = 100,\n)\n\n##########################################################################\n\nfunction animate_attractors_via_recurrences(\n        mapper::AttractorsViaRecurrences, u0s;\n        colors = [\"#FFFFFF\", \"#7143E0\",\"#0A9A84\",\"#AF9327\",\"#791457\", \"#6C768C\", \"#4287f5\",],\n        filename = \"recurrence_algorithm.mp4\",\n    )\n\n    grid_nfo = mapper.bsn_nfo.BoA.grid\n\n    fig = Figure()\n    ax = Axis(fig[1,1])\n\n    # Populate the grid with poly! rectangle plots. However! The rectangles\n    # correspond to the same \"cells\" of the grid. Additionally, all\n    # rectangles are colored with an _observable_, that can be accessed\n    # later using the `basin_cell_index` function. The observable\n    # holds the face color of the rectangle!\n\n    # Only 6 colors; need 3 for base, and extra 2 for each attractor.\n    # will choose initial conditions that are only in the first 2 attractors\n    COLORS = map(c -> Makie.RGBA(Makie.RGB(to_color(c)), 0.9), colors)\n\n    function initialize_cells2!(ax, grid; kwargs...)\n        # These are all possible outputs of the `basin_cell_index` function\n        idxs = all_cartesian_idxs(grid)\n        color_obs = Matrix{Any}(undef, size(idxs)...)\n        # We now need to reverse-engineer\n        for i in idxs\n            rect = cell_index_to_rect(i, grid)\n            color = Observable(COLORS[1])\n            color_obs[i] = color\n            poly!(ax, rect; color = color, strokecolor = :black, strokewidth = 0.5)\n        end\n        # Set the axis limits better\n        mini, maxi = Attractors.minmax_grid_extent(grid)\n        xlims!(ax, mini[1], maxi[1])\n        ylims!(ax, mini[2], maxi[2])\n        return color_obs\n    end\n\n    all_cartesian_idxs(grid::Attractors.RegularGrid) = CartesianIndices(length.(grid.grid))\n\n    # Given a cartesian index, the output of `basin_cell_index`, create\n    # a `Rect` object that corresponds to that grid cell!\n    function cell_index_to_rect(n::CartesianIndex, grid::Attractors.RegularGrid)\n        x = grid.grid[1][n[1]]\n        y = grid.grid[2][n[2]]\n        dx = grid.grid_steps[1]\n        dy = grid.grid_steps[2]\n        rect = Rect(x - dx/2, y - dy/2, dx, dy)\n        return rect\n    end\n\n    color_obs = initialize_cells2!(ax, grid_nfo)\n\n    # plot the trajectory\n    state2marker = Dict(\n        :att_search => :circle,\n        :att_found => :dtriangle,\n        :att_hit => :rect,\n        :lost => :star5,\n        :bas_hit => :xcross,\n    )\n\n    # This function gives correct color to search, recurrence, and\n    # the individual attractors. Ignores the lost state.\n    function update_current_cell_color!(cellcolor, bsn_nfo)\n        # We only alter the cell color at specific situations\n        state = bsn_nfo.state\n        if state == :att_search\n            if cellcolor[] == COLORS[1] # empty\n                cellcolor[] = COLORS[2] # visited\n            elseif cellcolor[] == COLORS[2] # visited\n                cellcolor[] = COLORS[3] # recurrence\n            end\n        elseif state == :att_found\n            attidx = (bsn_nfo.current_att_label ÷ 2)\n            attlabel = (attidx - 1)*2 + 1\n            cellcolor[] = COLORS[3+attlabel]\n        end\n        return\n    end\n\n    # Iteration and labelling\n    ds = mapper.ds\n    bsn_nfo = mapper.bsn_nfo\n    u0 = current_state(ds)\n\n    traj = Observable(SVector{2, Float64}[u0])\n    point = Observable([u0])\n\n    marker = Observable(:circle)\n    lines!(ax, traj; color = :black, linewidth = 1)\n    scatter!(ax, point; color = (:black, 0.5), markersize = 20, marker, strokewidth = 1.0, strokecolor = :black)\n\n    stateobs = Observable(:att_search)\n    consecutiveobs = Observable(0)\n    labeltext = @lift(\"state: $($(stateobs))\\nconsecutive: $($(consecutiveobs))\")\n\n    Label(fig[0, 1][1,1], labeltext; justification = :left, halign = :left, tellwidth = false)\n    # add text  with options\n    kwargstext = prod(\"$(p[1])=$(p[2])\\n\" for p in mapper.kwargs)\n    Label(fig[0, 1][1, 2], kwargstext; justification = :right, halign = :right, tellwidth = false)\n\n\n    # make legend\n    entries = [PolyElement(color = c) for c in COLORS[2:end]]\n    labels = [\"visited\", \"recurrence\", \"attr. 1\", \"basin 1\", \"attr. 2\", \"basin 2\"]\n\n    Legend(fig[:, 2][1, 1], entries, labels)\n\n\n    # %% loop\n    # The following code is similar to the source code of `recurrences_map_to_label!`\n\n    cell_label = 0\n    record(fig, filename) do io\n        for u0 in u0s\n            reinit!(ds, copy(u0))\n            traj[] = [copy(u0)]\n\n            while cell_label == 0\n                step!(ds, bsn_nfo.Δt)\n                u = current_state(ds)\n\n                # update FSM\n                n = Attractors.basin_cell_index(u, bsn_nfo.BoA.grid)\n                cell_label = Attractors.finite_state_machine!(bsn_nfo, n, u; mapper.kwargs...)\n\n                state = bsn_nfo.state\n\n                if cell_label ≠ 0 # FSM terminated; we assume no lost/divergence in the system\n                    stateobs[] = :terminated\n\n                    # color-code initial condition if we converged to attractor\n                    # or to basin (even or odd cell label)\n                    u0n = Attractors.basin_cell_index(u0, bsn_nfo.BoA.grid)\n\n                    basidx = (cell_label - 1)\n                    color_obs[u0n][] = COLORS[3+basidx]\n\n                    # Clean up: all \"visited\" cells become white again\n                    visited_idxs = findall(v -> (v[] == COLORS[2] || v[] == COLORS[3]), color_obs)\n                    for n in visited_idxs\n                        color_obs[n][] = COLORS[1] # empty\n                    end\n                    # clean up trajectory line\n                    traj[] = []\n\n                    for i in 1:15; recordframe!(io); end\n                    cell_label = 0\n                    break\n                end\n\n                # update visuals:\n                point[] = [u]\n                push!(traj[], u)\n                notify(traj)\n                marker[] = state2marker[state]\n                stateobs[] = state\n                consecutiveobs[] = bsn_nfo.consecutive_match\n\n                update_current_cell_color!(color_obs[n], bsn_nfo)\n\n                recordframe!(io)\n            end\n        end\n    end\nend\n\nanimate_attractors_via_recurrences(mapper, u0s)\n\n<video width=\"75%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/attractors/recurrence_algorithm.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"section"},{"location":"#Attractors.jl","page":"Attractors.jl","title":"Attractors.jl","text":"","category":"section"},{"location":"#Latest-news","page":"Attractors.jl","title":"Latest news","text":"Yet another groundbreaking feature has been implemented in Attractors.jl: estimation of extendably-many stability measures of a dynamical system automatically, with a single function call (also works along a globla continuation)\nSee the CHANGELOG.md (at the GitHub repo) for more!","category":"section"},{"location":"#Getting-started","page":"Attractors.jl","title":"Getting started","text":"Start by having a look at the tutorial, after which you can consult individual library functions in API. Many more examples can be found in the dedicated examples page.","category":"section"},{"location":"#Attractors","page":"Attractors.jl","title":"Attractors","text":"Attractors.jl\n\n(Image: docsdev) (Image: docsstable) (Image: Paper) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nAttractors.jl is a Julia package for\n\nFinding all attractors, and all types of attractors, of arbitrary dynamical systems. An extendable interface allows for new algorithms for finding attractors.\nFinding their basins of attraction or the state space fractions of the basins. This includes finding exit basins (divergence to infinity).\nAnalyzing nonlocal stability of attractors (also called global stability or  resilience).\nPerforming global continuation of attractors and their basins (or other measures of stability), over a parameter range. Global continuation is a new, cutting-edge type of continuation that offers several advantages over traditional local continuation (AUTO, MatCont, BifurcationKit.jl, etc.), see the comparison in our docs.\nFinding the basin boundaries and edges states and analyzing their fractal properties.\nTipping points related functionality for systems with known dynamic rule.\nAnd more!\n\nIt can be used as a standalone package, or as part of DynamicalSystems.jl.\n\nTo install it, run import Pkg; Pkg.add(\"Attractors\").\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\nPreviously, Attractors.jl was part of ChaosTools.jl\n\n\n\n\n\n","category":"module"},{"location":"tutorial/#tutorial","page":"Attractors.jl Tutorial","title":"Attractors.jl Tutorial","text":"<video width=\"auto\" controls loop>\n<source src=\"../attracont_extra.mp4\" type=\"video/mp4\">\n</video>\n\nAttractors is a component of the DynamicalSystems.jl library. This tutorial will walk you through its main functionality. That is, given a DynamicalSystem instance, find all its attractors and their basins of attraction. Then, continue these attractors, and their stability properties, across a parameter value. It also offers various functions that compute nonlocal stability properties for an attractor, any of which can be used in the continuation to quantify stability.\n\nBesides this main functionality, there are plenty of other stuff, like for example edgestate or basins_fractal_dimension, but we won't cover anything else in this introductory tutorial. See the examples page instead.","category":"section"},{"location":"tutorial/#Package-versions-used","page":"Attractors.jl Tutorial","title":"Package versions used","text":"import Pkg\n\nPkg.status([\"Attractors\", \"CairoMakie\", \"OrdinaryDiffEqVerner\"])","category":"section"},{"location":"tutorial/#Tutorial-copy-pasteable-version","page":"Attractors.jl Tutorial","title":"Tutorial - copy-pasteable version","text":"Gotta go fast!\n\nusing Attractors, CairoMakie, OrdinaryDiffEqVerner\n## Define key input: a `DynamicalSystem`\nfunction modified_lorenz_rule(u, p, t)\n    x, y, z = u; a, b = p\n    dx = y - x\n    dy = - x*z + b*abs(z)\n    dz = x*y - a\n    return SVector(dx, dy, dz)\nend\np0 = [5.0, 0.1] # parameters\nu0 = [-4.0, 5, 0] # state\ndiffeq = (alg = Vern9(), abstol = 1e-9, reltol = 1e-9, dt = 0.01) # solver options\nds = CoupledODEs(modified_lorenz_rule, u0, p0; diffeq)\n\n## Define key input: an `AttractorMaper` that finds\n## attractors of a `DynamicalSystem`\ngrid = (\n    range(-15.0, 15.0; length = 150), # x\n    range(-20.0, 20.0; length = 150), # y\n    range(-20.0, 20.0; length = 150), # z\n)\nmapper = AttractorsViaRecurrences(ds, grid;\n    consecutive_recurrences = 1000,\n    consecutive_lost_steps = 100,\n)\n\n## Find attractors and their basins of attraction state space fraction\n## by randomly sampling initial conditions in state sapce\nsampler, = statespace_sampler(grid)\nalgo = AttractorSeedContinueMatch(mapper)\nfs = basins_fractions(mapper, sampler)\nattractors = extract_attractors(mapper)\n\n## found two attractors: one is a limit cycle, the other is chaotic\n## visualize them\nplot_attractors(attractors)\n\n## continue all attractors and their basin fractions across any arbigrary\n## curve in parameter space using a global continuation algorithm\nalgo = AttractorSeedContinueMatch(mapper)\nparams(θ) = [1 => 5 + 0.5cos(θ), 2 => 0.1 + 0.01sin(θ)]\nangles = range(0, 2π; length = 101)\npcurve = params.(angles)\nfractions_cont, attractors_cont = global_continuation(\n\talgo, pcurve, sampler; samples_per_parameter = 1_000\n)\n\n## and visualize the results\nfig = plot_basins_attractors_curves(\n\tfractions_cont, attractors_cont, A -> minimum(A[:, 1]), angles; add_legend = false\n)","category":"section"},{"location":"tutorial/#Input:-a-DynamicalSystem","page":"Attractors.jl Tutorial","title":"Input: a DynamicalSystem","text":"The key input for most functionality of Attractors.jl is an instance of a DynamicalSystem. If you don't know how to make a DynamicalSystem, you need to consult the main tutorial of the DynamicalSystems.jl library. For this tutorial we will use a modified Lorenz-like system with equations\n\nbeginalign*\ndotx  = y - x \ndoty  = -x*z + b*z \ndotz  = x*y - a \nendalign*\n\nwhich we define in code as\n\nusing Attractors # part of `DynamicalSystems`, so it re-exports functionality for making them!\nusing OrdinaryDiffEqVerner # for accessing advanced ODE Solvers\n\nfunction modified_lorenz_rule(u, p, t)\n    x, y, z = u; a, b = p\n    dx = y - x\n    dy = - x * z + b * abs(z)\n    dz = x * y - a\n    return SVector(dx, dy, dz)\nend\n\np0 = [5.0, 0.1] # parameters\nu0 = [-4.0, 5, 0] # state\ndiffeq = (alg = Vern9(), abstol = 1.0e-9, reltol = 1.0e-9, dt = 0.01) # solver options\nds = CoupledODEs(modified_lorenz_rule, u0, p0; diffeq)","category":"section"},{"location":"tutorial/#Finding-attractors","page":"Attractors.jl Tutorial","title":"Finding attractors","text":"In this tutorial we will utilize two methods for finding attractors in dynamical systems. Explanation of how they work is in their respective docs.\n\nAttractorsViaRecurrences.\nAttractorsViaFeaturizing.\n\nYou can consult (Datseris et al., 2023) for a comparison between the two.\n\nAs far as the user is concerned, both algorithms are part of the same interface, and can be used in the same way. The interface is extendable as well, and works as follows.\n\nFirst, we create an instance of such an \"attractor finding algorithm\", which we call AttractorMapper. For example, AttractorsViaRecurrences requires a tesselated grid of the state space to search for attractors in. It also allows the user to tune some meta parameters, but in our example they are already tuned for the dynamical system at hand. So we initialize\n\ngrid = (\n    range(-10.0, 10.0; length = 150), # x\n    range(-15.0, 15.0; length = 150), # y\n    range(-15.0, 15.0; length = 150), # z\n)\n\nmapper = AttractorsViaRecurrences(\n    ds, grid;\n    consecutive_recurrences = 1000, attractor_locate_steps = 1000,\n    consecutive_lost_steps = 100,\n)\n\nThis mapper can map any initial condition to the corresponding attractor ID, for example\n\nmapper([-4.0, 5, 0])\n\nwhile\n\nmapper([4.0, 2, 0])\n\nthe fact that these two different initial conditions got assigned different IDs means that they converged to a different attractor. Indeed,\n\nmapper([1.0, 3, 2])\n\ngets the same ID as the first initial condition.\n\nThis functionality is already incredibly powerful! To our knowledge the DynamicalSystems.jl library is the only dynamical systems software (in any language) that provides such an infrastructure for mapping initial conditions of any arbitrary dynamical system to its unique attractors. And this is only the tip of this iceberg! The rest of the functionality of Attractors.jl is all full of brand new cutting edge progress in dynamical systems research.\n\nOkay, back to the tutorial now! The found attractors are stored in the mapper internally, to obtain them we use the function\n\nattractors = extract_attractors(mapper)\n\nIn Attractors.jl, all information regarding attractors is always a standard Julia Dict, which maps attractor IDs (positive integers) to the corresponding quantity. Here the quantity are the attractors themselves, represented as StateSpaceSet.\n\nWe can visualize them with the convenience plotting function\n\nusing CairoMakie\nplot_attractors(attractors)\n\n(this convenience function is a simple loop over scattering the values of the attractors dictionary)\n\nIn our example system we see that for the chosen parameters there are two coexisting attractors: a limit cycle and a chaotic attractor. There may be more attractors though! We've only checked two initial conditions, so we could have found at most two attractors! However, it can get tedious to manually iterate over initial conditions, which is why this mapper is typically given to higher level functions for finding attractors and their basins of attraction. The simplest one is basins_fractions. Using the mapper, it finds \"all\" attractors of the dynamical system and reports the state space fraction each attractors attracts. The search is probabilistic, so \"all\" attractors means those that at least one initial condition converged to.\n\nWe can provide explicitly initial conditions to basins_fractions, however it is typically simpler to provide it with with a state space sampler instead: a function that generates random initial conditions in the region of the state space that we are interested in. Here this region coincides with grid, so we can simply do:\n\nsampler, = statespace_sampler(grid)\n\nsampler() # random i.c.\n\nsampler() # another random i.c.\n\nand finally call\n\nfs = basins_fractions(mapper, sampler)\n\nThe returned fs is a dictionary mapping each attractor ID to the fraction of the state space the corresponding basin occupies. With this we can confirm that there are (likely) only two attractors and that both attractors are robust as both have sufficiently large basin fractions.\n\nTo obtain the full basins, which is computationally much more expensive, use basins_of_attraction.\n\nYou can use alternative algorithms in basins_fractions, see the documentation of AttractorMapper for possible subtypes. AttractorMapper defines an extendable interface and can be enriched with other methods in the future!","category":"section"},{"location":"tutorial/#Different-Attractor-Mapper","page":"Attractors.jl Tutorial","title":"Different Attractor Mapper","text":"Attractors.jl utilizes composable interfaces throughout its functionality. In the above example we used one particular method to find attractors, via recurrences in the state space. An alternative is AttractorsViaFeaturizing.\n\nFor this method, we need to provide a \"featurizing\" function that given an trajectory (which is likely an attractor), it returns some features that will hopefully distinguish different attractors in a subsequent grouping step. Finding good features is typically a trial-and-error process, but for our system we already have some good features:\n\nusing Statistics: mean\n\nfunction featurizer(A, t) # t is the time vector associated with trajectory A\n    xmin = minimum(A[:, 1])\n    ycen = mean(A[:, 2])\n    return SVector(xmin, ycen)\nend\n\nfrom which we initialize\n\nmapper2 = AttractorsViaFeaturizing(ds, featurizer; Δt = 0.1)\n\nAttractorsViaFeaturizing allows for a third input, which is a \"grouping configuration\", that dictates how features will be grouped into attractors, as features are extracted from (randomly) sampled state space trajectories. In this tutorial we leave it at its default value, which is clustering using the DBSCAN algorithm. The keyword arguments are meta parameters which control how long to integrate each initial condition for, and what sampling time, to produce a trajectory A given to the featurizer function. Because one of the two attractors is chaotic, we need denser sampling time than the default.\n\nWe can use mapper2 exactly as mapper:\n\nfs2 = basins_fractions(mapper2, sampler)\n\nattractors2 = extract_attractors(mapper2)\n\nplot_attractors(attractors2)\n\nThis mapper also found the attractors, but we should warn you: this mapper is less robust than AttractorsViaRecurrences. One of the reasons for this is that AttractorsViaFeaturizing is not auto-terminating. For example, if we do not have enough transient integration time, the two attractors will get confused into one:\n\nmapper3 = AttractorsViaFeaturizing(ds, featurizer; Ttr = 10, Δt = 0.1)\nfs3 = basins_fractions(mapper3, sampler)\nattractors3 = extract_attractors(mapper3)\nplot_attractors(attractors3)\n\nOn the other hand, the downside of AttractorsViaRecurrences is that it can take quite a while to converge for chaotic high dimensional systems.","category":"section"},{"location":"tutorial/#global_cont_tutorial","page":"Attractors.jl Tutorial","title":"Global continuation","text":"If you have heard before the word \"continuation\", then you are likely aware of the traditional continuation-based bifurcation analysis (CBA) offered by many software, such as AUTO, MatCont, and in Julia BifurcationKit.jl. These software perform local continuation. Here we offer a completely different kind of continuation called global continuation.\n\nThe local continuation continues the curves of individual fixed points (and under some conditions limit cycles) across the joint state-parameter space and tracks their local (linear) stability. This approach needs to manually be \"re-run\" for every individual branch of fixed points or limit cycles. The global continuation in Attractors.jl finds all attractors, including chaotic or quasiperiodic ones, in the whole of the state space (that it searches in), without manual intervention. It then continues all of these attractors concurrently along a parameter axis. Additionally, the global continuation tracks a nonlocal stability property which by default is the basin fraction.\n\nBecause all attractors are simultaneously tracked across the parameter axis, the user may arbitrarily estimate any property of the attractors and how it varies as the parameter varies. A more detailed comparison between these two approaches can be found in (Datseris et al., 2023). See also the comparison page in our docs that attempts to do the same analysis of our Tutorial with traditional continuation software.\n\nTo perform a global continuation is surprisingly simple. First, we decide what parameter, and what range of that parameter, to continue over:\n\nprange = 4.5:0.01:6\npidx = 1 # index of the parameter\n\nThen, we may call the global_continuation function. We have to provide a continuation algorithm, which itself references an AttractorMapper. In this example we will re-use the mapper to create the \"flagship product\" of Attractors.jl which is the general AttractorSeedContinueMatch. This algorithm uses the mapper to find all attractors at each parameter value and from the found attractors it continues them along a parameter axis using a seeding process (see its documentation string). Then, it performs a \"matching\" step, ensuring a \"continuity\" of the attractor label across the parameter axis. For now we ignore the matching step, leaving it to the default value. We'll use the mapper we created above and define\n\nascm = AttractorSeedContinueMatch(mapper)\n\nand call\n\nfractions_cont, attractors_cont = global_continuation(\n    ascm, prange, pidx, sampler; samples_per_parameter = 1_000\n)\n\nthe output is given as two vectors. Each vector is a dictionary mapping attractor IDs to their basin fractions, or their state space sets, respectively. Both vectors have the same size as the parameter range. For example, the attractors at the 34-th parameter value are:\n\nattractors_cont[34]\n\nIf you want to transform the output to the alternative format of a dictionary of vectors, use continuation_series. You typically don't have to though, because there is a fantastic convenience function for animating the attractors evolution, that utilizes things we have already defined:\n\nanimate_attractors_continuation(\n    ds, attractors_cont, fractions_cont, prange, pidx\n);\nnothing #hide\n\n<video width=\"auto\" controls loop>\n<source src=\"../attracont.mp4\" type=\"video/mp4\">\n</video>\n\nHah, how cool is that! The attractors pop in and out of existence like out of nowhere! It can be difficult to find these attractors in traditional continuation software where a rough estimate of the period is required! (It would also be too hard due to the presence of chaos for most of the parameter values, but that's another issue!)\n\nNow typically a continuation is visualized in a 2D plot where the x axis is the parameter axis. We can do this with the convenience function:\n\nfig = plot_basins_attractors_curves(\n    fractions_cont, attractors_cont, A -> minimum(A[:, 1]), prange,\n)\n\nIn the top panel are the basin fractions, by default plotted as stacked bars. Bottom panel is a visualization of some feature(s) of the tracked attractors. The argument A -> minimum(A[:, 1]) is simply a function that maps an attractor into a real number for plotting. A vector of such functions can be given instead.\n\nMoreover, you can combine the animation we created above with this continuation plot so you can see both the attractors in state space as well as some chosen feature(s). This is done by calling animate_attractors_continuation again with additional keyword arguments like so:\n\nfig = animate_attractors_continuation(\n    ds, attractors_cont, fractions_cont, prange, pidx;\n    figure = (size = (600, 700),),\n    axis = (ylabel = \"y\", xlabel = \"x\"),\n    savename = \"attracont_extra.mp4\",\n    add_legend = false,\n    a2rs = [A -> minimum(A[:, 1]), A -> maximum(A[:, 2])],\n    a2rs_ylabels = [\"x-min\", \"y-max\"],\n    a2rs_ratio = 0.33,\n    vline_kwargs = (linestyle = :dash, linewidth = 3, color = \"red\"),\n)\n\n<video width=\"auto\" controls loop>\n<source src=\"../attracont_extra.mp4\" type=\"video/mp4\">\n</video>","category":"section"},{"location":"tutorial/#Different-matching-procedures","page":"Attractors.jl Tutorial","title":"Different matching procedures","text":"By default attractors are matched by their distance in state space. The default matcher is MatchBySSSetDistance, and is given implicitly as a default 2nd argument when creating AttractorSeedContinueMatch. But like anything else in Attractors.jl, \"matchers\" also follow a well-defined and extendable interface, see IDMatchers for that.\n\nLet's say that the default matching that we chose above isn't desirable. For example, one may argue that the attractor that pops up at the end of the continuation should have been assigned the same ID as attractor 1, because they are both to the left (see the video above). In reality one wouldn't really request that, because looking the video of attractors above shows that the attractors labelled \"1\", \"2\", and \"3\" are all completely different. But we argue here for example that \"3\" should have been the same as \"1\".\n\nThankfully during a global continuation the \"matching\" step is completely separated from the \"finding and continuing\" step. If we don't like the initial matching, we can call match_sequentially! with a new instance of a matcher, and match again, without having to recompute the attractors and their basin fractions. For example, using this matcher:\n\nmatcher = MatchBySSSetDistance(use_vanished = true)\n\nwill compare a new attractor with the latest instance of attractors with a given ID that have ever existed, irrespectively if they exist in the current parameter or not. This means, that the attractor \"3\" would in fact be compared with both attractor \"2\" and \"1\", even if \"1\" doesn't exist in the parameter \"3\" started existing at. And because \"3\" is closer to \"1\" than to \"2\", it will get matched to attractor \"1\" and get the same ID.\n\nLet's see this in action:\n\nattractors_cont2 = deepcopy(attractors_cont)\n\nmatch_sequentially!(attractors_cont2, matcher)\n\nfig = plot_attractors_curves(\n    attractors_cont2, A -> minimum(A[:, 1]), prange,\n)\n\nand as we can see, the new attractor at the end of the parameter range got assigned the same ID as the original attractor \"1\". For more ways of matching attractors see IDMatcher.","category":"section"},{"location":"tutorial/#Continuation-along-arbitrary-parameter-curves","page":"Attractors.jl Tutorial","title":"Continuation along arbitrary parameter curves","text":"One of the many advantages of the global continuation is that we can choose what parameters to continue over. We can provide any arbitrary curve in parameter space. This is possible because (1) finding and matching attractors are two completely orthogonal steps, and (2) it is completely fine for attractors to dissapear (and perhaps re-appear) during a global continuation.\n\n#For example, we can probe an elipsoid defined as\n\nparams(θ) = [1 => 5 + 0.5cos(θ), 2 => 0.1 + 0.01sin(θ)]\nθs = range(0, 2π; length = 101)\npcurve = params.(θs)\n\nhere each component maps the parameter index to its value. We can just give this pcurve to the global continuation, using the same mapper and continuation algorithm, but adjusting the matching process so that vanished attractors are kept in \"memory\"\n\nmatcher = MatchBySSSetDistance(use_vanished = true)\n\nascm = AttractorSeedContinueMatch(mapper, matcher)\n\nfractions_cont, attractors_cont = global_continuation(\n    ascm, pcurve, sampler; samples_per_parameter = 1_000\n)\n\nand animate the result\n\nanimate_attractors_continuation(\n    ds, attractors_cont, fractions_cont, pcurve;\n    savename = \"curvecont.mp4\"\n);\nnothing #hide\n\n<video width=\"auto\" controls loop>\n<source src=\"../curvecont.mp4\" type=\"video/mp4\">\n</video>","category":"section"},{"location":"tutorial/#Enhancing-the-continuation-with-more-stability-measures-or-other-quantities","page":"Attractors.jl Tutorial","title":"Enhancing the continuation with more stability measures or other quantities","text":"The standard stability measure that is reported during a global continuation is the basin fractions. This is primarily because it is computed automatically as we find the different attractors. There are many more stability measures that could be more useful in different contexts. Attractors.jl offers the unique possibility of estimating almost all known measures of stability in the literature of dynamical systems during a single global continuation pass. This is done with the StabilityMeasuresAccumulator data structure. You can visit its documentation string to learn about all different stability measures. If you find some stability measures not included in the StabilityMeasuresAccumulator then either open an Issue and tell us about it or even better make a Pull Request and contribute it yourself!\n\nUsing StabilityMeasuresAccumulator is very easy. If we have already performed a global continuation then we can utilize the function stability_measures_along_continuation to run through it again and estimate now all stability measures.\n\nresult = stability_measures_along_continuation(\n    ds, attractors_cont, pcurve, sampler; ε = 0.1\n)\nkeys(result)\n\nThe result is a dictionary mapping the stability measure name (as a string) to the continuation of the measure. We can see there are quite a lot of measures that have been estimated! So the values of result are the same type as the fractions_cont we have computed before. This means it is straightforward to visualize these new stability measures. For example, let's say we want to visualize\n\nchosen = [\"median_convergence_pace\", \"minimal_critical_shock_magnitude\"]\nabbrev = [\"MCP\", \"MCS\"]\n\nthen we just use the visualization function plot_continuation_curves\n\nukeys = unique_keys(attractors_cont) # so that we ignore key -1 (divergent orbits)\nfig = plot_attractors_curves(attractors_cont, A -> minimum(A[:, 1]), θs)\nfor (i, c) in enumerate(chosen)\n    ax = Axis(fig[1 - i, 1]; ylabel = abbrev[i])\n    measure_cont = result[c]\n    plot_continuation_curves!(ax, measure_cont, θs; ukeys, add_legend = false)\n    hidexdecorations!(ax; grid = false)\nend\nresize!(fig, 600, 500)\nfig\n\nFor more specialization on estimating these stability measures, see the documentation of StabilityMeasuresAccumulator.\n\nOne of the biggest strengths of Attractors.jl is that it is not an isolated software. It is part of DynamicalSystems.jl. We can straightforwardly use any other functionality of the library to enhance this continuation, even beyond stability measures. Let's also estimate and visualize the maximum Lyapunov exponent for each attractor. We first import the function that estimates the MLE\n\nusing ChaosTools: lyapunov\n\nand then, the estimation itself is rather simple:\n\nlis = map(enumerate(pcurve)) do (i, p) # loop over parameters\n    set_parameters!(ds, p) # important! We use the dynamical system!\n    attractors = attractors_cont[i]\n    # Return a dictionary mapping attractor IDs to their MLE\n    Dict(k => lyapunov(ds, 10000.0; u0 = A[1]) for (k, A) in attractors)\nend\n\nThe above map loop may be intimidating if you are a beginner, but it is really just a shorter way to write a for loop for our example. We iterate over all parameters, and for each we first update the dynamical system with the correct parameter, and then extract the MLE for each attractor. map just means that we don't have to pre-allocate a new vector before the loop; it creates it for us.\n\nWe now visualize the MLE with the same way as any other quantity over the continuation:\n\naxλ = Axis(fig[-length(chosen), 1]; ylabel = \"MLE\")\nhidexdecorations!(axλ)\nplot_continuation_curves!(axλ, lis, θs; add_legend = false)\nfig\n\nThis reveals crucial information for tha attractors, whether they are chaotic or not, that we would otherwise obtain only by visualizing the system dynamics at every single point in the continuation parameter.","category":"section"},{"location":"tutorial/#Conclusion-and-comparison-with-traditional-local-continuation","page":"Attractors.jl Tutorial","title":"Conclusion and comparison with traditional local continuation","text":"We've reached the end of the tutorial! Some aspects we haven't highlighted is how most of the infrastructure of Attractors.jl is fully extendable. You will see this when reading the documentation strings of key structures like AttractorMapper. All documentation strings are in the API page. See the examples page for more varied applications. And lastly, see the comparison page in our docs that attempts to do the same analysis of our Tutorial with traditional local continuation and bifurcation analysis software showing that (at least for this example) using Attractors.jl is clearly beneficial over the alternatives.","category":"section"}]
}
