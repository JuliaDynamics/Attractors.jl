<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Attractors.jl</title><meta name="title" content="API · Attractors.jl"/><meta property="og:title" content="API · Attractors.jl"/><meta property="twitter:title" content="API · Attractors.jl"/><meta name="description" content="Documentation for Attractors.jl."/><meta property="og:description" content="Documentation for Attractors.jl."/><meta property="twitter:description" content="Documentation for Attractors.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Attractors.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Attractors.jl</a></li><li><a class="tocitem" href="../tutorial/">Attractors.jl Tutorial</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Finding-attractors"><span>Finding attractors</span></a></li><li><a class="tocitem" href="#Grouping-configurations"><span>Grouping configurations</span></a></li><li><a class="tocitem" href="#Basins-of-attraction"><span>Basins of attraction</span></a></li><li><a class="tocitem" href="#Convergence-times"><span>Convergence times</span></a></li><li><a class="tocitem" href="#Final-state-sensitivity-/-fractal-boundaries"><span>Final state sensitivity / fractal boundaries</span></a></li><li><a class="tocitem" href="#Edge-tracking-and-edge-states"><span>Edge tracking and edge states</span></a></li><li><a class="tocitem" href="#Tipping-points"><span>Tipping points</span></a></li><li><a class="tocitem" href="#Minimal-Fatal-Shock"><span>Minimal Fatal Shock</span></a></li><li><a class="tocitem" href="#Global-continuation"><span>Global continuation</span></a></li><li><a class="tocitem" href="#Matching-attractors"><span>Matching attractors</span></a></li><li><a class="tocitem" href="#Visualization-utilities"><span>Visualization utilities</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Examples for Attractors.jl</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Attractors.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Attractors.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Finding-attractors"><a class="docs-heading-anchor" href="#Finding-attractors">Finding attractors</a><a id="Finding-attractors-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-attractors" title="Permalink"></a></h2><p>Attractors.jl defines a generic interface for finding attractors of dynamical systems. One first decides the instance of <a href="@ref"><code>DynamicalSystem</code></a> they need. Then, an instance of <a href="#Attractors.AttractorMapper"><code>AttractorMapper</code></a> is created from this dynamical system. This <code>mapper</code> instance can be used to compute e.g., <a href="#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>, and the output can be further analyzed to get e.g., the <a href="#Attractors.basin_entropy"><code>basin_entropy</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.AttractorMapper" href="#Attractors.AttractorMapper"><code>Attractors.AttractorMapper</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AttractorMapper(ds::DynamicalSystem, args...; kwargs...) → mapper</code></pre><p>Subtypes of <code>AttractorMapper</code> are structures that map initial conditions of <code>ds</code> to attractors. The found attractors are stored inside the <code>mapper</code>, and can be obtained by calling <code>attractors = extract_attractors(mapper)</code>.</p><p>Currently available mapping methods:</p><ul><li><a href="#Attractors.AttractorsViaProximity"><code>AttractorsViaProximity</code></a></li><li><a href="#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a></li><li><a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a></li></ul><p>All <code>AttractorMapper</code> subtypes can be used with <a href="#Attractors.basins_fractions"><code>basins_fractions</code></a> or <a href="#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>.</p><p>In addition, some mappers can be called as a function of an initial condition:</p><pre><code class="language-julia hljs">label = mapper(u0)</code></pre><p>and this will on the fly compute and return the label of the attractor <code>u0</code> converges at. The mappers that can do this are:</p><ul><li><a href="#Attractors.AttractorsViaProximity"><code>AttractorsViaProximity</code></a></li><li><a href="#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a></li><li><a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a> with the <a href="#Attractors.GroupViaHistogram"><code>GroupViaHistogram</code></a> configuration.</li></ul><p><strong>For developers</strong></p><p><code>AttractorMapper</code> defines an extendable interface. A new type needs to implement <a href="#Attractors.extract_attractors"><code>extract_attractors</code></a> and <code>id = mapper(u0)</code>. From these, everything else in the entire rest of the library just works! If it is not possible to implement <code>id = mapper(u0)</code>, then instead extend <code>basins_fractions(mapper, ics)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/mapping/attractor_mapping.jl#L23-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.extract_attractors" href="#Attractors.extract_attractors"><code>Attractors.extract_attractors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_attractors(mapper::AttractorsMapper) → attractors</code></pre><p>Return a dictionary mapping label IDs to attractors found by the <code>mapper</code>. This function should be called after calling <a href="#Attractors.basins_fractions"><code>basins_fractions</code></a> with the given <code>mapper</code> so that the attractors have actually been found first.</p><p>For <code>AttractorsViaFeaturizing</code>, the attractors are only stored if the mapper was called with pre-defined initial conditions rather than a sampler (function returning initial conditions).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/mapping/attractor_mapping.jl#L149-L159">source</a></section></article><h3 id="Recurrences"><a class="docs-heading-anchor" href="#Recurrences">Recurrences</a><a id="Recurrences-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrences" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.AttractorsViaRecurrences" href="#Attractors.AttractorsViaRecurrences"><code>Attractors.AttractorsViaRecurrences</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AttractorsViaRecurrences(ds::DynamicalSystem, grid; kwargs...)</code></pre><p>Map initial conditions of <code>ds</code> to attractors by identifying attractors on the fly based on recurrences in the state space, as outlined in (<a href="../references/#Datseris2022">Datseris and Wagemakers, 2022</a>). However, the Description section below for has a more accurate (and simpler) exposition to the algorithm than the paper.</p><p><code>grid</code> is instructions for partitioning the state space into finite-sized cells so that a finite state machine can operate on top of it. Possibilities are:</p><ol><li>A tuple of sorted <code>AbstractRange</code>s for a regular grid.</li></ol><p>Example is <code>grid = (xg, yg)</code> where <code>xg = yg = range(-5, 5; length = 100)</code>   for a two-dimensional system.</p><ol><li>A tuple of sorted <code>AbstractVector</code>s for an irregular grid, for example</li></ol><p><code>grid = (xg, yg)</code> with <code>xg = range(0, 10.0^(1/2); length = 200).^2,   yg = range(-5, 5; length = 100)</code>.</p><ol><li>An instance of the special grid type</li></ol><p><a href="#Attractors.SubdivisionBasedGrid"><code>SubdivisionBasedGrid</code></a>, which can be created either manually or by using   <a href="#Attractors.subdivision_based_grid"><code>subdivision_based_grid</code></a>.   This automatically analyzes and adapts grid discretization   levels in accordance with state space flow speed in different regions.</p><p>The grid has to be the same dimensionality as the state space, use a <a href="@ref"><code>ProjectedDynamicalSystem</code></a> if you want to search for attractors in a lower dimensional subspace.</p><p><strong>Keyword arguments</strong></p><ul><li><code>sparse = true</code>: control the storage type of the state space grid. If true,  uses a sparse array, whose memory usage is in general more efficient than a regular  array obtained with <code>sparse=false</code>. In practice, the sparse representation should  always be preferred when searching for <a href="#Attractors.basins_fractions"><code>basins_fractions</code></a>. Only for very low  dimensional systems and for computing the full <a href="#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a> the  non-sparse version should be used.</li></ul><p><strong>Time evolution configuration</strong></p><ul><li><code>Ttr = 0</code>: Skip a transient before the recurrence routine begins.</li><li><code>Δt</code>: Approximate integration time step (second argument of the <code>step!</code> function). The keyword <code>Dt</code> can also be used instead if <code>Δ</code> (<code>\Delta</code>) is not accessible. It is <code>1</code> for discrete time systems. For continuous systems, an automatic value is calculated using <a href="#Attractors.automatic_Δt_basins"><code>automatic_Δt_basins</code></a>. For very fine grids, this can become very small, much smaller than the typical integrator internal step size in case of adaptive integrators. In such cases, use <code>force_non_adaptive = true</code>.</li><li><code>force_non_adaptive = false</code>: Only used if the input dynamical system is <code>CoupledODEs</code>. If <code>true</code> the additional keywords <code>adaptive = false, dt = Δt</code> are given as <code>diffeq</code> to the <code>CoupledODEs</code>. This means that adaptive integration is turned off and <code>Δt</code> is used as the ODE integrator timestep. This is useful in (1) very fine grids, and (2) if some of the attractors are limit cycles. We have noticed that in this case the integrator timestep becomes commensurate with the limit cycle period, leading to incorrectly counting the limit cycle as more than one attractor.</li></ul><p><strong>Finite state machine configuration</strong></p><ul><li><code>consecutive_recurrences = 100</code>: Number of consecutive visits to previously visited unlabeled cells (i.e., recurrences) required before declaring we have converged to a new attractor. This number tunes the accuracy of converging to attractors and should generally be high (and even higher for chaotic systems).</li><li><code>attractor_locate_steps = 1000</code>: Number of subsequent steps taken to locate accurately the new attractor after the convergence phase is over. Once <code>attractor_locate_steps</code> steps have been taken, the new attractor has been identified with sufficient accuracy and iteration stops. This number can be very high without much impact to overall performance.</li><li><code>store_once_per_cell = true</code>: Control if multiple points in state space that belong to the same cell are stored or not in the attractor, when a new attractor is found. If <code>true</code>, each visited cell will only store a point once, which is desirable for fixed points and limit cycles. If <code>false</code> then <code>attractor_locate_steps</code> points are stored per attractor, leading to more densely stored attractors, which may be desirable for instance in chaotic attractors.</li><li><code>consecutive_attractor_steps = 2</code>: Μaximum checks of consecutives hits of an existing attractor cell before declaring convergence to that existing attractor.</li><li><code>consecutive_basin_steps = 10</code>: Number of consecutive visits of the same basin of attraction required before declaring convergence to an existing attractor. This is ignored if <code>sparse = true</code>, as basins are not stored internally in that case.</li><li><code>consecutive_lost_steps = 20</code>: Maximum check of iterations outside the defined grid before we declare the orbit lost outside and hence assign it label <code>-1</code>.</li><li><code>horizon_limit = 1e6</code>: If the norm of the integrator state reaches this limit we declare that the orbit diverged to infinity.</li><li><code>maximum_iterations = Int(1e6)</code>: A safety counter that is always increasing for each initial condition. Once exceeded, the algorithm assigns <code>-1</code> and throws a warning. This clause exists to stop the algorithm never halting for inappropriate grids. It may happen when a newly found attractor orbit intersects in the same cell of a previously found attractor (which leads to infinite resetting of all counters).</li></ul><p><strong>Description</strong></p><p>An initial condition given to an instance of <code>AttractorsViaRecurrences</code> is iterated based on the integrator corresponding to <code>ds</code>. Enough recurrences in the state space (i.e., a trajectory visited a region it has visited before) means that the trajectory has converged to an attractor. This is the basis for finding attractors.</p><p>A finite state machine (FSM) follows the trajectory in the state space, and constantly maps it to a cell in the given <code>grid</code>. The grid cells store information: they are empty, visited, basins, or attractor cells. The state of the FSM is decided based on the cell type and the previous state of the FSM. Whenever the FSM recurs its state, its internal counter is increased, otherwise it is reset to 0. Once the internal counter reaches a threshold, the FSM terminates or changes its state. The possibilities for termination are the following:</p><ul><li>The trajectory hits <code>consecutive_recurrences</code> times in a row previously visited cells:  it is considered that an attractor is found and is labelled with a new ID. Then,  iteration continues for <code>attractor_locate_steps</code> steps. Each cell visited in this period stores  the &quot;attractor&quot; information. Then iteration terminates and the initial condition is  numbered with the attractor&#39;s ID.</li><li>The trajectory hits an already identified attractor <code>consecutive_attractor_steps</code> consecutive times:  the initial condition is numbered with the attractor&#39;s basin ID.</li><li>The trajectory hits a known basin <code>consecutive_basin_steps</code> times in a row: the initial condition  belongs to that basin and is numbered accordingly. Notice that basins are stored and  used only when <code>sparse = false</code> otherwise this clause is ignored.</li><li>The trajectory spends <code>consecutive_lost_steps</code> steps outside the defined grid or the norm  of the dynamical system state becomes &gt; than <code>horizon_limit</code>: the initial  condition is labelled <code>-1</code>.</li><li>If none of the above happens, the initial condition is labelled <code>-1</code> after  <code>maximum_iterations</code> steps.</li></ul><p>There are some special internal optimizations and details that we do not describe here but can be found in comments in the source code. (E.g., a special timer exists for the &quot;lost&quot; state which does not interrupt the main timer of the FSM.)</p><p>A video illustrating how the algorithm works can be found in the online documentation, under the <a href="../recurrences_animation/#recurrences_animation">recurrences animation</a> page.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/mapping/recurrences/attractor_mapping_recurrences.jl#L4-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.automatic_Δt_basins" href="#Attractors.automatic_Δt_basins"><code>Attractors.automatic_Δt_basins</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">automatic_Δt_basins(ds::DynamicalSystem, grid; N = 5000) → Δt</code></pre><p>Calculate an optimal <code>Δt</code> value for <a href="#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>. This is done by evaluating the dynamic rule <code>f</code> (vector field) at <code>N</code> randomly chosen points within the bounding box of the grid. The average <code>f</code> is then compared with the average diagonal length of a grid cell and their ratio provides <code>Δt</code>.</p><p>Notice that <code>Δt</code> should not be too small which happens typically if the grid resolution is high. It is okay if the trajectory skips a few cells. Also, <code>Δt</code> that is smaller than the internal step size of the integrator will cause a performance drop.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/mapping/recurrences/attractor_mapping_recurrences.jl#L312-L325">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.SubdivisionBasedGrid" href="#Attractors.SubdivisionBasedGrid"><code>Attractors.SubdivisionBasedGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SubdivisionBasedGrid(grid::NTuple{D, &lt;:AbstractRange}, lvl_array::Array{Int, D})</code></pre><p>Given a coarse <code>grid</code> tesselating the state space, construct a <code>SubdivisionBasedGrid</code> based on the given level array <code>lvl_array</code> that should have the same dimension as <code>grid</code>. The level array has non-negative integer values, with 0 meaning that the corresponding cell of the coarse <code>grid</code> should not be subdivided any further. Value <code>n &gt; 0</code> means that the corresponding cell will be subdivided in total <code>2^n</code> times (along each dimension), resulting in finer cells within the original coarse cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/mapping/recurrences/grids.jl#L34-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.subdivision_based_grid" href="#Attractors.subdivision_based_grid"><code>Attractors.subdivision_based_grid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">subdivision_based_grid(ds::DynamicalSystem, grid; maxlevel = 4, q = 0.99)</code></pre><p>Construct a grid structure <a href="#Attractors.SubdivisionBasedGrid"><code>SubdivisionBasedGrid</code></a> that can be directly passed as a grid to <a href="#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a>. The input <code>grid</code> is an originally coarse grid (a tuple of <code>AbstractRange</code>s). The state space speed is evaluate in all cells of the <code>grid</code>. Cells with small speed (when compared to the &quot;max&quot; speed) resultin in this cell being subdivided more. To avoid problems with spikes in the speed, the <code>q</code>-th quantile of the velocities is used as the &quot;max&quot; speed (use <code>q = 1</code> for true maximum). The subdivisions in the resulting grid are clamped to at most value <code>maxlevel</code>.</p><p>This approach is designed for <em>continuous time</em> systems in which different areas of the state space flow may have significantly different velocity. In case of originally coarse grids, this may lead <a href="#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a> being stuck in some state space regions with a small motion speed and false identification of attractors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/mapping/recurrences/grids.jl#L56-L73">source</a></section></article><h3 id="Proximity"><a class="docs-heading-anchor" href="#Proximity">Proximity</a><a id="Proximity-1"></a><a class="docs-heading-anchor-permalink" href="#Proximity" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.AttractorsViaProximity" href="#Attractors.AttractorsViaProximity"><code>Attractors.AttractorsViaProximity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AttractorsViaProximity(ds::DynamicalSystem, attractors::Dict [, ε]; kwargs...)</code></pre><p>Map initial conditions to attractors based on whether the trajectory reaches <code>ε</code>-distance close to any of the user-provided <code>attractors</code>. They have to be in a form of a dictionary mapping attractor labels to <code>StateSpaceSet</code>s containing the attractors.</p><p>The system gets stepped, and at each step the minimum distance to all attractors is computed. If any of these distances is <code>&lt; ε</code>, then the label of the nearest attractor is returned.</p><p>If an <code>ε::Real</code> is not provided by the user, a value is computed automatically as half of the minimum distance between all attractors. This operation can be expensive for large <code>StateSpaceSet</code>s. If <code>length(attractors) == 1</code>, then <code>ε</code> becomes 1/10 of the diagonal of the box containing the attractor. If <code>length(attractors) == 1</code> and the attractor is a single point, an error is thrown.</p><p><strong>Keywords</strong></p><ul><li><code>Ttr = 100</code>: Transient time to first evolve the system for before checking for proximity.</li><li><code>Δt = 1</code>: Step time given to <code>step!</code>.</li><li><code>horizon_limit = 1e3</code>: If the maximum distance of the trajectory from any of the given attractors exceeds this limit, it is assumed that the trajectory diverged (gets labelled as <code>-1</code>).</li><li><code>consecutive_lost_steps = 1000</code>: If the integrator has been stepped this many times without coming <code>ε</code>-near to any attractor,  it is assumed that the trajectory diverged (gets labelled as <code>-1</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/mapping/attractor_mapping_proximity.jl#L1-L29">source</a></section></article><h3 id="Featurizing"><a class="docs-heading-anchor" href="#Featurizing">Featurizing</a><a id="Featurizing-1"></a><a class="docs-heading-anchor-permalink" href="#Featurizing" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.AttractorsViaFeaturizing" href="#Attractors.AttractorsViaFeaturizing"><code>Attractors.AttractorsViaFeaturizing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AttractorsViaFeaturizing(
    ds::DynamicalSystem, featurizer::Function,
    grouping_config = GroupViaClustering(); kwargs...
)</code></pre><p>Initialize a <code>mapper</code> that maps initial conditions to attractors using a featurizing and grouping approach. This is a supercase of the featurizing and clustering approach that is utilized by bSTAB (<a href="../references/#Stender2021">Stender and Hoffmann, 2021</a>) and MCBB (<a href="../references/#Gelbrecht2020">Gelbrecht <em>et al.</em>, 2020</a>). See <a href="#Attractors.AttractorMapper"><code>AttractorMapper</code></a> for how to use the <code>mapper</code>. This <code>mapper</code> also allows the syntax <code>mapper(u0)</code> but only if the <code>grouping_config</code> is <em>not</em> <code>GroupViaClustering</code>.</p><p><code>featurizer</code> is a function <code>f(A, t)</code> that takes as an input an integrated trajectory <code>A::StateSpaceSet</code> and the corresponding time vector <code>t</code> and returns a vector <code>v</code> of features describing the trajectory. For better performance, it is strongly recommended that <code>v isa SVector{&lt;:Real}</code>.</p><p><code>grouping_config</code> is an instance of any subtype of <a href="#Attractors.GroupingConfig"><code>GroupingConfig</code></a> and decides how features will be grouped into attractors, see below.</p><p>See also the intermediate functions <a href="#Attractors.extract_features"><code>extract_features</code></a> and <a href="#Attractors.group_features"><code>group_features</code></a>, which can be utilized when wanting to work directly with features.</p><p><strong>Keyword arguments</strong></p><ul><li><code>T=100, Ttr=100, Δt=1</code>: Propagated to <code>DynamicalSystems.trajectory</code> for integrating an initial condition to yield <code>A, t</code>.</li><li><code>threaded = true</code>: Whether to run the generation of features over threads by integrating trajectories in parallel.</li></ul><p><strong>Description</strong></p><p>The trajectory <code>X</code> of an initial condition is transformed into features. Each feature is a number useful in <em>characterizing the attractor</em> the initial condition ends up at, and <strong>distinguishing it from other attractors</strong>. Example features are the mean or standard deviation of some the dimensions of the trajectory, the entropy of some of the dimensions, the fractal dimension of <code>X</code>, or anything else you may fancy.</p><p>All feature vectors (each initial condition = 1 feature vector) are then grouped using one of the sevaral available grouping configurations. Each group is assumed to be a unique attractor, and hence each initial condition is labelled according to the group it is part of. The method thus relies on the user having at least some basic idea about what attractors to expect in order to pick the right features, and the right way to group them, in contrast to <a href="#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a>.</p><p>Attractors are stored and can be accessed with <a href="#Attractors.extract_attractors"><code>extract_attractors</code></a>, however it should be clear that this mapper never actually finds attractors. They way we store attractors is by picking the first initial condition that belongs to the corresponding &quot;attractor group&quot;, and then recording its trajectory with the same arguments <code>T, Ttr, Δt</code>. This is stored as the attractor, but of course there is no guarantee that this is actually an attractor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/mapping/grouping/attractor_mapping_featurizing.jl#L22-L74">source</a></section></article><h2 id="Grouping-configurations"><a class="docs-heading-anchor" href="#Grouping-configurations">Grouping configurations</a><a id="Grouping-configurations-1"></a><a class="docs-heading-anchor-permalink" href="#Grouping-configurations" title="Permalink"></a></h2><p>Grouping configurations that can be given to <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a> are part of a generic and extendable interface based on the <a href="#Attractors.group_features"><code>group_features</code></a> function. The grouping configuration sets how the features describing the trajectories will be grouped together. Nevertheless, this grouping infrastructure can also be used and extended completely independently of finding attractors of dynamical systems!</p><h3 id="Grouping-interface"><a class="docs-heading-anchor" href="#Grouping-interface">Grouping interface</a><a id="Grouping-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Grouping-interface" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.group_features" href="#Attractors.group_features"><code>Attractors.group_features</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">group_features(features, group_config::GroupingConfig) → labels</code></pre><p>Group the given iterable of &quot;features&quot; (anything that can be grouped, typically vectors of real numbers) according to the configuration and return the labels (vector of equal length as <code>features</code>). See <a href="#Attractors.GroupingConfig"><code>GroupingConfig</code></a> for possible grouping configuration configurations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/mapping/grouping/all_grouping_configs.jl#L35-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.GroupingConfig" href="#Attractors.GroupingConfig"><code>Attractors.GroupingConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><p>GroupingConfig</p><p>Supertype for configuration structs on how to group features together. Used in several occasions such as <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a> or <a href="#Attractors.aggregate_attractor_fractions"><code>aggregate_attractor_fractions</code></a>.</p><p>Currently available grouping configurations are:</p><ul><li><a href="#Attractors.GroupViaClustering"><code>GroupViaClustering</code></a></li><li><a href="#Attractors.GroupViaNearestFeature"><code>GroupViaNearestFeature</code></a></li><li><a href="#Attractors.GroupViaHistogram"><code>GroupViaHistogram</code></a></li><li><a href="#Attractors.GroupViaPairwiseComparison"><code>GroupViaPairwiseComparison</code></a></li></ul><p><strong>For developers</strong></p><p><code>GroupingConfig</code> defines an extendable interface. The only thing necessary for a new grouping configuration is to:</p><ol><li>Make a new type and subtype <code>GroupingConfig</code>.</li><li>If the grouping allows for mapping individual features to group index, then instead extend the <strong>internal function</strong> <code>feature_to_group(feature, config)</code>. This will also allow doing <code>id = mapper(u0)</code> with <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a>.</li><li>Else, extend the function <code>group_features(features, config)</code>. You could still extend <code>group_features</code> even if (2.) is satisfied, if there are any performance benefits.</li><li>Include the new grouping file in the <code>grouping/all_grouping_configs.jl</code> and list it in this documentation string.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/mapping/grouping/all_grouping_configs.jl#L3-L31">source</a></section></article><h3 id="Grouping-types"><a class="docs-heading-anchor" href="#Grouping-types">Grouping types</a><a id="Grouping-types-1"></a><a class="docs-heading-anchor-permalink" href="#Grouping-types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.GroupViaClustering" href="#Attractors.GroupViaClustering"><code>Attractors.GroupViaClustering</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GroupViaClustering(; kwargs...)</code></pre><p>Initialize a struct that contains instructions on how to group features in <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a>. <code>GroupViaClustering</code> clusters features into groups using DBSCAN, similar to the original work by bSTAB (<a href="../references/#Stender2021">Stender and Hoffmann, 2021</a>) and MCBB (<a href="../references/#Gelbrecht2020">Gelbrecht <em>et al.</em>, 2020</a>). Several options on clustering are available, see keywords below.</p><p>The defaults are a significant improvement over existing literature, see Description.</p><p><strong>Keyword arguments</strong></p><ul><li><code>clust_distance_metric = Euclidean()</code>: A metric to be used in the clustering. It can be any function <code>f(a, b)</code> that returns the distance between real-valued vectors <code>a, b</code>. All metrics from Distances.jl can be used here.</li><li><code>rescale_features = true</code>: if true, rescale each dimension of the extracted features separately into the range <code>[0,1]</code>. This typically leads to more accurate clustering.</li><li><code>min_neighbors = 10</code>: minimum number of neighbors (i.e. of similar features) each feature needs to have, including counting its own self, in order to be considered in a cluster (fewer than this, it is labeled as an outlier, <code>-1</code>).</li><li><code>use_mmap = false</code>: whether to use an on-disk map for creating the distance matrix of the features. Useful when the features are so many where a matrix with side their length would not fit to memory.</li></ul><p><strong>Keywords for optimal radius estimation</strong></p><ul><li><code>optimal_radius_method::Union{Real, String} = &quot;silhouettes_optim&quot;</code>: if a real number, it is the radius used to cluster features. Otherwise, it determines the method used to automatically determine that radius. Possible values are:<ul><li><code>&quot;silhouettes&quot;</code>: Performs a linear (sequential) search for the radius that maximizes a   statistic of the silhouette values of clusters (typically the mean). This can be chosen   with <code>silhouette_statistic</code>. The linear search may take some time to finish. To   increase speed, the number of radii iterated through can be reduced by decreasing   <code>num_attempts_radius</code> (see its entry below).</li><li><code>&quot;silhouettes_optim&quot;</code>: Same as <code>&quot;silhouettes&quot;</code> but performs an optimized search via   Optim.jl. It&#39;s faster than <code>&quot;silhouettes&quot;</code>, with typically the same accuracy (the   search here is not guaranteed to always find the global maximum, though it typically   gets close).</li><li><code>&quot;knee&quot;</code>: chooses the the radius according to the knee (a.k.a. elbow,   highest-derivative method) and is quicker, though generally leading to much worse   clustering. It requires that <code>min_neighbors</code> &gt; 1.</li></ul></li><li><code>num_attempts_radius = 100</code>: number of radii that the <code>optimal_radius_method</code> will try out in its iterative procedure. Higher values increase the accuracy of clustering, though not necessarily much, while always reducing speed.</li><li><code>silhouette_statistic::Function = mean</code>: statistic (e.g. mean or minimum) of the silhouettes that is maximized in the &quot;optimal&quot; clustering. The original implementation in (<a href="../references/#Stender2021">Stender and Hoffmann, 2021</a>) used the <code>minimum</code> of the silhouettes, and typically performs less accurately than the <code>mean</code>.</li><li><code>max_used_features = 0</code>: if not <code>0</code>, it should be an <code>Int</code> denoting the max amount of features to be used when finding the optimal radius. Useful when clustering a very large number of features (e.g., high accuracy estimation of fractions of basins of attraction).</li></ul><p><strong>Description</strong></p><p>The DBSCAN clustering algorithm is used to automatically identify clusters of similar features. Each feature vector is a point in a feature space. Each cluster then basically groups points that are closely packed together. Closely packed means that the points have at least <code>min_neighbors</code> inside a ball of radius <code>optimal_radius</code> centered on them. This method typically works well if the radius is chosen well, which is not necessarily an easy task. Currently, three methods are implemented to automatically estimate an &quot;optimal&quot; radius.</p><p><strong>Estimating the optimal radius</strong></p><p>The default method is the <strong>silhouettes method</strong>, which includes keywords <code>silhouette</code> and <code>silhouette_optim</code>. Both of them search for the radius that optimizes the clustering, meaning the one that maximizes a statistic <code>silhouette_statistic</code> (e.g. mean value) of a quantifier for the quality of each cluster. This quantifier is the silhouette value of each identified cluster. A silhouette value measures how similar a point is to the cluster it currently belongs to, compared to the other clusters, and ranges from -1 (worst matching) to +1 (ideal matching). If only one cluster is found, the assigned silhouette is zero. So for each attempted radius in the search the clusters are computed, their silhouettes calculated, and the statistic of these silhouettes computed. The algorithm then finds the radius that leads to the maximum such statistic. For <code>optimal_radius_method = &quot;silhouettes&quot;</code>, the search is done linearly, from a minimum to a maximum candidate radius for <code>optimal_radius_method = &quot;silhouettes&quot;</code>; <code>optimal_radius_method = silhouettes_optim</code>, it is done via an optimized search performed by Optim.jl which is typically faster and with similar accuracy. A third alternative is the<code>&quot;elbow&quot;</code> method, which works by calculating the distance of each point to its k-nearest-neighbors (with <code>k=min_neighbors</code>) and finding the distance corresponding to the highest derivative in the curve of the distances, sorted in ascending order. This distance is chosen as the optimal radius. It is described in (<a href="../references/#Ester1996">Ester <em>et al.</em>, 1996</a>) and (<a href="../references/#Schubert2017">Schubert <em>et al.</em>, 2017</a>). It typically performs considerably worse than the <code>&quot;silhouette&quot;</code> methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/mapping/grouping/cluster_config.jl#L5-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.GroupViaHistogram" href="#Attractors.GroupViaHistogram"><code>Attractors.GroupViaHistogram</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GroupViaHistogram(binning::FixedRectangularBinning)</code></pre><p>Initialize a struct that contains instructions on how to group features in <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a>. <code>GroupViaHistogram</code> performs a histogram in feature space. Then, all features that are in the same histogram bin get the same label. The <code>binning</code> is an instance of <a href="@ref"><code>FixedRectangularBinning</code></a> from ComplexityMeasures.jl. (the reason to not allow <code>RectangularBinning</code> is because during continuation we need to ensure that bins remain identical).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/mapping/grouping/histogram_config.jl#L5-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.GroupViaNearestFeature" href="#Attractors.GroupViaNearestFeature"><code>Attractors.GroupViaNearestFeature</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GroupViaNearestFeature(templates; kwargs...)</code></pre><p>Initialize a struct that contains instructions on how to group features in <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a>. <code>GroupViaNearestFeature</code> accepts a <code>template</code>, which is a vector of features. Then, generated features from initial conditions in <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a> are labelled according to the feature in <code>templates</code> that is closest (the label is the index of the closest template).</p><p><code>templates</code> can be a vector or dictionary mapping keys to templates. Internally all templates are converted to <code>SVector</code> for performance. Hence, it is strongly recommended that both <code>templates</code> and the output of the <code>featurizer</code> function in <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a> return <code>SVector</code> types.</p><p><strong>Keyword arguments</strong></p><ul><li><code>metric = Euclidean()</code>: metric to be used to quantify distances in the feature space.</li><li><code>max_distance = Inf</code>: Maximum allowed distance between a feature and its nearest template for it to be assigned to that template. By default, <code>Inf</code> guarantees that a feature is assigned to its nearest template regardless of the distance. Features that exceed <code>max_distance</code> to their nearest template get labelled <code>-1</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/mapping/grouping/nearest_feature_config.jl#L4-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.GroupViaPairwiseComparison" href="#Attractors.GroupViaPairwiseComparison"><code>Attractors.GroupViaPairwiseComparison</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GroupViaPairwiseComparison(; threshold::Real, kwargs...)</code></pre><p>Initialize a struct that contains instructions on how to group features in <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a>. <code>GroupViaPairwiseComparison</code> groups features and identifies clusters by considering the pairwise distance between features. It can be used as an alternative to the clustering method in <code>GroupViaClustering</code>, having the advantage that it is simpler, typically faster and uses less memory.</p><p><strong>Keyword arguments</strong></p><ul><li><code>threshold</code> (mandatory): A real number defining the maximum distance two features can be to be considered in the same cluster - above the threshold, features are different. This value simply needs to be large enough to differentiate clusters.</li><li><code>metric = Euclidean()</code>: A function <code>metric(a, b)</code> that returns the distance between two features <code>a</code> and <code>b</code>, outputs of <code>featurizer</code>. Any <code>Metric</code> from Distances.jl can be used here.</li><li><code>rescale_features = true</code>: if true, rescale each dimension of the extracted features separately into the range <code>[0,1]</code>. This typically leads to more accurate grouping.</li></ul><p><strong>Description</strong></p><p>This algorithm assumes that the features are well-separated into distinct clouds, with the maximum radius of the cloud controlled by <code>threshold</code>. Since the systems are deterministic, this is achievable with a good-enough <code>featurizer</code> function, by removing transients, and running the trajectories for sufficiently long. It then considers that features belong to the same attractor when their pairwise distance, computed using <code>metric</code>, is smaller than or equal to <code>threshold</code>, and that they belong to different attractors when the distance is bigger. Attractors correspond to each grouping of similar features. In this way, the key parameter <code>threshold</code> is basically the amount of variation permissible in the features belonging to the same attractor. If they are well-chosen, the value can be relatively small and does not need to be fine tuned.</p><p>The <code>threshold</code> should achieve a balance: one one hand, it should be large enough to account for variations in the features from the same attractor - if it&#39;s not large enough, the algorithm will find duplicate attractors. On the other hand, it should be small enough to not group together features from distinct attractors. This requires some knowledge of how spread the features are. If it&#39;s too big, the algorithm will miss some attractors, as it groups 2+ distinct attractors together. Therefore, as a rule of thumb, one can repeat the procedure a few times, starting with a relatively large value and reducing it until no more attractors are found and no duplicates appear.</p><p>The method uses relatively little memory, as it only stores vectors whose size is on order of the number of attractors of the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/mapping/grouping/pairwise_comparison.jl#L3-L48">source</a></section></article><h3 id="Grouping-utils"><a class="docs-heading-anchor" href="#Grouping-utils">Grouping utils</a><a id="Grouping-utils-1"></a><a class="docs-heading-anchor-permalink" href="#Grouping-utils" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.extract_features" href="#Attractors.extract_features"><code>Attractors.extract_features</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_features(mapper, ics; N = 1000, show_progress = true)</code></pre><p>Return a vector of the features of each initial condition in <code>ics</code> (as in <a href="#Attractors.basins_fractions"><code>basins_fractions</code></a>), using the configuration of <code>mapper::AttractorsViaFeaturizing</code>. Keyword <code>N</code> is ignored if <code>ics isa StateSpaceSet</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/mapping/grouping/attractor_mapping_featurizing.jl#L140-L146">source</a></section></article><h2 id="Basins-of-attraction"><a class="docs-heading-anchor" href="#Basins-of-attraction">Basins of attraction</a><a id="Basins-of-attraction-1"></a><a class="docs-heading-anchor-permalink" href="#Basins-of-attraction" title="Permalink"></a></h2><p>Calculating basins of attraction, or their state space fractions, can be done with the functions:</p><ul><li><a href="#Attractors.basins_fractions"><code>basins_fractions</code></a></li><li><a href="#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>.</li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.basins_fractions" href="#Attractors.basins_fractions"><code>Attractors.basins_fractions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basins_fractions(
    mapper::AttractorMapper,
    ics::Union{StateSpaceSet, Function};
    kwargs...
)</code></pre><p>Approximate the state space fractions <code>fs</code> of the basins of attraction of a dynamical system by mapping initial conditions to attractors using <code>mapper</code> (which contains a reference to a <a href="@ref"><code>DynamicalSystem</code></a>). The fractions are simply the ratios of how many initial conditions ended up at each attractor.</p><p>Initial conditions to use are defined by <code>ics</code>. It can be:</p><ul><li>a <code>StateSpaceSet</code> of initial conditions, in which case all are used.</li><li>a 0-argument function <code>ics()</code> that spits out random initial conditions. Then <code>N</code> random initial conditions are chosen. See <a href="#StateSpaceSets.statespace_sampler"><code>statespace_sampler</code></a> to generate such functions.</li></ul><p><strong>Return</strong></p><p>The function will always return <code>fractions</code>, which is a dictionary whose keys are the labels given to each attractor (always integers enumerating the different attractors), and whose values are the respective basins fractions. The label <code>-1</code> is given to any initial condition where <code>mapper</code> could not match to an attractor (this depends on the <code>mapper</code> type).</p><p>If <code>ics</code> is a <code>StateSpaceSet</code> the function will also return <code>labels</code>, which is a <em>vector</em>, of equal length to <code>ics</code>, that contains the label each initial condition was mapped to.</p><p>See <a href="#Attractors.AttractorMapper"><code>AttractorMapper</code></a> for all possible <code>mapper</code> types, and use <a href="#Attractors.extract_attractors"><code>extract_attractors</code></a> (after calling <code>basins_fractions</code>) to extract the stored attractors from the <code>mapper</code>. See also <a href="#Attractors.convergence_and_basins_fractions"><code>convergence_and_basins_fractions</code></a>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>N = 1000</code>: Number of random initial conditions to generate in case <code>ics</code> is a function.</li><li><code>show_progress = true</code>: Display a progress bar of the process.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/mapping/attractor_mapping.jl#L74-L114">source</a></section><section><div><pre><code class="language-julia hljs">basins_fractions(basins::AbstractArray [,ids]) → fs::Dict</code></pre><p>Calculate the state space fraction of the basins of attraction encoded in <code>basins</code>. The elements of <code>basins</code> are integers, enumerating the attractor that the entry of <code>basins</code> converges to (i.e., like the output of <a href="#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>). Return a dictionary that maps attractor IDs to their relative fractions. Optionally you may give a vector of <code>ids</code> to calculate the fractions of only the chosen ids (by default <code>ids = unique(basins)</code>).</p><p>In (<a href="../references/#Menck2013">Menck <em>et al.</em>, 2013</a>) the authors use these fractions to quantify the stability of a basin of attraction, and specifically how it changes when a parameter is changed. For this, see <a href="#Attractors.global_continuation"><code>global_continuation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/basins/basins_utilities.jl#L44-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.basins_of_attraction" href="#Attractors.basins_of_attraction"><code>Attractors.basins_of_attraction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basins_of_attraction(mapper::AttractorsViaRecurrences; show_progress = true)</code></pre><p>This is a special method of <code>basins_of_attraction</code> that using recurrences does <em>exactly</em> what is described in the paper by Datseris &amp; Wagemakers (<a href="../references/#Datseris2022">Datseris and Wagemakers, 2022</a>). By enforcing that the internal grid of <code>mapper</code> is the same as the grid of initial conditions to map to attractors, the method can further utilize found exit and attraction basins, making the computation faster as the grid is processed more and more.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/mapping/recurrences/attractor_mapping_recurrences.jl#L196-L204">source</a></section><section><div><pre><code class="language-julia hljs">basins_of_attraction(mapper::AttractorMapper, grid::Tuple) → basins, attractors</code></pre><p>Compute the full basins of attraction as identified by the given <code>mapper</code>, which includes a reference to a <a href="@ref"><code>DynamicalSystem</code></a> and return them along with (perhaps approximated) found attractors.</p><p><code>grid</code> is a tuple of ranges defining the grid of initial conditions that partition the state space into boxes with size the step size of each range. For example, <code>grid = (xg, yg)</code> where <code>xg = yg = range(-5, 5; length = 100)</code>. The grid has to be the same dimensionality as the state space expected by the integrator/system used in <code>mapper</code>. E.g., a <a href="@ref"><code>ProjectedDynamicalSystem</code></a> could be used for lower dimensional projections, etc. A special case here is a <a href="@ref"><code>PoincareMap</code></a> with <code>plane</code> being <code>Tuple{Int, &lt;: Real}</code>. In this special scenario the grid can be one dimension smaller than the state space, in which case the partitioning happens directly on the hyperplane the Poincaré map operates on.</p><p><code>basins_of_attraction</code> function is a convenience 5-lines-of-code wrapper which uses the <code>labels</code> returned by <a href="#Attractors.basins_fractions"><code>basins_fractions</code></a> and simply assigns them to a full array corresponding to the state space partitioning indicated by <code>grid</code>.</p><p>See also <a href="#Attractors.convergence_and_basins_of_attraction"><code>convergence_and_basins_of_attraction</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/basins/basins_utilities.jl#L2-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceSets.statespace_sampler" href="#StateSpaceSets.statespace_sampler"><code>StateSpaceSets.statespace_sampler</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">statespace_sampler(region [, seed = 42]) → sampler, isinside</code></pre><p>A function that facilitates sampling points randomly and uniformly in a state space <code>region</code>. It generates two functions:</p><ul><li><code>sampler</code> is a 0-argument function that when called generates a random point inside a state space <code>region</code>. The point is always a <code>Vector</code> for type stability irrespectively of dimension. Generally, the generated point should be <em>copied</em> if it needs to be stored. (i.e., calling <code>sampler()</code> utilizes a shared vector) <code>sampler</code> is a thread-safe function.</li><li><code>isinside</code> is a 1-argument function that returns <code>true</code> if the given state space point is inside the <code>region</code>.</li></ul><p>The <code>region</code> can be an instance of any of the following types (input arguments if not specified are vectors of length <code>D</code>, with <code>D</code> the state space dimension):</p><ul><li><code>HSphere(radius::Real, center)</code>: points <em>inside</em> the hypersphere (boundary excluded). Convenience method <code>HSphere(radius::Real, D::Int)</code> makes the center a <code>D</code>-long vector of zeros.</li><li><code>HSphereSurface(radius, center)</code>: points on the hypersphere surface. Same convenience method as above is possible.</li><li><code>HRectangle(mins, maxs)</code>: points in [min, max) for the bounds along each dimension.</li></ul><p>The random number generator is always <code>Xoshiro</code> with the given <code>seed</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/v1.5.0/src/sampler.jl#L9-L37">source</a></section><section><div><pre><code class="language-julia hljs">statespace_sampler(grid::NTuple{N, AbstractRange} [, seed])</code></pre><p>If given a <code>grid</code> that is a tuple of <code>AbstractVector</code>s, the minimum and maximum of the vectors are used to make an <code>HRectangle</code> region.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/v1.5.0/src/sampler.jl#L139-L144">source</a></section></article><h2 id="Convergence-times"><a class="docs-heading-anchor" href="#Convergence-times">Convergence times</a><a id="Convergence-times-1"></a><a class="docs-heading-anchor-permalink" href="#Convergence-times" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.convergence_and_basins_fractions" href="#Attractors.convergence_and_basins_fractions"><code>Attractors.convergence_and_basins_fractions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convergence_and_basins_fractions(mapper::AttractorMapper, ics::StateSpaceSet)</code></pre><p>An extension of <a href="#Attractors.basins_fractions"><code>basins_fractions</code></a>. Return <code>fs, labels, convergence</code>. The first two are as in <code>basins_fractions</code>, and <code>convergence</code> is a vector containing the time each initial condition took to converge to its attractor. Only usable with mappers that support <code>id = mapper(u0)</code>.</p><p>See also <a href="#Attractors.convergence_time"><code>convergence_time</code></a>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>show_progress = true</code>: show progress bar.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/basins/basins_utilities.jl#L105-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.convergence_and_basins_of_attraction" href="#Attractors.convergence_and_basins_of_attraction"><code>Attractors.convergence_and_basins_of_attraction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convergence_and_basins_of_attraction(mapper::AttractorMapper, grid)</code></pre><p>An extension of <a href="#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>. Return <code>basins, attractors, convergence</code>, with <code>basins, attractors</code> as in <code>basins_of_attraction</code>, and <code>convergence</code> being an array with same shape as <code>basins</code>. It contains the time each initial condition took to converge to its attractor. It is useful to give to <a href="#Attractors.shaded_basins_heatmap"><code>shaded_basins_heatmap</code></a>.</p><p>See also <a href="#Attractors.convergence_time"><code>convergence_time</code></a>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>show_progress = true</code>: show progress bar.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/basins/basins_utilities.jl#L68-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.convergence_time" href="#Attractors.convergence_time"><code>Attractors.convergence_time</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convergence_time(mapper::AttractorMapper) → t</code></pre><p>Return the approximate time the <code>mapper</code> took to converge to an attractor. This function should be called just right after <code>mapper(u0)</code> was called with <code>u0</code> the initial condition of interest. Hence it is only valid with <code>AttractorMapper</code> subtypes that support this syntax.</p><p>Obtaining the convergence time is computationally free, so that <a href="#Attractors.convergence_and_basins_fractions"><code>convergence_and_basins_fractions</code></a> can always be used instead of <a href="#Attractors.basins_fractions"><code>basins_fractions</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/mapping/attractor_mapping.jl#L163-L174">source</a></section></article><h2 id="Final-state-sensitivity-/-fractal-boundaries"><a class="docs-heading-anchor" href="#Final-state-sensitivity-/-fractal-boundaries">Final state sensitivity / fractal boundaries</a><a id="Final-state-sensitivity-/-fractal-boundaries-1"></a><a class="docs-heading-anchor-permalink" href="#Final-state-sensitivity-/-fractal-boundaries" title="Permalink"></a></h2><p>Several functions are provided related with analyzing the fractality of the boundaries of the basins of attraction:</p><ul><li><a href="#Attractors.basins_fractal_dimension"><code>basins_fractal_dimension</code></a></li><li><a href="#Attractors.basin_entropy"><code>basin_entropy</code></a></li><li><a href="#Attractors.basins_fractal_test"><code>basins_fractal_test</code></a></li><li><a href="#Attractors.uncertainty_exponent"><code>uncertainty_exponent</code></a></li><li><a href="#Attractors.test_wada_merge"><code>test_wada_merge</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.basins_fractal_dimension" href="#Attractors.basins_fractal_dimension"><code>Attractors.basins_fractal_dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basins_fractal_dimension(basins; kwargs...) -&gt; V_ε, N_ε, d</code></pre><p>Estimate the fractal dimension <code>d</code> of the boundary between basins of attraction using a box-counting algorithm for the boxes that contain at least two different basin IDs.</p><p><strong>Keyword arguments</strong></p><ul><li><code>range_ε = 2:maximum(size(basins))÷20</code> is the range of sizes of the box to test (in pixels).</li></ul><p><strong>Description</strong></p><p>The output <code>N_ε</code> is a vector with the number of the balls of radius <code>ε</code> (in pixels) that contain at least two initial conditions that lead to different attractors. <code>V_ε</code> is a vector with the corresponding size of the balls. The output <code>d</code> is the estimation of the box-counting dimension of the boundary by fitting a line in the <code>log.(N_ε)</code> vs <code>log.(1/V_ε)</code> curve. However it is recommended to analyze the curve directly for more accuracy.</p><p>It is the implementation of the popular algorithm of the estimation of the box-counting dimension. The algorithm search for a covering the boundary with <code>N_ε</code> boxes of size <code>ε</code> in pixels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/basins/fractality_of_basins.jl#L162-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.basin_entropy" href="#Attractors.basin_entropy"><code>Attractors.basin_entropy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basin_entropy(basins::Array, ε = 20) -&gt; Sb, Sbb</code></pre><p>Return the basin entropy (<a href="../references/#Daza2016">Daza <em>et al.</em>, 2016</a>) <code>Sb</code> and basin boundary entropy <code>Sbb</code> of the given <code>basins</code> of attraction by considering <code>ε</code>-sized boxes along each dimension.</p><p><strong>Description</strong></p><p>First, the n-dimensional input <code>basins</code> is divided regularly into n-dimensional boxes of side <code>ε</code>. If <code>ε</code> is an integer, the same size is used for all dimensions, otherwise <code>ε</code> can be a tuple with the same size as the dimensions of <code>basins</code>. Assuming that there are <span>$N$</span> <code>ε</code>-boxes that cover the <code>basins</code>, the basin entropy is estimated as (<a href="../references/#Daza2016">Daza <em>et al.</em>, 2016</a>)</p><p class="math-container">\[S_b = \tfrac{1}{N}\sum_{i=1}^{N}\sum_{j=1}^{m_i}-p_{ij}\log(p_{ij})\]</p><p>where <span>$m$</span> is the number of unique IDs (integers of <code>basins</code>) in box <span>$i$</span> and <span>$p_{ij}$</span> is the relative frequency (probability) to obtain ID <span>$j$</span> in the <span>$i$</span> box (simply the count of IDs <span>$j$</span> divided by the total in the box).</p><p><code>Sbb</code> is the boundary basin entropy. This follows the same definition as <span>$S_b$</span>, but now averaged over only only boxes that contains at least two different basins, that is, for the boxes on the boundaries.</p><p>The basin entropy is a measure of the uncertainty on the initial conditions of the basins. It is maximum at the value <code>log(n_att)</code> being <code>n_att</code> the number of unique IDs in <code>basins</code>. In this case the boundary is intermingled: for a given initial condition we can find another initial condition that lead to another basin arbitrarily close. It provides also a simple criterion for fractality: if the boundary basin entropy <code>Sbb</code> is above <code>log(2)</code> then we have a fractal boundary. It doesn&#39;t mean that basins with values below cannot have a fractal boundary, for a more precise test see <a href="#Attractors.basins_fractal_test"><code>basins_fractal_test</code></a>. An important feature of the basin entropy is that it allows comparisons between different basins using the same box size <code>ε</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/basins/fractality_of_basins.jl#L3-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.basins_fractal_test" href="#Attractors.basins_fractal_test"><code>Attractors.basins_fractal_test</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basins_fractal_test(basins; ε = 20, Ntotal = 1000) -&gt; test_res, Sbb</code></pre><p>Perform an automated test to decide if the boundary of the basins has fractal structures based on the method of Puy et al. (<a href="../references/#Puy2021">Puy <em>et al.</em>, 2021</a>). Return <code>test_res</code> (<code>:fractal</code> or <code>:smooth</code>) and the mean basin boundary entropy.</p><p><strong>Keyword arguments</strong></p><ul><li><code>ε = 20</code>: size of the box to compute the basin boundary entropy.</li><li><code>Ntotal = 1000</code>: number of balls to test in the boundary for the computation of <code>Sbb</code></li></ul><p><strong>Description</strong></p><p>The test &quot;looks&quot; at the basins with a magnifier of size <code>ε</code> at random. If what we see in the magnifier looks like a smooth boundary (onn average) we decide that the boundary is smooth. If it is not smooth we can say that at the scale <code>ε</code> we have structures, i.e., it is fractal.</p><p>In practice the algorithm computes the boundary basin entropy <code>Sbb</code> <a href="#Attractors.basin_entropy"><code>basin_entropy</code></a> for <code>Ntotal</code> random boxes of radius <code>ε</code>. If the computed value is equal to theoretical value of a smooth boundary (taking into account statistical errors and biases) then we decide that we have a smooth boundary. Notice that the response <code>test_res</code> may depend on the chosen ball radius <code>ε</code>. For larger size, we may observe structures for smooth boundary and we obtain a <em>different</em> answer.</p><p>The output <code>test_res</code> is a symbol describing the nature of the basin and the output <code>Sbb</code> is the estimated value of the boundary basin entropy with the sampling method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/basins/fractality_of_basins.jl#L74-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.uncertainty_exponent" href="#Attractors.uncertainty_exponent"><code>Attractors.uncertainty_exponent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">uncertainty_exponent(basins; kwargs...) -&gt; ε, N_ε, α</code></pre><p>Estimate the uncertainty exponent(<a href="../references/#Grebogi1983">Grebogi <em>et al.</em>, 1983</a>) of the basins of attraction. This exponent is related to the final state sensitivity of the trajectories in the phase space. An exponent close to <code>1</code> means basins with smooth boundaries whereas an exponent close to <code>0</code> represent completely fractalized basins, also called riddled basins.</p><p>The output <code>N_ε</code> is a vector with the number of the balls of radius <code>ε</code> (in pixels) that contain at least two initial conditions that lead to different attractors. The output <code>α</code> is the estimation of the uncertainty exponent using the box-counting dimension of the boundary by fitting a line in the <code>log.(N_ε)</code> vs <code>log.(1/ε)</code> curve. However it is recommended to analyze the curve directly for more accuracy.</p><p><strong>Keyword arguments</strong></p><ul><li><code>range_ε = 2:maximum(size(basins))÷20</code> is the range of sizes of the ball to test (in pixels).</li></ul><p><strong>Description</strong></p><p>A phase space with a fractal boundary may cause a uncertainty on the final state of the dynamical system for a given initial condition. A measure of this final state sensitivity is the uncertainty exponent. The algorithm probes the basin of attraction with balls of size <code>ε</code> at random. If there are a least two initial conditions that lead to different attractors, a ball is tagged &quot;uncertain&quot;. <code>f_ε</code> is the fraction of &quot;uncertain balls&quot; to the total number of tries in the basin. In analogy to the fractal dimension, there is a scaling law between, <code>f_ε ~ ε^α</code>. The number that characterizes this scaling is called the uncertainty exponent <code>α</code>.</p><p>Notice that the uncertainty exponent and the box counting dimension of the boundary are related. We have <code>Δ₀ = D - α</code> where <code>Δ₀</code> is the box counting dimension computed with <a href="#Attractors.basins_fractal_dimension"><code>basins_fractal_dimension</code></a> and <code>D</code> is the dimension of the phase space. The algorithm first estimates the box counting dimension of the boundary and returns the uncertainty exponent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/basins/fractality_of_basins.jl#L223-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.test_wada_merge" href="#Attractors.test_wada_merge"><code>Attractors.test_wada_merge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">test_wada_merge(basins, r) -&gt; p</code></pre><p>Test if the 2D array <code>basins</code> has the <a href="https://en.wikipedia.org/wiki/Lakes_of_Wada">Wada property</a> using the merging technique of (<a href="../references/#Daza2018">Daza <em>et al.</em>, 2018</a>).</p><p><strong>Description</strong></p><p>The technique consists in computing the generalized basins of each attractor. These new basins are formed with on of the basins and the union of the other basins. A new boundary is defined by these two objects. The algorithm then computes the distance between each boundaries of these basins pairwise. If all the boundaries are within some distance <code>r</code>, there is a unique boundary separating the basins and we have the wada property. The algorithm returns the maximum proportion of pixels of a boundary with distance strictly greater than <code>r</code> from another boundary.</p><p>If <code>p == 0</code>,  we have the Wada property for this value of <code>r</code>. If <code>p &gt; 0</code>, the criteria to decide if the basins are Wada is left to the user. Numerical inaccuracies may be responsible for a small percentage of points with distance larger than <code>r</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/basins/wada_test.jl#L5-L29">source</a></section></article><h2 id="Edge-tracking-and-edge-states"><a class="docs-heading-anchor" href="#Edge-tracking-and-edge-states">Edge tracking and edge states</a><a id="Edge-tracking-and-edge-states-1"></a><a class="docs-heading-anchor-permalink" href="#Edge-tracking-and-edge-states" title="Permalink"></a></h2><p>The edge tracking algorithm allows to locate and construct so-called edge states (also referred to as <em>Melancholia states</em>) embedded in the basin boundary separating different basins of attraction. These could be saddle points, unstable periodic orbits or chaotic saddles. The general idea is that these sets can be found because they act as attractors when restricting to the basin boundary.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.edgetracking" href="#Attractors.edgetracking"><code>Attractors.edgetracking</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">edgetracking(ds::DynamicalSystem, attractors::Dict; kwargs...)</code></pre><p>Track along a basin boundary in a dynamical system <code>ds</code> with two or more attractors in order to find an <em>edge state</em>. Results are returned in the form of <a href="#Attractors.EdgeTrackingResults"><code>EdgeTrackingResults</code></a>, which contains the pseudo-trajectory <code>edge</code> representing the track on the basin boundary, along with additional output (see below).</p><p>The system&#39;s <code>attractors</code> are specified as a <code>Dict</code> of <code>StateSpaceSet</code>s, as in <a href="#Attractors.AttractorsViaProximity"><code>AttractorsViaProximity</code></a> or the output of <a href="#Attractors.extract_attractors"><code>extract_attractors</code></a>. By default, the algorithm is initialized from the first and second attractor in <code>attractors</code>. Alternatively, the initial states can be set via keyword arguments <code>u1</code>, <code>u2</code> (see below). Note that the two initial states must belong to different basins of attraction.</p><p><strong>Keyword arguments</strong></p><ul><li><code>bisect_thresh = 1e-7</code>: distance threshold for bisection</li><li><code>diverge_thresh = 1e-6</code>: distance threshold for parallel integration</li><li><code>u1</code>: first initial state (defaults to first point in first entry of <code>attractors</code>)</li><li><code>u2</code>: second initial state (defaults to first point in second entry of <code>attractors</code>)</li><li><code>maxiter = 100</code>: maximum number of iterations before the algorithm stops</li><li><code>abstol = 0.0</code>: distance threshold for convergence of the updated edge state</li><li><code>T_transient = 0.0</code>: transient time before the algorithm starts saving the edge track</li><li><code>tmax = Inf</code>: maximum integration time of parallel trajectories until re-bisection </li><li><code>Δt = 0.01</code>: time step passed to <a href="@ref"><code>step!</code></a> when evolving the two trajectories</li><li><code>ϵ_mapper = nothing</code>: <code>ϵ</code> parameter in <a href="#Attractors.AttractorsViaProximity"><code>AttractorsViaProximity</code></a></li><li><code>show_progress = true</code>: if true, shows progress bar and information while running</li><li><code>verbose = true</code>: if false, silences print output and warnings while running</li><li><code>kwargs...</code>: additional keyword arguments to be passed to <a href="#Attractors.AttractorsViaProximity"><code>AttractorsViaProximity</code></a></li></ul><p><strong>Description</strong></p><p>The edge tracking algorithm is a numerical method to find an <em>edge state</em> or (possibly chaotic) saddle on the boundary between two basins of attraction. Introduced by (<a href="../references/#Battelino1988">Battelino <em>et al.</em>, 1988</a>) and further described by (<a href="../references/#Skufca2006">Skufca <em>et al.</em>, 2006</a>), the algorithm has been applied to, e.g., the laminar-turbulent boundary in plane Couette flow (<a href="../references/#Schneider2008">Schneider <em>et al.</em>, 2008</a>), Wada basins (<a href="../references/#Wagemakers2020">Wagemakers <em>et al.</em>, 2020</a>), as well as Melancholia states in conceptual (<a href="../references/#Mehling2023">Mehling <em>et al.</em>, 2023</a>) and intermediate-complexity (<a href="../references/#Lucarini2017">Lucarini and Bódai, 2017</a>)  climate models.  Relying only on forward integration of the system, it works even in high-dimensional systems with complicated fractal basin boundary structures.</p><p>The algorithm consists of two main steps: bisection and tracking. First, it iteratively  bisects along a straight line in state space between the intial states <code>u1</code> and <code>u2</code> to find the separating basin boundary. The bisection stops when the two updated states are less than <code>bisect_thresh</code> (Euclidean distance in state space) apart from each other. Next, a <code>ParallelDynamicalSystem</code> is initialized from these two updated states and integrated forward until the two trajectories diverge from each other by more than <code>diverge_thresh</code> (Euclidean distance). The two final states of the parallel integration are then used as new states <code>u1</code> and <code>u2</code> for a new bisection, and  so on, until a stopping criterion is fulfilled. </p><p>Two stopping criteria are implemented via the keyword arguments <code>maxiter</code> and <code>abstol</code>. Either the algorithm stops when the number of iterations reaches <code>maxiter</code>, or when the state space position of the updated edge point changes by less than <code>abstol</code> (in Euclidean distance) compared to the previous iteration. Convergence below <code>abstol</code> happens after sufficient iterations if the edge state is a saddle point. However, the edge state may also be an unstable limit cycle or a chaotic saddle. In these cases, the algorithm will never actually converge to a point but (after a transient period) continue populating the set constituting the edge state by tracking along it.</p><p>A central idea behind this algorithm is that basin boundaries are typically the stable manifolds of unstable sets, namely edge states or saddles. The flow along the basin boundary  will thus lead to these sets, and the iterative bisection neutralizes the unstable direction of the flow away from the basin boundary. If the system possesses multiple edge  states, the algorithm will find one of them depending on where the initial bisection locates the boundary.</p><p><strong>Output</strong></p><p>Returns a data type <a href="#Attractors.EdgeTrackingResults"><code>EdgeTrackingResults</code></a> containing the results.</p><p>Sometimes, the AttractorMapper used in the algorithm may erroneously identify both states <code>u1</code> and <code>u2</code> with the same basin of attraction due to being very close to the basin boundary. If this happens, a warning is raised and <code>EdgeTrackingResults.success = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/boundaries/edgetracking.jl#L28-L101">source</a></section><section><div><pre><code class="language-julia hljs">edgetracking(pds::ParallelDynamicalSystem, mapper::AttractorMapper; kwargs...)</code></pre><p>Low-level function for running the edge tracking algorithm, see <a href="#Attractors.edgetracking"><code>edgetracking</code></a> for a description, keyword arguments and output type.</p><p><code>pds</code> is a <code>ParallelDynamicalSystem</code> with two states. The <code>mapper</code> must be an <code>AttractorMapper</code> of subtype <code>AttractorsViaProximity</code> or <code>AttractorsViaRecurrences</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/boundaries/edgetracking.jl#L125-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.EdgeTrackingResults" href="#Attractors.EdgeTrackingResults"><code>Attractors.EdgeTrackingResults</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EdgeTrackingResults(edge, track1, track2, time, bisect_idx)</code></pre><p>Data type that stores output of the <a href="#Attractors.edgetracking"><code>edgetracking</code></a> algorithm.</p><p><strong>Fields</strong></p><ul><li><code>edge::StateSpaceSet</code>: the pseudo-trajectory representing the tracked edge segment (given by the average in state space between <code>track1</code> and <code>track2</code>)</li><li><code>track1::StateSpaceSet</code>: the pseudo-trajectory tracking the edge within basin 1</li><li><code>track2::StateSpaceSet</code>: the pseudo-trajectory tracking the edge within basin 2</li><li><code>time::Vector</code>: time points of the above <code>StateSpaceSet</code>s</li><li><code>bisect_idx::Vector</code>: indices of <code>time</code> at which a re-bisection occurred</li><li><code>success::Bool</code>: indicates whether the edge tracking has been successful or not</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/boundaries/edgetracking.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.bisect_to_edge" href="#Attractors.bisect_to_edge"><code>Attractors.bisect_to_edge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bisect_to_edge(pds::ParallelDynamicalSystem, mapper::AttractorMapper; kwargs...) -&gt; u1, u2</code></pre><p>Finds the basin boundary between two states <code>u1, u2 = current_states(pds)</code> by bisecting along a straight line in phase space. The states <code>u1</code> and <code>u2</code> must belong to different basins.</p><p>Returns a triple <code>u1, u2, success</code>, where <code>u1, u2</code> are two new states located on either side of the basin boundary that lie less than <code>bisect_thresh</code> (Euclidean distance in state space) apart from each other, and <code>success</code> is a Bool indicating whether the bisection was successful (it may fail if the <code>mapper</code> maps both states to the same basin of attraction, in which case a warning is raised).</p><p><strong>Keyword arguments</strong></p><ul><li><code>bisect_thresh = 1e-7</code>: The maximum (Euclidean) distance between the two returned states.</li></ul><p><strong>Description</strong></p><p><code>pds</code> is a <code>ParallelDynamicalSystem</code> with two states. The <code>mapper</code> must be an <code>AttractorMapper</code> of subtype <code>AttractorsViaProximity</code> or <code>AttractorsViaRecurrences</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>If the straight line between <code>u1</code> and <code>u2</code> intersects the basin boundary multiple times, the method will find one of these intersection points. If more than two attractors exist, one of the two returned states may belong to a different basin than the initial conditions <code>u1</code> and <code>u2</code>. A warning is raised if the bisection involves a third basin.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/boundaries/edgetracking.jl#L222-L246">source</a></section></article><h2 id="Tipping-points"><a class="docs-heading-anchor" href="#Tipping-points">Tipping points</a><a id="Tipping-points-1"></a><a class="docs-heading-anchor-permalink" href="#Tipping-points" title="Permalink"></a></h2><p>This page discusses functionality related with tipping points in dynamical systems with known rule. If instead you are interested in identifying tipping points in measured timeseries, have a look at <a href="https://github.com/JuliaDynamics/TransitionIndicators.jl">TransitionIndicators.jl</a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.tipping_probabilities" href="#Attractors.tipping_probabilities"><code>Attractors.tipping_probabilities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tipping_probabilities(basins_before, basins_after) → P</code></pre><p>Return the tipping probabilities of the computed basins before and after a change in the system parameters (or time forcing), according to the definition of (<a href="../references/#Kaszas2019">Kaszás <em>et al.</em>, 2019</a>).</p><p>The input <code>basins</code> are integer-valued arrays, where the integers enumerate the attractor, e.g. the output of <a href="#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>.</p><p><strong>Description</strong></p><p>Let <span>$\mathcal{B}_i(p)$</span> denote the basin of attraction of attractor <span>$A_i$</span> at parameter(s) <span>$p$</span>. Kaszás et al (<a href="../references/#Kaszas2019">Kaszás <em>et al.</em>, 2019</a>) define the tipping probability from <span>$A_i$</span> to <span>$A_j$</span>, given a parameter change in the system of <span>$p_- \to p_+$</span>, as</p><p class="math-container">\[P(A_i \to A_j | p_- \to p_+) =
\frac{|\mathcal{B}_j(p_+) \cap \mathcal{B}_i(p_-)|}{|\mathcal{B}_i(p_-)|}\]</p><p>where <span>$|\cdot|$</span> is simply the volume of the enclosed set. The value of <span>$P(A_i \to A_j | p_- \to p_+)$</span> is <code>P[i, j]</code>. The equation describes something quite simple: what is the overlap of the basin of attraction of <span>$A_i$</span> at <span>$p_-$</span> with that of the attractor <span>$A_j$</span> at <span>$p_+$</span>. If <code>basins_before, basins_after</code> contain values of <code>-1</code>, corresponding to trajectories that diverge, this is considered as the last attractor of the system in <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/tipping/tipping_probabilities.jl#L3-L28">source</a></section></article><h2 id="Minimal-Fatal-Shock"><a class="docs-heading-anchor" href="#Minimal-Fatal-Shock">Minimal Fatal Shock</a><a id="Minimal-Fatal-Shock-1"></a><a class="docs-heading-anchor-permalink" href="#Minimal-Fatal-Shock" title="Permalink"></a></h2><p>The algorithm to find minimal perturbation for arbitrary initial condition <code>u0</code> which will kick the system into different from the current basin.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.minimal_fatal_shock" href="#Attractors.minimal_fatal_shock"><code>Attractors.minimal_fatal_shock</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">minimal_fatal_shock(mapper::AttractorMapper, u0, search_area, algorithm; kw...)</code></pre><p>Return the <em>minimal fatal shock</em> <code>mfs</code> (also known as <em>excitability threshold</em>) for the initial point <code>u0</code> according to the specified <code>algorithm</code> given a <code>mapper</code> that satisfies the <code>id = mapper(u0)</code> interface (see <a href="#Attractors.AttractorMapper"><code>AttractorMapper</code></a> if you are not sure which mappers do that). The <code>mapper</code> contains a reference to a <a href="@ref"><code>DynamicalSystem</code></a>. The options for <code>algorithm</code> are: <a href="#Attractors.MFSBruteForce"><code>MFSBruteForce</code></a> or <a href="#Attractors.MFSBlackBoxOptim"><code>MFSBlackBoxOptim</code></a>. For high dimensional systems <a href="#Attractors.MFSBlackBoxOptim"><code>MFSBlackBoxOptim</code></a> is likely more accurate.</p><p>The <code>search_area</code> dictates the state space range for the search of the <code>mfs</code>. It can be a 2-tuple of (min, max) values, in which case the same values are used for each dimension of the system in <code>mapper</code>. Otherwise, it can be a vector of 2-tuples, each for each dimension of the system. The search area is defined w.r.t. to <code>u0</code> (i.e., it is the search area for perturbations of <code>u0</code>).</p><p>An alias to <code>minimal_fata_shock</code> is <code>excitability_threshold</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>metric = LinearAlgebra.norm</code>: a metric function that gives the norm of a perturbation vector. This keyword is ignored for the <a href="#Attractors.MFSBruteForce"><code>MFSBruteForce</code></a> algorithm.</li><li><code>target_id = nothing</code>: when not <code>nothing</code>, it should be an integer or a vector of integers corresponding to target attractor label(s). Then, the MFS is estimated based only on perturbations that lead to the target attractor(s).</li></ul><p><strong>Description</strong></p><p>The minimal fatal shock is defined as the smallest-norm perturbation of the initial point <code>u0</code> that will lead it a different basin of attraction. It is inspired by the paper &quot;Minimal fatal shocks in multistable complex networks&quot; (<a href="../references/#Halekotte2020">Halekotte and Feudel, 2020</a>), however the implementation here is generic: it works for <em>any</em> dynamical system.</p><p>The <em>excitability threshold</em> is a concept nearly identical, however, instead of looking for a perturbation that simply brings us out of the basin, we look for the smallest perturbation that brings us into specified basin(s). This is enabled via the keyword <code>target_id</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/tipping/mfs.jl#L7-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.MFSBlackBoxOptim" href="#Attractors.MFSBlackBoxOptim"><code>Attractors.MFSBlackBoxOptim</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MFSBlackBoxOptim(; kwargs...)</code></pre><p>The black box derivative-free optimization algorithm used in <a href="#Attractors.minimal_fatal_shock"><code>minimal_fatal_shock</code></a>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>guess = nothing</code>: a initial guess for the minimal fatal shock given to the optimization algorithm. If not <code>nothing</code>, <code>random_algo</code> below is ignored.</li><li><code>max_steps = 10000</code>: maximum number of steps for the optimization algorithm.</li><li><code>penalty = 1000.0</code>: penalty value for the objective function for perturbations that do not lead to a different basin of attraction. This value is added to the norm of the perturbation and its value should be much larger than the typical sizes of the basins of attraction.</li><li><code>print_info</code>: boolean value, if true, the optimization algorithm will print information on the evaluation steps of objective function, <code>default = false</code>.</li><li><code>random_algo = MFSBruteForce(100, 100, 0.99)</code>: an instance of <a href="#Attractors.MFSBruteForce"><code>MFSBruteForce</code></a> that can be used to provide an initial guess.</li><li><code>bbkwargs = NamedTuple()</code>: additional keyword arguments propagated to <code>BlackBoxOptim.bboptimize</code> for selecting solver, accuracy, and more.</li></ul><p><strong>Description</strong></p><p>The algorithm uses BlackBoxOptim.jl and a penalized objective function to minimize. y function used as a constraint function. So, if we hit another basin during the search we encourage the algorithm otherwise we punish it with some penalty. The function to minimize is (besides some details):</p><pre><code class="language-julia hljs">function mfs_objective(perturbation, u0, mapper, penalty)
    dist = norm(perturbation)
    if mapper(u0 + perturbation) == mapper(u0)
        # penalize if we stay in the same basin:
        return dist + penalty
    else
        return dist
    end
end</code></pre><p>Using an initial guess can be beneficial to both performance and accuracy, which is why the output of a crude <a href="#Attractors.MFSBruteForce"><code>MFSBruteForce</code></a> is used to provide a guess. This can be disabled by either passing a <code>guess</code> vector explicitly or by giving <code>nothing</code> as <code>random_algo</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/tipping/mfs.jl#L194-L236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.MFSBruteForce" href="#Attractors.MFSBruteForce"><code>Attractors.MFSBruteForce</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MFSBruteForce(; kwargs...)</code></pre><p>The brute force randomized search algorithm used in <a href="#Attractors.minimal_fatal_shock"><code>minimal_fatal_shock</code></a>.</p><p>It consists of two steps: random initialization and sphere radius reduction. On the first step, the algorithm generates random perturbations within the search area and records the perturbation that leads to a different basin but with the smallest magnitude. With this obtained perturbation it proceeds to the second step. On the second step, the algorithm generates random perturbations on the surface of the hypersphere with radius equal to the norm of the perturbation found in the first step. It reduces the radius of the hypersphere and continues searching for the better result with a smaller radius. Each time a better result is found, the radius is reduced further.</p><p>The algorithm records the perturbation with smallest radius that leads to a different basin.</p><p><strong>Keyword arguments</strong></p><ul><li><code>initial_iterations = 10000</code>: number of random perturbations to try in the first step of the algorithm.</li><li><code>sphere_iterations = 10000</code>: number of steps while initializing random points on hypersphere and decreasing its radius.</li><li><code>sphere_decrease_factor = 0.999</code> factor by which the radius of the hypersphere is decreased (at each step the radius is multiplied by this number). Number closer to 1 means more refined accuracy</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/tipping/mfs.jl#L76-L103">source</a></section></article><h2 id="Global-continuation"><a class="docs-heading-anchor" href="#Global-continuation">Global continuation</a><a id="Global-continuation-1"></a><a class="docs-heading-anchor-permalink" href="#Global-continuation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.global_continuation" href="#Attractors.global_continuation"><code>Attractors.global_continuation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">global_continuation(gca::GlobalContinuationAlgorithm, prange, pidx, ics; kwargs...)
global_continuation(gca::GlobalContinuationAlgorithm, pcurve, ics; kwargs...)</code></pre><p>Find and continue attractors (or representations of attractors) and the fractions of their basins of attraction across a parameter range. <code>global_continuation</code> is the central function of the framework for global stability analysis illustrated in (<a href="../references/#Datseris2023">Datseris <em>et al.</em>, 2023</a>).</p><p>The global continuation algorithm typically references an <a href="#Attractors.AttractorMapper"><code>AttractorMapper</code></a> which is used to find the attractors and basins of a dynamical system. Additional arguments that control how to continue/track/match attractors across a parameter range are given when creating <code>gca</code>.</p><p>The basin fractions and the attractors (or some representation of them) are continued across the parameter range <code>prange</code>, for the parameter of the system with index <code>pidx</code> (any index valid in <code>DynamicalSystems.set_parameter!</code> can be used). In contrast to traditional continuation (see online Tutorial for a comparison), global continuation can be performed over arbitrary user-defined curves in parameter space. The second call signature with <code>pcurve</code> allows for this possibility. In this case <code>pcurve</code> is a vector of iterables, where each itereable maps parameter indices to parameter values. These iterables can be dictionaries, named tuples, <code>Vector{Pair}</code>, etc., and the sequence of the iterables defines a curve in parameter space. In fact, the version with <code>prange, pidx</code> simply defines <code>pcurve = [[pidx =&gt; p] for p in prange]</code> and calls the second method.</p><p><code>ics</code> are the initial conditions to use when globally sampling the state space. Like in <a href="#Attractors.basins_fractions"><code>basins_fractions</code></a> it can be either a set vector of initial conditions, or a 0-argument function that generates random initial conditions.</p><p>Possible subtypes of <code>GlobalContinuationAlgorithm</code> are:</p><ul><li><a href="#Attractors.AttractorSeedContinueMatch"><code>AttractorSeedContinueMatch</code></a></li><li><a href="#Attractors.FeaturizeGroupAcrossParameter"><code>FeaturizeGroupAcrossParameter</code></a></li></ul><p><strong>Return</strong></p><ol><li><code>fractions_cont::Vector{Dict{Int, Float64}}</code>. The fractions of basins of attraction. <code>fractions_cont[i]</code> is a dictionary mapping attractor IDs to their basin fraction at the <code>i</code>-th parameter combination.</li><li><code>attractors_cont::Vector{Dict{Int, &lt;:Any}}</code>. The continued attractors. <code>attractors_cont[i]</code> is a dictionary mapping attractor ID to the attractor set at the <code>i</code>-th parameter combination.</li></ol><p><strong>Keyword arguments</strong></p><ul><li><code>show_progress = true</code>: display a progress bar of the computation.</li><li><code>samples_per_parameter = 100</code>: amount of initial conditions sampled at each parameter combination from <code>ics</code> if <code>ics</code> is a function instead of set initial conditions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/continuation/basins_fractions_continuation_api.jl#L15-L64">source</a></section></article><h3 id="General-seeding-based-continuation"><a class="docs-heading-anchor" href="#General-seeding-based-continuation">General seeding-based continuation</a><a id="General-seeding-based-continuation-1"></a><a class="docs-heading-anchor-permalink" href="#General-seeding-based-continuation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.AttractorSeedContinueMatch" href="#Attractors.AttractorSeedContinueMatch"><code>Attractors.AttractorSeedContinueMatch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AttractorSeedContinueMatch(mapper, matcher = MatchBySSSetDistance(); seeding)</code></pre><p>A global continuation method for <a href="#Attractors.global_continuation"><code>global_continuation</code></a>. <code>mapper</code> is any subtype of <a href="#Attractors.AttractorMapper"><code>AttractorMapper</code></a> which implements <a href="#Attractors.extract_attractors"><code>extract_attractors</code></a>, i.e., it finds the actual attractors. <code>matcher</code> is a configuration of how to match attractor IDs, see <a href="#Attractors.IDMatcher"><code>IDMatcher</code></a> for more options.</p><p><strong>Description</strong></p><p>This is a general/composable global continuation method based on a 4-step process:</p><ol><li>Seed initial conditions from previously found attractors</li><li>Propagate those forwards to &quot;continue&quot; previous attractors</li><li>Estimate basin fractions and potentially find new attractors</li><li>Match attractors</li></ol><p><strong>Step 0 - Finding initial attractors</strong></p><p>At the first parameter slice of the global continuation process, attractors and their fractions are found using the given <code>mapper</code> and <a href="#Attractors.basins_fractions"><code>basins_fractions</code></a>. See the <code>mapper</code> documentation and <a href="#Attractors.AttractorMapper"><code>AttractorMapper</code></a> for details on how this works. Then, from the second parameter onwards the continuation occurs.</p><p><strong>Step 1 - Seeding initial conditions</strong></p><p>Initial conditions can be seeded from previously found attractors. This is controlled by the <code>seeding</code> keyword, which must be a function that given a <code>StateSpaceSet</code> (an attractor), it returns an iterator of initial conditions. By default the first point of an attractor is provided as the only seed.</p><p>Seeding can be turned off by providing the dummy function <code>seeding = A -&gt; []</code>, i.e., it always returns an empty iterator and hence no seeds and we skip to step 2.</p><p><strong>Step 2 - Continuing the seeds</strong></p><p>The dynamical system referenced by the <code>mapper</code> is now set to the new parameter value. The seeds are run through the <code>mapper</code> to converge to attractors at the new parameter value. Seeding initial conditions close to previous attractors increases the probability that if an attractor continues to exist in the new parameter, it is found. Additionally, for some <code>mappers</code> this seeding process improves the accuracy as well as performance of finding attractors, see e.g. discussion in (<a href="../references/#Datseris2023">Datseris <em>et al.</em>, 2023</a>).</p><p>This seeding works for any <code>mapper</code>, regardless of if they can map individual initial conditions with the <code>mapper(u0)</code> syntax! If this syntax isn&#39;t supported, steps 2 and 3 are done together.</p><p><strong>Step 3 - Estimate basins fractions</strong></p><p>After the special seeded initial conditions are mapped to attractors, attractor basin fractions are computed by sampling additional initial conditions using the provided <code>ics</code> in <a href="#Attractors.global_continuation"><code>global_continuation</code></a>. I.e., exactly as in <a href="#Attractors.basins_fractions"><code>basins_fractions</code></a>. Naturally, during this step new attractors may be found, besides those found using the &quot;seeding from previous attractors&quot;.</p><p><strong>Step 4 - Matching</strong></p><p>Normally the ID an attractor gets assigned is somewhat a random integer. Therefore, to ensure a logical output of the global continuation process, attractors need to be &quot;matched&quot;. This means: attractor and fractions must have their <em>IDs changed</em>, so that attractors that are &quot;similar&quot; to those at a previous parameter get assigned the same ID.</p><p>What is &quot;similar enough&quot; is controlled by the <code>matcher</code> input. The default <code>matcher</code> <a href="#Attractors.MatchBySSSetDistance"><code>MatchBySSSetDistance</code></a> matches sets which have small distance in state space. The matching algorithm itself can be quite involved, so read the documentation of the <code>matcher</code> for how matching works.</p><p>A note on matching: the <a href="#Attractors.MatchBySSSetDistance"><code>MatchBySSSetDistance</code></a> can also be used after the continuation is completed, as it only requires as input the state space sets (attractors), without caring at which parameter each attractor exists at. If you don&#39;t like the final matching output, you may use a different instance of <a href="#Attractors.MatchBySSSetDistance"><code>MatchBySSSetDistance</code></a> and call <a href="#Attractors.match_sequentially!"><code>match_sequentially!</code></a> again on the output, without having to recompute the whole global continuation!</p><p><strong>Step 5 - Finish</strong></p><p>After matching the parameter is incremented. Steps 1-4 repeat until all parameter values are exhausted.</p><p><strong>Further note</strong></p><p>This global continuation method is a generalization of the &quot;RAFM&quot; continuation described in (<a href="../references/#Datseris2023">Datseris <em>et al.</em>, 2023</a>). This continuation method is still exported as <a href="#Attractors.RecurrencesFindAndMatch"><code>RecurrencesFindAndMatch</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/continuation/continuation_ascm_generic.jl#L5-L94">source</a></section></article><h3 id="Recurrences-continuation"><a class="docs-heading-anchor" href="#Recurrences-continuation">Recurrences continuation</a><a id="Recurrences-continuation-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrences-continuation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.RecurrencesFindAndMatch" href="#Attractors.RecurrencesFindAndMatch"><code>Attractors.RecurrencesFindAndMatch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">RecurrencesFindAndMatch &lt;: GlobalContinuationAlgorithm
RecurrencesFindAndMatch(mapper::AttractorsViaRecurrences; kwargs...)</code></pre><p>A method for <a href="#Attractors.global_continuation"><code>global_continuation</code></a> as in (<a href="../references/#Datseris2023">Datseris <em>et al.</em>, 2023</a>) that is based on the recurrences algorithm for finding attractors (<a href="#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a>) and then matching them according to their state space distance.</p><p><strong>Keyword arguments</strong></p><ul><li><code>distance = Centroid(), threshold = Inf</code>: passed to <a href="#Attractors.MatchBySSSetDistance"><code>MatchBySSSetDistance</code></a>.</li><li><code>seeds_from_attractor</code>: A function that takes as an input an attractor and returns an iterator of initial conditions to be seeded from the attractor for the next parameter slice. By default, we sample only the first stored point on the attractor.</li></ul><p><strong>Description</strong></p><p><code>RecurrencesFindAndMatch</code> is a wrapper type. It is has been generalized by <a href="#Attractors.AttractorSeedContinueMatch"><code>AttractorSeedContinueMatch</code></a>. It is still exported for backwards compatibility and to have a clear reference to the original algorithm developed in (<a href="../references/#Datseris2023">Datseris <em>et al.</em>, 2023</a>).</p><p>The source code of <code>RecurrencesFindAndMatch</code> is trival: it takes the given mapper, it initializes a <a href="#Attractors.MatchBySSSetDistance"><code>MatchBySSSetDistance</code></a>, and along with <code>seeds_from_attractor</code> it makes the <a href="#Attractors.AttractorSeedContinueMatch"><code>AttractorSeedContinueMatch</code></a> instance. This is the process described in (<a href="../references/#Datseris2023">Datseris <em>et al.</em>, 2023</a>), whereby attractors are found using the recurrences algorithm <a href="#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a> and they are then matched by their distance in state space <a href="#Attractors.MatchBySSSetDistance"><code>MatchBySSSetDistance</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/continuation/continuation_recurrences.jl#L3-L30">source</a></section></article><h3 id="Aggregating-attractors-and-fractions"><a class="docs-heading-anchor" href="#Aggregating-attractors-and-fractions">Aggregating attractors and fractions</a><a id="Aggregating-attractors-and-fractions-1"></a><a class="docs-heading-anchor-permalink" href="#Aggregating-attractors-and-fractions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.aggregate_attractor_fractions" href="#Attractors.aggregate_attractor_fractions"><code>Attractors.aggregate_attractor_fractions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">aggregate_attractor_fractions(
    fractions_cont, attractors_cont, featurizer, group_config [, info_extraction]
)</code></pre><p>Aggregate the already-estimated curves of fractions of basins of attraction of similar attractors using the same pipeline used by <a href="#Attractors.GroupingConfig"><code>GroupingConfig</code></a>. The most typical application of this function is to transform the output of a <a href="#Attractors.global_continuation"><code>global_continuation</code></a> with <a href="#Attractors.RecurrencesFindAndMatch"><code>RecurrencesFindAndMatch</code></a> so that similar attractors, even across parameter space, are grouped into one &quot;attractor&quot;. Thus, the fractions of their basins are aggregated.</p><p>You could also use this function to aggregate attractors and their fractions even in a single parameter configuration, i.e., using the output of <a href="#Attractors.basins_fractions"><code>basins_fractions</code></a>.</p><p>This function is useful in cases where you want the accuracy and performance of <a href="#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a>, but you also want the convenience of &quot;grouping&quot; similar attractrors like in <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a> for presentation or analysis purposes. For example, a high dimensional model of competition dynamics across multispecies may have extreme multistability. After finding this multistability however, one may care about aggregating all attractors into two groups: where a given species is extinct or not. This is the example highlighted in our documentation, in <a href="../examples/#Extinction-of-a-species-in-a-multistable-competition-model">Extinction of a species in a multistable competition model</a>.</p><p><strong>Input</strong></p><ol><li><code>fractions_cont</code>: a vector of dictionaries mapping labels to basin fractions.</li><li><code>attractors_cont</code>: a vector of dictionaries mapping labels to attractors. 1st and 2nd argument are exactly like the return values of <a href="#Attractors.global_continuation"><code>global_continuation</code></a> with <a href="#Attractors.RecurrencesFindAndMatch"><code>RecurrencesFindAndMatch</code></a> (or, they can be the return of <a href="#Attractors.basins_fractions"><code>basins_fractions</code></a>).</li><li><code>featurizer</code>: a 1-argument function to map an attractor into an appropriate feature to be grouped later. Features expected by <a href="#Attractors.GroupingConfig"><code>GroupingConfig</code></a> are <code>SVector</code>.</li><li><code>group_config</code>: a subtype of <a href="#Attractors.GroupingConfig"><code>GroupingConfig</code></a>.</li><li><code>info_extraction</code>: a function accepting a vector of features and returning a description of the features. I.e., exactly as in <a href="#Attractors.FeaturizeGroupAcrossParameter"><code>FeaturizeGroupAcrossParameter</code></a>. The 5th argument is optional and defaults to the centroid of the features.</li></ol><p><strong>Return</strong></p><ol><li><code>aggregated_fractions</code>: same as <code>fractions_cont</code> but now contains the fractions of the aggregated attractors.</li><li><code>aggregated_info</code>: dictionary mapping the new labels of <code>aggregated_fractions</code> to the extracted information using <code>info_extraction</code>.</li></ol><p><strong>Clustering attractors directly</strong></p><p><em>(this is rather advanced)</em></p><p>You may also use the DBSCAN clustering approach here to group attractors based on their state space distance (the <a href="#StateSpaceSets.set_distance"><code>set_distance</code></a>) by making a distance matrix as expected by the DBSCAN implementation. For this, use <code>identity</code> as <code>featurizer</code>, and choose <a href="#Attractors.GroupViaClustering"><code>GroupViaClustering</code></a> as the <code>group_config</code> with <code>clust_distance_metric = set_distance</code> and provide a numerical value for <code>optimal_radius_method</code> when initializing the <a href="#Attractors.GroupViaClustering"><code>GroupViaClustering</code></a>, and also, for the <code>info_extraction</code> argument, you now need to provide a function that expects a <em>vector of <code>StateSpaceSet</code>s</em> and outputs a descriptor. E.g., <code>info_extraction = vector -&gt; mean(mean(x) for x in vector)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/continuation/aggregate_attractor_fractions.jl#L3-L60">source</a></section></article><h3 id="Grouping-continuation"><a class="docs-heading-anchor" href="#Grouping-continuation">Grouping continuation</a><a id="Grouping-continuation-1"></a><a class="docs-heading-anchor-permalink" href="#Grouping-continuation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.FeaturizeGroupAcrossParameter" href="#Attractors.FeaturizeGroupAcrossParameter"><code>Attractors.FeaturizeGroupAcrossParameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FeaturizeGroupAcrossParameter &lt;: GlobalContinuationAlgorithm
FeaturizeGroupAcrossParameter(mapper::AttractorsViaFeaturizing; kwargs...)</code></pre><p>A method for <a href="#Attractors.global_continuation"><code>global_continuation</code></a>. It uses the featurizing approach discussed in <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a> and hence requires an instance of that mapper as an input. When used in <a href="#Attractors.global_continuation"><code>global_continuation</code></a>, features are extracted and then grouped across a parameter range. Said differently, all features of all initial conditions across all parameter values are put into the same &quot;pool&quot; and then grouped as dictated by the <code>group_config</code> of the mapper. After the grouping is finished the feature label fractions are distributed to each parameter value they came from.</p><p>This continuation method is based on, but strongly generalizes, the approaches in the papers (<a href="../references/#Gelbrecht2020">Gelbrecht <em>et al.</em>, 2020</a>) and (<a href="../references/#Stender2021">Stender and Hoffmann, 2021</a>).</p><p><strong>Keyword arguments</strong></p><ul><li><code>info_extraction::Function</code> a function that takes as an input a vector of feature-vectors (corresponding to a cluster) and returns a description of the cluster. By default, the centroid of the cluster is used. This is what the <code>attractors_cont</code> contains in the return of <code>global_continuation</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/continuation/continuation_grouping.jl#L11-L34">source</a></section></article><h2 id="Matching-attractors"><a class="docs-heading-anchor" href="#Matching-attractors">Matching attractors</a><a id="Matching-attractors-1"></a><a class="docs-heading-anchor-permalink" href="#Matching-attractors" title="Permalink"></a></h2><p>Matching attractors follow an extendable interface based on <a href="#Attractors.IDMatcher"><code>IDMatcher</code></a>. The available matchers are:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.MatchBySSSetDistance" href="#Attractors.MatchBySSSetDistance"><code>Attractors.MatchBySSSetDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MatchBySSSetDistance(; distance = Centroid(), threshold = Inf, use_vanished = false)</code></pre><p>A matcher type that matches IDs by the distance of their corresponding state space sets.</p><p><strong>Keyword arguments</strong></p><ul><li><code>distance = Centroid()</code>: distance to match by, given to <a href="#StateSpaceSets.setsofsets_distances"><code>setsofsets_distances</code></a>.</li><li><code>threshold = Inf</code>: sets with distance larger than the <code>threshold</code> are guaranteed to not be mapped to each other.</li><li><code>use_vanished = !isinf(threshold)</code>: value of the keyword <code>use_vanished</code> when used in <a href="#Attractors.match_sequentially!"><code>match_sequentially!</code></a>.</li></ul><p><strong>Description</strong></p><p>In this matcher the values compared are <a href="@ref"><code>StateSpaceSet</code></a>s which in most cases represent attractors in the state space, but may also represent any other set such as a group of features.</p><p>Here is how this matcher works: (recall in this conversation that sets/attractors are stored in dictionaries, mapping keys/IDs to the sets, and we want to match keys in the &quot;new&quot; dictionary (<code>a₊</code>) to those in the &quot;old&quot; dictionary (<code>a₋</code>)).</p><p>The distance between all possible pairs of sets between the &quot;old&quot; sets and &quot;new&quot; sets is computed as a formal distance between sets. This is controlled by the <code>distance</code> option, itself given to the lower-level <a href="#StateSpaceSets.setsofsets_distances"><code>setsofsets_distances</code></a> function, so <code>distance</code> can be whatever that function accepts. That is, one of <a href="#StateSpaceSets.Centroid"><code>Centroid</code></a>, <a href="#StateSpaceSets.Hausdorff"><code>Hausdorff</code></a>, <a href="#StateSpaceSets.StrictlyMinimumDistance"><code>StrictlyMinimumDistance</code></a>, or any arbitrary user-provided function <code>f</code> that given two sets <code>f(A, B)</code> it returns a positive number (their distance).</p><p>Sets (in particular, their corresponding IDs) are then matched according to this distance. First, all possible ID pairs (old, new) are sorted according to the distance of their corresponding sets. The pair with smallest distance is matched. IDs in matched pairs are removed from the matching pool to ensure a unique mapping. Then, the next pair with least remaining distance is matched, and the process repeats until all pairs are exhausted.</p><p>Additionally, you can provide a <code>threshold</code> value. If the distance between two sets is larger than this <code>threshold</code>, then it is guaranteed that the two sets will get assigned different ID in the replacement map, and hence, the set in <code>a₊</code> gets the next available integer as its ID.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/matching/sssdistance.jl#L3-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.MatchByBasinEnclosure" href="#Attractors.MatchByBasinEnclosure"><code>Attractors.MatchByBasinEnclosure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MatchByBasinEnclosure(; kw...) &lt;: IDMatcher</code></pre><p>A matcher that matches attractors by whether they are enclosed in the basin of a new attractor or not.</p><p><strong>Keyword arguments</strong></p><ul><li><code>ε = nothing</code>: distance threshold given to <a href="#Attractors.AttractorsViaProximity"><code>AttractorsViaProximity</code></a>. If <code>nothing</code>, it is estimated as a quarter of the minimum distance of centroids (in contrast to the default more accurate estimation in <a href="#Attractors.AttractorsViaProximity"><code>AttractorsViaProximity</code></a>).</li><li><code>Δt = 1, consecutive_lost_steps = 1000</code>: also given to <a href="#Attractors.AttractorsViaProximity"><code>AttractorsViaProximity</code></a>. We have not yet decided what should happen to attractors that did not converge to one of the current attractors within this number of steps. At the moment they get assigned the next available free ID but this may change in future releases.</li><li><code>distance = Centroid()</code>: metric to estimate distances between state space sets in case there are co-flowing attractors, see below.</li><li><code>seeding = A -&gt; A[end]</code>: how to select a point from the attractor to see if it is enclosed in the basin of a new attractor.</li></ul><p><strong>Description</strong></p><p>An attractor <code>A₋</code> is a set in a state space that occupies a particular region (or, a single point, if it is a fixed point). This region is always within the basin of attraction of said attractor. When the parameter of the dynamical system is incremented, the attractors <code>A₊</code> in the new parameter have basins that may have changed in shape and size.</p><p>The new attractor <code>A₊</code> is &quot;matched&quot; (i.e., has its ID changed) to the old attractor <code>A₋</code> attractor if <code>A₋</code> is located inside the basin of attraction of <code>A₊</code>. To see if <code>A₋</code> is in the basin of <code>A₊</code>, we first pick a point from <code>A₋</code> using the <code>seeding</code> keyword argument. By default this is the last point on the attractor, but it could be anything else, including the centroid of the attractor (<code>mean(A)</code>). This point is given as an initial condition to an <a href="#Attractors.AttractorsViaProximity"><code>AttractorsViaProximity</code></a> mapper that maps initial conditions to the <code>₊</code> attractors when the trajectories from the initial conditions are <code>ε</code>-close to the <code>₊</code> attractors.</p><p>There can be the situation where multiple <code>₋</code> attractors converge to the same <code>₊</code> attractor, which we call &quot;coflowing attractors&quot;. In this scenario matching is prioritized for the <code>₋</code> attractor that is closest to the <code>₊</code> in terms of state space set distance, which is estimated with the <code>distance</code> keyword, which can be anything <a href="#Attractors.MatchBySSSetDistance"><code>MatchBySSSetDistance</code></a> accepts. The closest <code>₊</code> attractor gets the ID of the <code>₋</code> closest attractor that converge to it.</p><p>Basin enclosure is a concept similar to &quot;basin instability&quot; in (<a href="../references/#Ritchie2023">Ritchie <em>et al.</em>, 2023</a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/matching/basin_enclosure.jl#L3-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.MatchByBasinOverlap" href="#Attractors.MatchByBasinOverlap"><code>Attractors.MatchByBasinOverlap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MatchByBasinOverlap(threshold = Inf)</code></pre><p>A matcher that matches IDs given full basins of attraction.</p><p><strong>Description</strong></p><p>This matcher cannot be used in with the generic global continuation method of <a href="#Attractors.AttractorSeedContinueMatch"><code>AttractorSeedContinueMatch</code></a>. This matcher matches IDs of attractors whose basins of attraction before and after <code>b₋, b₊</code> have the most overlap (in pixels). This overlap is normalized in 0-1 (with 1 meaning 100% of a basin in <code>b₋</code> is overlaping with some other basin in <code>b₊</code>). Therefore, the values this matcher compares are <em>full basins of attraction</em>, not attractors themselves (hence why it can&#39;t be given to <a href="#Attractors.AttractorSeedContinueMatch"><code>AttractorSeedContinueMatch</code></a>). Rather, you may use this matcher with <a href="#Attractors.matching_map"><code>matching_map</code></a>.</p><p>The <code>threshold</code> can dissallow matching between basins that do not have enough overlap. Basins whose overlap is less than <code>1/threshold</code> are guaranteed to get assined different IDs. For example: for <code>threshold = 2</code> basins that have ≤ 50% overlap get different IDs guaranteed. By default, there is no threshold.</p><p>The information of the basins of attraction is typically an <code>Array</code>, i.e., the direct output of <a href="#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>. For convenience, as well as backwards compatibility, when using <a href="#Attractors.matching_map"><code>matching_map</code></a> with this mapper you may provide two <code>Array</code>s <code>b₊, b₋</code> representing basins of attraction after and before, and the conversion to dictionaries will happen internally as it is supposed to. To replace the <code>IDs</code> in <code>b₊</code> given the replacement map just call <code>replace!(b₊, rmap...)</code>, or use the in-place version <a href="#Attractors.matching_map!"><code>matching_map!</code></a> directly.</p><p>A lower-level input for this matcher in <a href="#Attractors.matching_map"><code>matching_map</code></a> can be dictionaries mapping IDs to vectors of cartesian indices, where the indices mean which parts of the state space belong to which ID</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/matching/basin_overlap.jl#L3-L37">source</a></section></article><h3 id="Matching-interface"><a class="docs-heading-anchor" href="#Matching-interface">Matching interface</a><a id="Matching-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Matching-interface" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.IDMatcher" href="#Attractors.IDMatcher"><code>Attractors.IDMatcher</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IDMatcher</code></pre><p>Supertype of all &quot;matchers&quot; that match can IDs labelling attractors. Currently available matchers:</p><ul><li><a href="#Attractors.MatchBySSSetDistance"><code>MatchBySSSetDistance</code></a></li><li><a href="#Attractors.MatchByBasinEnclosure"><code>MatchByBasinEnclosure</code></a></li><li><a href="#Attractors.MatchByBasinOverlap"><code>MatchByBasinOverlap</code></a></li></ul><p>Matchers implement an extendable interface based on the function <a href="#Attractors.matching_map"><code>matching_map</code></a>. This function is used by the higher level function <a href="#Attractors.match_sequentially!"><code>match_sequentially!</code></a>, which can be called after any call to a global continuation to match attractors differently, if the matching used originally during the continuation was not the best.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/matching/matching_interface.jl#L10-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.matching_map" href="#Attractors.matching_map"><code>Attractors.matching_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">matching_map(
    a₊::Dict, a₋::Dict, matcher;
    ds::DynamicalSystem, p, pprev, next_id
) → rmap</code></pre><p>Given dictionaries <code>a₊, a₋</code> mapping IDs to values, return a <em>replacement map</em>: a dictionary mapping the IDs (keys) in dictionary <code>a₊</code> to IDs (keys) in dictionary <code>a₋</code>, so that so that values in <code>a₊</code> that are the &quot;closest&quot; to values in <code>a₋</code> get assigned the same key as in <code>a₋</code>. In this way keys of <code>a₊</code> are &quot;matched&quot; to keys of <code>a₋</code>. Use <a href="@ref"><code>swap_dict_keys</code></a> to apply <code>rmap</code> to <code>a₊</code> or to other dictionaries with same keys as <code>a₊</code>.</p><p>How matching happens, i.e., how &quot;closeness&quot; is defined, depends on the algorithm <code>matcher</code>.</p><p>The values contained in <code>a₊, a₋</code> can be anything supported by <code>matcher</code>. Within Attractors.jl they are typically <code>StateSpaceSet</code>s representing attractors. Typically the +,- mean after and before some change of parameter of a dynamical system.</p><p><strong>Keyword arguments</strong></p><ul><li><code>ds</code>: the dynamical system that generated <code>a₊, a₋</code>.</li><li><code>p, pprev</code>: the parameters corresponding to <code>a₊, a₋</code>. Both need to be iterables mapping parameter index to parameter value (such as <code>Dict, Vector{Pair}</code>, etc., so whatever can be given as input to <code>DynamicalSystems.set_parameters!</code>).</li><li><code>next_id = next_free_id(a₊, a₋)</code>: the ID to give to values of  <code>a₊</code> that cannot be matched to <code>a₋</code> and hence must obtain a new unique ID.</li></ul><p>Some matchers like <a href="#Attractors.MatchBySSSetDistance"><code>MatchBySSSetDistance</code></a> do not utilize <code>ds, p, pprev</code> in any way while other matchers like <a href="#Attractors.MatchByBasinEnclosure"><code>MatchByBasinEnclosure</code></a> do, and those require expliticly giving values to <code>ds, p, pprev</code> as their default values is just <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/matching/matching_interface.jl#L27-L60">source</a></section><section><div><pre><code class="language-julia hljs">matching_map(b₊::AbstractArray, b₋::AbstractArray, matcher::MatchByBasinOverlap)</code></pre><p>Special case of <code>matching_map</code> where instead of having as input dictionaries mapping IDs to values, we have <code>Array</code>s which represent basins of attraction and whose elements are the IDs.</p><p>See <a href="#Attractors.MatchByBasinOverlap"><code>MatchByBasinOverlap</code></a> for how matching works.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/matching/basin_overlap.jl#L44-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.matching_map!" href="#Attractors.matching_map!"><code>Attractors.matching_map!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">matching_map!(a₊, a₋, matcher; kw...) → rmap</code></pre><p>Convenience function that first calls <a href="#Attractors.matching_map"><code>matching_map</code></a> and then replaces the IDs in <code>a₊</code> with this <code>rmap</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/matching/matching_interface.jl#L67-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.match_sequentially!" href="#Attractors.match_sequentially!"><code>Attractors.match_sequentially!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">match_sequentially!(dicts::Vector{Dict{Int, Any}}, matcher::IDMatcher; kw...)</code></pre><p>Match the <code>dicts</code>, a vector of dictionaries mapping IDs (integers) to values, according to the given <code>matcher</code> by sequentially applying the <a href="#Attractors.matching_map"><code>matching_map</code></a> function to all elements of <code>dicts</code> besides the first one.</p><p>In the context of Attractors.jl <code>dicts</code> are typically dictionaries mapping IDs to attractors (<code>StateSpaceSet</code>s), however the function is generic and would work for any values that <code>matcher</code> works with.</p><p>Return <code>rmaps</code>, which is a vector of dictionaries. <code>rmaps[i]</code> contains the <a href="#Attractors.matching_map"><code>matching_map</code></a> for <code>attractors[i+1]</code>, i.e., the pairs of <code>old =&gt; new</code> IDs.</p><p><strong>Keyword arguments</strong></p><ul><li><code>pcurve = nothing</code>: the curve of parameters along which the continuation occured, from which to extract the <code>p, pprev</code> values given to <a href="#Attractors.matching_map"><code>matching_map</code></a>. See <a href="#Attractors.global_continuation"><code>global_continuation</code></a> if you are unsure what this means.</li><li><code>ds = nothing</code>: propagated to <a href="#Attractors.matching_map"><code>matching_map</code></a>.</li><li><code>retract_keys::Bool = true</code>: If <code>true</code> at the end the function will &quot;retract&quot; keys (i.e., make the integers smaller integers) so that all unique IDs are the 1-incremented positive integers. E.g., if the IDs where 1, 6, 8, they will become 1, 2, 3. The special ID -1 is unaffected by this.</li><li><code>use_vanished = false</code>: If <code>use_vanised = true</code>, then IDs (and their corresponding sets) that existed before but have vanished are kept in &quot;memory&quot; when it comes to matching: the current dictionary values (the attractor sets) are compared to the latest instance of all values that have ever existed, each with a unique ID, and get matched to their closest ones. The value of this keyword is obtained from the <code>matcher</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/matching/matching_interface.jl#L79-L109">source</a></section><section><div><pre><code class="language-julia hljs">match_sequentially!(continuation_quantity::Vector{Dict}, rmaps::Vector{Dict})</code></pre><p>Do the same as in <code>match_sequentially!</code> above, now given the vector of matching maps, and for any arbitrary quantity that has been tracked in the global<em>continuation. `continuation</em>quantity<code>can for example be</code>fractions<em>cont<code>from [</code>global</em>continuation`](@ref).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/matching/matching_interface.jl#L144-L150">source</a></section></article><h3 id="Low-level-distance-functions"><a class="docs-heading-anchor" href="#Low-level-distance-functions">Low-level distance functions</a><a id="Low-level-distance-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Low-level-distance-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceSets.Centroid" href="#StateSpaceSets.Centroid"><code>StateSpaceSets.Centroid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Centroid(metric = Euclidean())</code></pre><p>A distance that can be used in <a href="#StateSpaceSets.set_distance"><code>set_distance</code></a>. The <code>Centroid</code> method returns the distance (according to <code>metric</code>) between the <a href="https://en.wikipedia.org/wiki/Centroid">centroids</a> (a.k.a. centers of mass) of the sets.</p><p><code>metric</code> can be any function that takes in two static vectors are returns a positive definite number to use as a distance (and typically is a <code>Metric</code> from Distances.jl).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/v1.5.0/src/set_distance.jl#L21-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceSets.Hausdorff" href="#StateSpaceSets.Hausdorff"><code>StateSpaceSets.Hausdorff</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Hausdorff(metric = Euclidean())</code></pre><p>A distance that can be used in <a href="#StateSpaceSets.set_distance"><code>set_distance</code></a>. The <a href="https://en.wikipedia.org/wiki/Hausdorff_distance">Hausdorff distance</a> is the greatest of all the distances from a point in one set to the closest point in the other set. The distance is calculated with the metric given to <code>Hausdorff</code> which defaults to Euclidean.</p><p><code>Hausdorff</code> is 2x slower than <a href="#StateSpaceSets.StrictlyMinimumDistance"><code>StrictlyMinimumDistance</code></a>, however it is a proper metric in the space of sets of state space sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/v1.5.0/src/set_distance.jl#L42-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceSets.StrictlyMinimumDistance" href="#StateSpaceSets.StrictlyMinimumDistance"><code>StateSpaceSets.StrictlyMinimumDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StrictlyMinimumDistance([brute = false,] [metric = Euclidean(),])</code></pre><p>A distance that can be used in <a href="#StateSpaceSets.set_distance"><code>set_distance</code></a>. The <code>StrictlyMinimumDistance</code> returns the minimum distance of all the distances from a point in one set to the closest point in the other set. The distance is calculated with the given metric.</p><p>The <code>brute::Bool</code> argument switches the computation between a KDTree-based version, or brute force (i.e., calculation of all distances and picking the smallest one). Brute force performs better for datasets that are either large dimensional or have a small amount of points. Deciding a cutting point is not trivial, and is recommended to simply benchmark the <a href="#StateSpaceSets.set_distance"><code>set_distance</code></a> function to make a decision.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/v1.5.0/src/set_distance.jl#L68-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceSets.set_distance" href="#StateSpaceSets.set_distance"><code>StateSpaceSets.set_distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_distance(ssset1, ssset2 [, distance])</code></pre><p>Calculate a distance between two <code>StateSpaceSet</code>s, i.e., a distance defined between sets of points, as dictated by <code>distance</code>.</p><p>Possible <code>distance</code> types are:</p><ul><li><a href="#StateSpaceSets.Centroid"><code>Centroid</code></a>, which is the default, and 100s of times faster than the rest</li><li><a href="#StateSpaceSets.Hausdorff"><code>Hausdorff</code></a></li><li><a href="#StateSpaceSets.StrictlyMinimumDistance"><code>StrictlyMinimumDistance</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/v1.5.0/src/set_distance.jl#L7-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceSets.setsofsets_distances" href="#StateSpaceSets.setsofsets_distances"><code>StateSpaceSets.setsofsets_distances</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setsofsets_distances(a₊, a₋ [, distance]) → distances</code></pre><p>Calculate distances between sets of <code>StateSpaceSet</code>s. Here  <code>a₊, a₋</code> are containers of <code>StateSpaceSet</code>s, and the returned distances are dictionaries of distances. Specifically, <code>distances[i][j]</code> is the distance of the set in the <code>i</code> key of <code>a₊</code> to the <code>j</code> key of <code>a₋</code>. Notice that distances from <code>a₋</code> to <code>a₊</code> are not computed at all (assumming symmetry in the distance function).</p><p>The <code>distance</code> can be as in <a href="#StateSpaceSets.set_distance"><code>set_distance</code></a>, or it can be an arbitrary function that takes as input two state space sets and returns any positive-definite number as their &quot;distance&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/v1.5.0/src/set_distance.jl#L132-L144">source</a></section></article><h3 id="Dict-utils"><a class="docs-heading-anchor" href="#Dict-utils">Dict utils</a><a id="Dict-utils-1"></a><a class="docs-heading-anchor-permalink" href="#Dict-utils" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.unique_keys" href="#Attractors.unique_keys"><code>Attractors.unique_keys</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unique_keys(v::Iterator{&lt;:AbstractDict})</code></pre><p>Given a vector of dictionaries, return a sorted vector of the unique keys that are present across all dictionaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/dict_utils.jl#L85-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.swap_dict_keys!" href="#Attractors.swap_dict_keys!"><code>Attractors.swap_dict_keys!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">swap_dict_keys!(d::Dict, matching_map::Dict)</code></pre><p>Swap the keys of a dictionary <code>d</code> given a <code>matching_map</code> which maps old keys to new keys. Also ensure that a swap can happen at most once, e.g., if input <code>d</code> has a key <code>4</code>, and <code>rmap = Dict(4 =&gt; 3, 3 =&gt; 2)</code>, then the key <code>4</code> will be transformed to <code>3</code> and not further to <code>2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/dict_utils.jl#L9-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.next_free_id" href="#Attractors.next_free_id"><code>Attractors.next_free_id</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">next_free_id(new::Dict, old::Dict)</code></pre><p>Return the minimum key of the &quot;new&quot; dictionary that doesn&#39;t exist in the &quot;old&quot; dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/dict_utils.jl#L101-L106">source</a></section></article><h2 id="Visualization-utilities"><a class="docs-heading-anchor" href="#Visualization-utilities">Visualization utilities</a><a id="Visualization-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization-utilities" title="Permalink"></a></h2><p>Several plotting utility functions have been created to make the visualization of the output of Attractors.jl seamless. See the examples page for usage of all these plotting functions.</p><p>Note that all functions have an out-of-place and an in-place form, the in-place form always taking as a first input a pre-initialized <code>Axis</code> to plot in while the out-of-place creates and returns a new figure object.</p><p>E.g.,</p><pre><code class="language-julia hljs">fig = heatmap_basins_attractors(grid, basins, attractors; kwargs...)
heatmap_basins_attractors!(ax, grid, basins, attractors; kwargs...)</code></pre><h3 id="common_plot_kwargs"><a class="docs-heading-anchor" href="#common_plot_kwargs">Common plotting keywords</a><a id="common_plot_kwargs-1"></a><a class="docs-heading-anchor-permalink" href="#common_plot_kwargs" title="Permalink"></a></h3><p>Common keywords for plotting functions in Attractors.jl are:</p><ul><li><code>ukeys</code>: the basin ids (unique keys, vector of integers) to use. By default all existing keys are used.</li><li><code>access = [1, 2]</code>: indices of which dimensions of an attractor to select and visualize in a two-dimensional plot (as in <a href="#Attractors.animate_attractors_continuation"><code>animate_attractors_continuation</code></a>).</li><li><code>colors</code>: a dictionary mapping basin ids (i.e., including the <code>-1</code> key) to a color. By default the JuliaDynamics colorscheme is used if less than 7 ids are present, otherwise random colors from the <code>:darktest</code> colormap.</li><li><code>markers</code>: dictionary mapping attractor ids to markers they should be plotted as</li><li><code>labels = Dict(ukeys .=&gt; ukeys)</code>: how to label each attractor.</li><li><code>add_legend = length(ukeys) &lt; 7</code>: whether to add a legend mapping colors to labels.</li></ul><h3 id="Basins-related"><a class="docs-heading-anchor" href="#Basins-related">Basins related</a><a id="Basins-related-1"></a><a class="docs-heading-anchor-permalink" href="#Basins-related" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.plot_attractors" href="#Attractors.plot_attractors"><code>Attractors.plot_attractors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot_attractors(attractors::Dict{Int, StateSpaceSet}; kwargs...)</code></pre><p>Plot the attractors as a scatter plot.</p><p><strong>Keyword arguments</strong></p><ul><li>All the <a href="#common_plot_kwargs">common plotting keywords</a>. Particularly important is the <code>access</code> keyword.</li><li><code>sckwargs = (strokewidth = 0.5, strokecolor = :black,)</code>: additional keywords propagated to the <code>Makie.scatter</code> function that plots the attractors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/plotting.jl#L4-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.heatmap_basins_attractors" href="#Attractors.heatmap_basins_attractors"><code>Attractors.heatmap_basins_attractors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">heatmap_basins_attractors(grid, basins, attractors; kwargs...)</code></pre><p>Plot a heatmap of found (2-dimensional) <code>basins</code> of attraction and corresponding <code>attractors</code>, i.e., the output of <a href="#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>.</p><p><strong>Keyword arguments</strong></p><ul><li>All the <a href="#common_plot_kwargs">common plotting keywords</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/plotting.jl#L23-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.shaded_basins_heatmap" href="#Attractors.shaded_basins_heatmap"><code>Attractors.shaded_basins_heatmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">shaded_basins_heatmap(grid, basins, attractors, iterations; kwargs...)</code></pre><p>Plot a heatmap of found (2-dimensional) <code>basins</code> of attraction and corresponding <code>attractors</code>. A matrix <code>iterations</code> with the same size of <code>basins</code> must be provided to shade the color according to the value of this matrix. A small value corresponds to a light color and a large value to a darker tone. This is useful to represent the number of iterations taken for each initial condition to converge. See also <a href="#Attractors.convergence_time"><code>convergence_time</code></a> to store this iteration number.</p><p><strong>Keyword arguments</strong></p><ul><li><code>show_attractors = true</code>: shows the attractor on plot</li><li><code>maxit = maximum(iterations)</code>: clip the values of <code>iterations</code> to</li></ul><p>the value <code>maxit</code>. Useful when there are some very long iterations and keep the range constrained to a given interval.</p><ul><li>All the <a href="#common_plot_kwargs">common plotting keywords</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/plotting.jl#L37-L54">source</a></section></article><h3 id="Continuation-related"><a class="docs-heading-anchor" href="#Continuation-related">Continuation related</a><a id="Continuation-related-1"></a><a class="docs-heading-anchor-permalink" href="#Continuation-related" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.plot_basins_curves" href="#Attractors.plot_basins_curves"><code>Attractors.plot_basins_curves</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot_basins_curves(fractions_cont [, prange]; kw...)</code></pre><p>Plot the fractions of basins of attraction versus a parameter range/curve, i.e., visualize the output of <a href="#Attractors.global_continuation"><code>global_continuation</code></a>. See also <a href="#Attractors.plot_basins_attractors_curves"><code>plot_basins_attractors_curves</code></a> and <a href="@ref"><code>plot_continuation_curves</code></a>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>style = :band</code>: how to visualize the basin fractions. Choices are <code>:band</code> for a band plot with cumulative sum = 1 or <code>:lines</code> for a lines plot of each basin fraction</li><li><code>separatorwidth = 1, separatorcolor = &quot;white&quot;</code>: adds a line separating the fractions if the style is <code>:band</code></li><li><code>axislegend_kwargs = (position = :lt,)</code>: propagated to <code>axislegend</code> if a legend is added</li><li><code>series_kwargs = NamedTuple()</code>: propagated to the band or scatterline plot</li><li>Also all <a href="#common_plot_kwargs">common plotting keywords</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/plotting.jl#L92-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.plot_attractors_curves" href="#Attractors.plot_attractors_curves"><code>Attractors.plot_attractors_curves</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot_attractors_curves(attractors_cont, attractor_to_real [, prange]; kw...)</code></pre><p>Same as in <a href="#Attractors.plot_basins_curves"><code>plot_basins_curves</code></a> but visualize the attractor dependence on the parameter(s) instead of their basin fraction. The function <code>attractor_to_real</code> takes as input a <code>StateSpaceSet</code> (attractor) and returns a real number so that it can be plotted versus the parameter axis. See also <a href="#Attractors.plot_basins_attractors_curves"><code>plot_basins_attractors_curves</code></a>.</p><p>Same keywords as <a href="#common_plot_kwargs"><code>plot_basins_curves</code></a>. See also <a href="@ref"><code>plot_continuation_curves</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/plotting.jl#L115-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.plot_basins_attractors_curves" href="#Attractors.plot_basins_attractors_curves"><code>Attractors.plot_basins_attractors_curves</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot_basins_attractors_curves(
    fractions_cont, attractors_cont, a2rs [, prange]
    kwargs...
)</code></pre><p>Convenience combination of <a href="#Attractors.plot_basins_curves"><code>plot_basins_curves</code></a> and <a href="#Attractors.plot_attractors_curves"><code>plot_attractors_curves</code></a> in a multi-panel plot that shares legend, colors, markers, etc. This function allows <code>a2rs</code> to be a <code>Vector</code> of functions, each mapping attractors into real numbers. Below the basins fractions plot, one additional panel is created for each entry in <code>a2rs</code>. <code>a2rs</code> can also be a single function, in which case only one panel is made.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/plotting.jl#L151-L163">source</a></section></article><h3 id="Video-output"><a class="docs-heading-anchor" href="#Video-output">Video output</a><a id="Video-output-1"></a><a class="docs-heading-anchor-permalink" href="#Video-output" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.animate_attractors_continuation" href="#Attractors.animate_attractors_continuation"><code>Attractors.animate_attractors_continuation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">animate_attractors_continuation(
    ds::DynamicalSystem, attractors_cont, fractions_cont, pcurve;
    kwargs...
)</code></pre><p>Animate how the found system attractors and their corresponding basin fractions change as the system parameter is increased. This function combines the input and output of the <a href="#Attractors.global_continuation"><code>global_continuation</code></a> function into a video output.</p><p>The input dynamical system <code>ds</code> is used to evolve initial conditions sampled from the found attractors, so that the attractors are better visualized. <code>attractors_cont, fractions_cont</code> are the output of <a href="#Attractors.global_continuation"><code>global_continuation</code></a> while <code>ds, pcurve</code> are the input to <a href="#Attractors.global_continuation"><code>global_continuation</code></a>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>savename = &quot;attracont.mp4&quot;</code>: name of video output file.</li><li><code>framerate = 4</code>: framerate of video output.</li><li><code>Δt, T</code>: propagated to <code>trajectory</code> for evolving an initial condition sampled from an attractor.</li><li>Also all <a href="#common_plot_kwargs">common plotting keywords</a>.</li><li><code>figure, axis, fracaxis, legend</code>: named tuples propagated as keyword arguments to the creation of the <code>Figure</code>, the <code>Axis</code>, the &quot;bar-like&quot; axis containing the fractions, and the <code>axislegend</code> that adds the legend (if <code>add_legend = true</code>).</li><li><code>add_legend = true</code>: whether to display the axis legend.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/079fb599b65e296acc65d4f5ebd31c5d740e374c/src/plotting.jl#L62-L88">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Attractors.jl Tutorial</a><a class="docs-footer-nextpage" href="../examples/">Examples for Attractors.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Tuesday 6 August 2024 13:36">Tuesday 6 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
