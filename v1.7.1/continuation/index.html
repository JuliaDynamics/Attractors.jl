<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Attractor &amp; Basins Continuation · Attractors.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Attractors.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Attractors.jl</a></li><li><a class="tocitem" href="../dynsysref/"><code>DynamicalSystem</code> reference</a></li><li><a class="tocitem" href="../attractors/">Finding Attractors</a></li><li><a class="tocitem" href="../basins/">Basins of Attraction</a></li><li class="is-active"><a class="tocitem" href>Attractor &amp; Basins Continuation</a><ul class="internal"><li><a class="tocitem" href="#A-new-kind-of-continuation"><span>A new kind of continuation</span></a></li><li><a class="tocitem" href="#Continuation-API"><span>Continuation API</span></a></li><li><a class="tocitem" href="#Recurrences-continuation-(best)"><span>Recurrences continuation (best)</span></a></li><li><a class="tocitem" href="#Matching-attractors"><span>Matching attractors</span></a></li><li><a class="tocitem" href="#Aggregating-attractors-and-fractions"><span>Aggregating attractors and fractions</span></a></li><li><a class="tocitem" href="#Grouping-continuation"><span>Grouping continuation</span></a></li></ul></li><li><a class="tocitem" href="../visualization/">Visualization utilities</a></li><li><a class="tocitem" href="../examples/">Examples for Attractors.jl</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Attractor &amp; Basins Continuation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Attractor &amp; Basins Continuation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/Attractors.jl/blob/main/docs/src/continuation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Attractor-and-Basins-Continuation"><a class="docs-heading-anchor" href="#Attractor-and-Basins-Continuation">Attractor &amp; Basins Continuation</a><a id="Attractor-and-Basins-Continuation-1"></a><a class="docs-heading-anchor-permalink" href="#Attractor-and-Basins-Continuation" title="Permalink"></a></h1><h2 id="A-new-kind-of-continuation"><a class="docs-heading-anchor" href="#A-new-kind-of-continuation">A new kind of continuation</a><a id="A-new-kind-of-continuation-1"></a><a class="docs-heading-anchor-permalink" href="#A-new-kind-of-continuation" title="Permalink"></a></h2><p>If you have heard before the word &quot;continuation&quot;, then you are likely aware of the <strong>traditional continuation-based bifurcation analysis (CBA)</strong> offered by many software, such as AUTO, MatCont, and in Julia <a href="https://github.com/bifurcationkit/BifurcationKit.jl">BifurcationKit.jl</a>. Here we offer a completely different kind of continuation called <strong>attractors &amp; basins continuation</strong>.</p><p>A direct comparison of the two approaches is not truly possible, because they do different things. The traditional linearized continuation analysis continues the curves of individual fixed points across the joint state-parameter space. The attractor and basins continuation first finds all attractors at all parameter values and then <em>matches</em> appropriately similar attractors across different parameters, giving the illusion of continuing them individually. Additionally, the curves of stable fixed points in the joint parameter space is only a small by-product of the attractor basins continuation, and the main information is the basin fractions and how these change in the parameter space.</p><p>A more detailed comparison between these two fundamentally different approaches in is given in high detail in our <a href="https://github.com/JuliaDynamics/Attractors.jl/blob/main/CITATION.bib">paper</a>.</p><h2 id="Continuation-API"><a class="docs-heading-anchor" href="#Continuation-API">Continuation API</a><a id="Continuation-API-1"></a><a class="docs-heading-anchor-permalink" href="#Continuation-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Attractors.continuation" href="#Attractors.continuation"><code>Attractors.continuation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">continuation(abc::AttractorsBasinsContinuation, prange, pidx, ics; kwargs...)</code></pre><p>Find and continue attractors (or feature-based representations of attractors) and the fractions of their basins of attraction across a parameter range. <code>continuation</code> is the central function of the framework for global stability analysis illustrated in <sup class="footnote-reference"><a id="citeref-Datseris2023" href="#footnote-Datseris2023">[Datseris2023]</a></sup>.</p><p>The continuation type <code>abc</code> is a subtype of <code>AttractorsBasinsContinuation</code> and contains an <a href="../attractors/#Attractors.AttractorMapper"><code>AttractorMapper</code></a>. The mapper contains information on how to find the attractors and basins of a dynamical system. Additional arguments and keyword arguments given when creating <code>abc</code> further tune the continuation and how attractors are matched across different parameter values.</p><p>The basin fractions and the attractors (or some representation of them) are continued across the parameter range <code>prange</code>, for the parameter of the system with index <code>pidx</code> (any index valid in <a href="../dynsysref/#DynamicalSystemsBase.set_parameter!"><code>set_parameter!</code></a> can be used).</p><p><code>ics</code> is a 0-argument function generating initial conditions for the dynamical system (as in <a href="../basins/#Attractors.basins_fractions"><code>basins_fractions</code></a>).</p><p>Possible subtypes of <code>AttractorsBasinsContinuation</code> are:</p><ul><li><a href="#Attractors.RecurrencesFindAndMatch"><code>RecurrencesFindAndMatch</code></a></li><li><a href="#Attractors.FeaturizeGroupAcrossParameter"><code>FeaturizeGroupAcrossParameter</code></a></li></ul><p><strong>Return</strong></p><ol><li><code>fractions_curves::Vector{Dict{Int, Float64}}</code>. The fractions of basins of attraction. <code>fractions_curves[i]</code> is a dictionary mapping attractor IDs to their basin fraction at the <code>i</code>-th parameter.</li><li><code>attractors_info::Vector{Dict{Int, &lt;:Any}}</code>. Information about the attractors. <code>attractors_info[i]</code> is a dictionary mapping attractor ID to information about the attractor at the <code>i</code>-th parameter. The type of information stored depends on the chosen continuation type.</li></ol><p><strong>Keyword arguments</strong></p><ul><li><code>show_progress = true</code>: display a progress bar of the computation.</li><li><code>samples_per_parameter = 100</code>: amount of initial conditions sampled at each parameter from <code>ics</code>.</li></ul><p>Datseris, Rossi, Wagemakers 2023, Framework for global stability analysis of    dynamical systems, <a href="https://arxiv.org/abs/2304.12786">arXiv:2304.12786</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/cd0e8579ebb2dca5fd64dd784d11dd0346ff1345/src/continuation/basins_fractions_continuation_api.jl#L9-L54">source</a></section></article><h2 id="Recurrences-continuation-(best)"><a class="docs-heading-anchor" href="#Recurrences-continuation-(best)">Recurrences continuation (best)</a><a id="Recurrences-continuation-(best)-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrences-continuation-(best)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Attractors.RecurrencesFindAndMatch" href="#Attractors.RecurrencesFindAndMatch"><code>Attractors.RecurrencesFindAndMatch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RecurrencesFindAndMatch &lt;: AttractorsBasinsContinuation
RecurrencesFindAndMatch(mapper::AttractorsViaRecurrences; kwargs...)</code></pre><p>A method for <a href="#Attractors.continuation"><code>continuation</code></a> as in <sup class="footnote-reference"><a id="citeref-Datseris2023" href="#footnote-Datseris2023">[Datseris2023]</a></sup> that is based on the recurrences-based algorithm for finding attractors (<a href="../attractors/#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a>) and the &quot;matching attractors&quot; functionality offered by <a href="#Attractors.match_statespacesets!"><code>match_statespacesets!</code></a>.</p><p>You can use <code>RAFM</code> as an alias.</p><p><strong>Description</strong></p><p>At the first parameter slice of the continuation process, attractors and their fractions are found as described in the <a href="../attractors/#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a> mapper using recurrences in state space. At each subsequent parameter slice, new attractors are found by seeding initial conditions from the previously found attractors and then running these initial conditions through the recurrences algorithm of the <code>mapper</code>. Seeding initial conditions close to previous attractors accelerates the main bottleneck of <a href="../attractors/#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a>, which is finding the attractors.</p><p>After the attractors are found, their fractions are computed by sampling new random initial (using the provided <code>sampler</code> in <a href="#Attractors.continuation"><code>continuation</code></a>) and mapping them to attractors using the <a href="../attractors/#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a> mapper. I.e., exactly as in <a href="../basins/#Attractors.basins_fractions"><code>basins_fractions</code></a>.</p><p>Then, the newly found attractors (and their fractions) are &quot;matched&quot; to the previous ones. I.e., their <em>IDs are changed</em>, according to the <a href="#Attractors.match_statespacesets!"><code>match_statespacesets!</code></a> function. Typically, the matching process matches attractor IDs that are closest in state space distance, but more options are possible, see <a href="#Attractors.match_statespacesets!"><code>match_statespacesets!</code></a>.</p><p>This process continues until all parameter values are exhausted and for each parameter value the attractors and their fractions are found.</p><p>Note that since in this continuation the finding-attractors and matching-attractors steps are completely independent. This means, that if you don&#39;t like the initial outcome of the matching process, you may call <a href="#Attractors.rematch!"><code>rematch!</code></a> on the outcome.</p><p><strong>Keyword arguments</strong></p><ul><li><code>distance, threshold</code>: propagated to <a href="#Attractors.match_statespacesets!"><code>match_statespacesets!</code></a>.</li><li><code>info_extraction = identity</code>: A function that takes as an input an attractor (<code>StateSpaceSet</code>) and outputs whatever information should be stored. It is used to return the <code>attractors_info</code> in <a href="#Attractors.continuation"><code>continuation</code></a>.</li><li><code>seeds_from_attractor</code>: A function that takes as an input an attractor and returns an iterator of initial conditions to be seeded from the attractor for the next parameter slice. By default, we sample only the first stored point on the attractor.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/cd0e8579ebb2dca5fd64dd784d11dd0346ff1345/src/continuation/continuation_recurrences.jl#L8-L58">source</a></section></article><h2 id="Matching-attractors"><a class="docs-heading-anchor" href="#Matching-attractors">Matching attractors</a><a id="Matching-attractors-1"></a><a class="docs-heading-anchor-permalink" href="#Matching-attractors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Attractors.match_statespacesets!" href="#Attractors.match_statespacesets!"><code>Attractors.match_statespacesets!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">match_statespacesets!(a₊::AbstractDict, a₋; distance = Centroid(), threshold = Inf)</code></pre><p>Given dictionaries <code>a₊, a₋</code> mapping IDs to <code>StateSpaceSet</code> instances, match the IDs in dictionary <code>a₊</code> so that its sets that are the closest to those in dictionary <code>a₋</code> get assigned the same key as in <code>a₋</code>. Typically the +,- mean after and before some change of parameter of a system.</p><p>Return the replacement map, a dictionary mapping old keys of <code>a₊</code> to the new ones that they were mapped to. You can obtain this map, without modifying the dictionaries, by calling the <a href="#Attractors.replacement_map"><code>replacement_map</code></a> function directly.</p><p><strong>Keyword arguments</strong></p><ul><li><code>distance = Centroid()</code>: given to <a href="#StateSpaceSets.setsofsets_distances"><code>setsofsets_distances</code></a>.</li><li><code>threshold = Inf</code>: attractors with distance larger than the <code>threshold</code> are guaranteed to not be mapped to each other.</li></ul><p><strong>Description</strong></p><p>When finding attractors and their fractions in Attractors.jl, different attractors get assigned different IDs. However which attractor gets which ID is somewhat arbitrary. Finding the attractors of the same system for slightly different parameters could label &quot;similar&quot; attractors (at the different parameters) with different IDs. <code>match_statespacesets!</code> tries to &quot;match&quot; them by modifying the IDs, i.e., the keys of the given dictionaries. Do note however that there is nothing in this function that is limited to attractors in the formal mathematical sense. Any dictionary with <code>StateSpaceSet</code> values is a valid input and these sets may represent attractors, trajectories, group of features, or anything else.</p><p>The matching happens according to the output of the <a href="#StateSpaceSets.setsofsets_distances"><code>setsofsets_distances</code></a> function with the keyword <code>distance</code>. <code>distance</code> can be whatever that function accepts, i.e., one of <code>Centroid, Hausdorff, StrictlyMinimumDistance</code> or any arbitrary user- provided function that given two sets it returns a positive number (their distance). State space sets are then matched according to this distance, with unique mapping. The closest attractors (before and after) are mapped to each other, and are removed from the matching pool, and then the next pair with least remaining distance is matched, and so on.</p><p>Additionally, you can provide a <code>threshold</code> value. If the distance between two attractors is larger than this <code>threshold</code>, then it is guaranteed that the attractors will get assigned different key in the dictionary <code>a₊</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/cd0e8579ebb2dca5fd64dd784d11dd0346ff1345/src/continuation/match_attractor_ids.jl#L7-L50">source</a></section><section><div><pre><code class="nohighlight hljs">match_statespacesets!(attractors_info::Vector{&lt;:Dict}; kwargs...)</code></pre><p>Convenience method that progresses through the dictionaries in <code>attractors_info</code> in sequence and matches them using same keywords as the above method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/cd0e8579ebb2dca5fd64dd784d11dd0346ff1345/src/continuation/match_attractor_ids.jl#L57-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Attractors.replacement_map" href="#Attractors.replacement_map"><code>Attractors.replacement_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">replacement_map(a₊, a₋; distance = Centroid(), threshold = Inf) → rmap</code></pre><p>Return a dictionary mapping keys in <code>a₊</code> to new keys in <code>a₋</code>, as explained in <a href="#Attractors.match_statespacesets!"><code>match_statespacesets!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/cd0e8579ebb2dca5fd64dd784d11dd0346ff1345/src/continuation/match_attractor_ids.jl#L70-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.set_distance" href="#StateSpaceSets.set_distance"><code>StateSpaceSets.set_distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_distance(ssset1, ssset2 [, distance])</code></pre><p>Calculate a distance between two <code>StateSpaceSet</code>s, i.e., a distance defined between sets of points, as dictated by <code>distance</code>.</p><p>Possible <code>distance</code> types are:</p><ul><li><a href="@ref"><code>Centroid</code></a>, which is the default, and 100s of times faster than the rest</li><li><a href="@ref"><code>Hausdorff</code></a></li><li><a href="@ref"><code>StrictlyMinimumDistance</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.setsofsets_distances" href="#StateSpaceSets.setsofsets_distances"><code>StateSpaceSets.setsofsets_distances</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setsofsets_distances(a₊, a₋ [, distance]) → distances</code></pre><p>Calculate distances between sets of <code>StateSpaceSet</code>s. Here  <code>a₊, a₋</code> are containers of <code>StateSpaceSet</code>s, and the returned distances are dictionaries of distances. Specifically, <code>distances[i][j]</code> is the distance of the set in the <code>i</code> key of <code>a₊</code> to the <code>j</code> key of <code>a₋</code>. Notice that distances from <code>a₋</code> to <code>a₊</code> are not computed at all (assumming symmetry in the distance function).</p><p>The <code>distance</code> can be as in <a href="#StateSpaceSets.set_distance"><code>set_distance</code></a>, or it can be an arbitrary function that takes as input two state space sets and returns any positive-definite number as their &quot;distance&quot;.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Attractors.match_basins_ids!" href="#Attractors.match_basins_ids!"><code>Attractors.match_basins_ids!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">match_basins_ids!(b₊::AbstractArray, b₋; threshold = Inf)</code></pre><p>Similar to <a href="#Attractors.match_statespacesets!"><code>match_statespacesets!</code></a> but operate on basin arrays instead (the arrays typically returned by <a href="../basins/#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>).</p><p>This method matches IDs of attractors whose basins of attraction before and after <code>b₋,b₊</code> have the most overlap (in pixels). This overlap is normalized in 0-1 (with 1 meaning 100% overlap of pixels). The <code>threshold</code> in this case is compared to the inverse of the overlap (so, for <code>threshold = 2</code> attractors that have less than 50% overlap get different IDs guaranteed).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/cd0e8579ebb2dca5fd64dd784d11dd0346ff1345/src/continuation/match_attractor_ids.jl#L132-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Attractors.rematch!" href="#Attractors.rematch!"><code>Attractors.rematch!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rematch!(fractions_curves, attractors_info; kwargs...)</code></pre><p>Given the outputs of <a href="#Attractors.continuation"><code>continuation</code></a> witn <a href="#Attractors.RecurrencesFindAndMatch"><code>RecurrencesFindAndMatch</code></a>, perform the matching step of the process again with the (possibly different) keywords that <a href="#Attractors.match_statespacesets!"><code>match_statespacesets!</code></a> accepts. This &quot;re-matching&quot; is possible because in <a href="#Attractors.continuation"><code>continuation</code></a> finding the attractors and their basins is a completely independent step from matching them with their IDs in the previous parameter value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/cd0e8579ebb2dca5fd64dd784d11dd0346ff1345/src/continuation/match_attractor_ids.jl#L171-L179">source</a></section></article><h2 id="Aggregating-attractors-and-fractions"><a class="docs-heading-anchor" href="#Aggregating-attractors-and-fractions">Aggregating attractors and fractions</a><a id="Aggregating-attractors-and-fractions-1"></a><a class="docs-heading-anchor-permalink" href="#Aggregating-attractors-and-fractions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Attractors.aggregate_attractor_fractions" href="#Attractors.aggregate_attractor_fractions"><code>Attractors.aggregate_attractor_fractions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">aggregate_attractor_fractions(
    fractions_curves, attractors_info, featurizer, group_config [, info_extraction]
)</code></pre><p>Aggregate the already-estimated curves of fractions of basins of attraction of similar attractors using the same pipeline used by <a href="../attractors/#Attractors.GroupingConfig"><code>GroupingConfig</code></a>. The most typical application of this function is to transform the output of <a href="#Attractors.RecurrencesFindAndMatch"><code>RecurrencesFindAndMatch</code></a> so that similar attractors, even across parameter space, are grouped into one &quot;attractor&quot;. Thus, the fractions of their basins are aggregated.</p><p>You could also use this function to aggregate attractors and their fractions even in a single parameter configuration, i.e., using the output of <a href="../basins/#Attractors.basins_fractions"><code>basins_fractions</code></a>.</p><p>This function is useful in cases where you want the accuracy and performance of <a href="../attractors/#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a>, but you also want the convenience of &quot;grouping&quot; similar attractrors like in <a href="../attractors/#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a> for presentation or analysis purposes. For example, a high dimesional model of competition dynamics across multispecies may have extreme multistability. After finding this multistability however, one may care about aggregating all attractors into two groups: where a given species is extinct or not. This is the example highlighted in our documentation, in <a href="../examples/#Extinction-of-a-species-in-a-multistable-competition-model">Extinction of a species in a multistable competition model</a>.</p><p><strong>Input</strong></p><ol><li><code>fractions_curves</code>: a vector of dictionaries mapping labels to basin fractions.</li><li><code>attractors_info</code>: a vector of dictionaries mapping labels to attractors. 1st and 2nd argument are exactly like the return values of <a href="#Attractors.continuation"><code>continuation</code></a> with <a href="#Attractors.RecurrencesFindAndMatch"><code>RecurrencesFindAndMatch</code></a> (or, they can be the return of <a href="../basins/#Attractors.basins_fractions"><code>basins_fractions</code></a>).</li><li><code>featurizer</code>: a 1-argument function to map an attractor into an appropriate feature to be grouped later. Features expected by <a href="../attractors/#Attractors.GroupingConfig"><code>GroupingConfig</code></a> are <code>SVector</code>.</li><li><code>group_config</code>: a subtype of <a href="../attractors/#Attractors.GroupingConfig"><code>GroupingConfig</code></a>.</li><li><code>info_extraction</code>: a function accepting a vector of features and returning a description of the features. I.e., exactly as in <a href="#Attractors.FeaturizeGroupAcrossParameter"><code>FeaturizeGroupAcrossParameter</code></a>. The 5th argument is optional and defaults to the centroid of the features.</li></ol><p><strong>Return</strong></p><ol><li><code>aggregated_fractions</code>: same as <code>fractions_curves</code> but now contains the fractions of the aggregated attractors.</li><li><code>aggregated_info</code>: dictionary mapping the new labels of <code>aggregated_fractions</code> to the extracted information using <code>info_extraction</code>.</li></ol><p><strong>Clustering attractors directly</strong></p><p><em>(this is rather advanced)</em></p><p>You may also use the DBSCAN clustering approach here to group attractors based on their state space distance (the <a href="#StateSpaceSets.set_distance"><code>set_distance</code></a>) by making a distance matrix as expected by the DBSCAN implementation. For this, use <code>identity</code> as <code>featurizer</code>, and choose <a href="../attractors/#Attractors.GroupViaClustering"><code>GroupViaClustering</code></a> as the <code>group_config</code> with <code>clust_distance_metric = set_distance</code> and provide a numerical value for <code>optimal_radius_method</code> when initializing the <a href="../attractors/#Attractors.GroupViaClustering"><code>GroupViaClustering</code></a>, and also, for the <code>info_extraction</code> argument, you now need to provide a function that expects a <em>vector of <code>StateSpaceSet</code>s</em> and outputs a descriptor. E.g., <code>info_extraction = vector -&gt; mean(mean(x) for x in vector)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/cd0e8579ebb2dca5fd64dd784d11dd0346ff1345/src/continuation/aggregate_attractor_fractions.jl#L3-L60">source</a></section></article><h2 id="Grouping-continuation"><a class="docs-heading-anchor" href="#Grouping-continuation">Grouping continuation</a><a id="Grouping-continuation-1"></a><a class="docs-heading-anchor-permalink" href="#Grouping-continuation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Attractors.FeaturizeGroupAcrossParameter" href="#Attractors.FeaturizeGroupAcrossParameter"><code>Attractors.FeaturizeGroupAcrossParameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FeaturizeGroupAcrossParameter &lt;: AttractorsBasinsContinuation
FeaturizeGroupAcrossParameter(mapper::AttractorsViaFeaturizing; kwargs...)</code></pre><p>A method for <a href="#Attractors.continuation"><code>continuation</code></a>. It uses the featurizing approach discussed in <a href="../attractors/#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a> and hence requires an instance of that mapper as an input. When used in <a href="#Attractors.continuation"><code>continuation</code></a>, features are extracted and then grouped across a parameter range. Said differently, all features of all initial conditions across all parameter values are put into the same &quot;pool&quot; and then grouped as dictated by the <code>group_config</code> of the mapper. After the grouping is finished the feature label fractions are distributed to each parameter value they came from.</p><p><strong>Keyword arguments</strong></p><ul><li><code>info_extraction::Function</code> a function that takes as an input a vector of feature-vectors (corresponding to a cluster) and returns a description of the cluster. By default, the centroid of the cluster is used.</li><li><code>par_weight = 0</code>: See below the section on MCBB.</li></ul><p><strong>MCBB special version</strong></p><p>If the chosen grouping method is <a href="../attractors/#Attractors.GroupViaClustering"><code>GroupViaClustering</code></a>, the additional keyword <code>par_weight::Real</code> can be used. If it is ≠ 0, the distance matrix between features obtains an extra weight that is proportional to the distance <code>par_weight*|p[i] - p[j]|</code> between the parameters used when extracting features. The range of parameters is normalized to 0-1 such that the largest distance in the parameter space is 1. The normalization is done because the feature space is also (by default) normalized to 0-1.</p><p>This version of the algorithm is the original &quot;MCBB&quot; continuation method described in <sup class="footnote-reference"><a id="citeref-Gelbrecht2020" href="#footnote-Gelbrecht2020">[Gelbrecht2020]</a></sup>, besides the improvements of clustering accuracy and performance done by the developer team of Attractors.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/cd0e8579ebb2dca5fd64dd784d11dd0346ff1345/src/continuation/continuation_grouping.jl#L11-L47">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Datseris2023"><a class="tag is-link" href="#citeref-Datseris2023">Datseris2023</a></li><li class="footnote" id="footnote-Datseris2023"><a class="tag is-link" href="#citeref-Datseris2023">Datseris2023</a>Datseris, Rossi, Wagemakers 2023, Framework for global stability analysis of dynamical systems, <a href="https://arxiv.org/abs/2304.12786">arXiv:2304.12786</a></li><li class="footnote" id="footnote-Gelbrecht2021"><a class="tag is-link" href="#citeref-Gelbrecht2021">Gelbrecht2021</a>Maximilian Gelbrecht et al 2021, Monte Carlo basin bifurcation analysis, <a href="http://dx.doi.org/10.1088/1367-2630/ab7a05">New J. Phys.22 03303</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../basins/">« Basins of Attraction</a><a class="docs-footer-nextpage" href="../visualization/">Visualization utilities »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 29 June 2023 10:03">Thursday 29 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
