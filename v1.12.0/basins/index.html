<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basins of Attraction · Attractors.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Attractors.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Attractors.jl</a></li><li><a class="tocitem" href="../dynsysref/"><code>DynamicalSystem</code> reference</a></li><li><a class="tocitem" href="../attractors/">Finding Attractors</a></li><li class="is-active"><a class="tocitem" href>Basins of Attraction</a><ul class="internal"><li><a class="tocitem" href="#Basins-of-attraction"><span>Basins of attraction</span></a></li><li><a class="tocitem" href="#Final-state-sensitivity-/-fractal-boundaries"><span>Final state sensitivity / fractal boundaries</span></a></li><li><a class="tocitem" href="#Tipping-points"><span>Tipping points</span></a></li><li><a class="tocitem" href="#Mimimal-Fatal-Shock"><span>Mimimal Fatal Shock</span></a></li></ul></li><li><a class="tocitem" href="../continuation/">Attractor &amp; Basins Continuation</a></li><li><a class="tocitem" href="../visualization/">Visualization utilities</a></li><li><a class="tocitem" href="../examples/">Examples for Attractors.jl</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Basins of Attraction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Basins of Attraction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/Attractors.jl/blob/main/docs/src/basins.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Basins-of-Attraction"><a class="docs-heading-anchor" href="#Basins-of-Attraction">Basins of Attraction</a><a id="Basins-of-Attraction-1"></a><a class="docs-heading-anchor-permalink" href="#Basins-of-Attraction" title="Permalink"></a></h1><p>This page provides several functions related to the basins of attraction and their boundaries. It requires you to have first understood the <a href="../attractors/#Finding-Attractors">Finding Attractors</a> page.</p><h2 id="Basins-of-attraction"><a class="docs-heading-anchor" href="#Basins-of-attraction">Basins of attraction</a><a id="Basins-of-attraction-1"></a><a class="docs-heading-anchor-permalink" href="#Basins-of-attraction" title="Permalink"></a></h2><p>Calculating basins of attraction, or their state space fractions, can be done with the functions:</p><ul><li><a href="#Attractors.basins_fractions"><code>basins_fractions</code></a></li><li><a href="#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>.</li></ul><article class="docstring"><header><a class="docstring-binding" id="Attractors.basins_fractions" href="#Attractors.basins_fractions"><code>Attractors.basins_fractions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basins_fractions(
    mapper::AttractorMapper,
    ics::Union{StateSpaceSet, Function};
    kwargs...
)</code></pre><p>Approximate the state space fractions <code>fs</code> of the basins of attraction of a dynamical stystem by mapping initial conditions to attractors using <code>mapper</code> (which contains a reference to a <a href="../dynsysref/#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a>). The fractions are simply the ratios of how many initial conditions ended up at each attractor.</p><p>Initial conditions to use are defined by <code>ics</code>. It can be:</p><ul><li>a <code>StateSpaceSet</code> of initial conditions, in which case all are used.</li><li>a 0-argument function <code>ics()</code> that spits out random initial conditions. Then <code>N</code> random initial conditions are chosen. See <a href="#StateSpaceSets.statespace_sampler"><code>statespace_sampler</code></a> to generate such functions.</li></ul><p><strong>Return</strong></p><p>The function will always return <code>fractions</code>, which is a dictionary whose keys are the labels given to each attractor (always integers enumerating the different attractors), and whose values are the respective basins fractions. The label <code>-1</code> is given to any initial condition where <code>mapper</code> could not match to an attractor (this depends on the <code>mapper</code> type).</p><p>If <code>ics</code> is a <code>StateSpaceSet</code> the function will also return <code>labels</code>, which is <em>vector</em>, of equal length to <code>ics</code>, that contains the label each initial condition was mapped to.</p><p>See <a href="../attractors/#Attractors.AttractorMapper"><code>AttractorMapper</code></a> for all possible <code>mapper</code> types, and use <a href="#Attractors.extract_attractors"><code>extract_attractors</code></a> (after calling <code>basins_fractions</code>) to extract the stored attractors from the <code>mapper</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>N = 1000</code>: Number of random initial conditions to generate in case <code>ics</code> is a function.</li><li><code>show_progress = true</code>: Display a progress bar of the process.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/55e3876e72e19fa5341294ec794f1300b1215a37/src/mapping/attractor_mapping.jl#L58-L96">source</a></section><section><div><pre><code class="nohighlight hljs">basins_fractions(basins::AbstractArray) → fs::Dict</code></pre><p>Calculate the state space fraction of the basins of attraction encoded in <code>basins</code>. The elements of <code>basins</code> are integers, enumerating the attractor that the entry of <code>basins</code> converges to (i.e., like the output of <a href="#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>). Return a dictionary that maps attractor IDs to their relative fractions.</p><p>In <a href="../references/#Menck2013">(Menck <em>et al.</em>, 2013)</a> the authors use these fractions to quantify the stability of a basin of attraction, and specifically how it changes when a parameter is changed. For this, see <a href="../continuation/#Attractors.continuation"><code>continuation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/55e3876e72e19fa5341294ec794f1300b1215a37/src/basins/basins_utilities.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Attractors.extract_attractors" href="#Attractors.extract_attractors"><code>Attractors.extract_attractors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_attractors(mapper::AttractorsMapper) → attractors</code></pre><p>Return a dictionary mapping label IDs to attractors found by the <code>mapper</code>. This function should be called after calling <a href="#Attractors.basins_fractions"><code>basins_fractions</code></a> with the given <code>mapper</code> so that the attractors have actually been found first.</p><p>For <code>AttractorsViaFeaturizing</code>, the attractors are only stored if the mapper was called with pre-defined initial conditions rather than a sampler (function returning initial conditions).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/55e3876e72e19fa5341294ec794f1300b1215a37/src/mapping/attractor_mapping.jl#L130-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Attractors.basins_of_attraction" href="#Attractors.basins_of_attraction"><code>Attractors.basins_of_attraction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basins_of_attraction(mapper::AttractorMapper, grid::Tuple) → basins, attractors</code></pre><p>Compute the full basins of attraction as identified by the given <code>mapper</code>, which includes a reference to a <a href="@ref"><code>GeneralizedDynamicalSystem</code></a> and return them along with (perhaps approximated) found attractors.</p><p><code>grid</code> is a tuple of ranges defining the grid of initial conditions that partition the state space into boxes with size the step size of each range. For example, <code>grid = (xg, yg)</code> where <code>xg = yg = range(-5, 5; length = 100)</code>. The grid has to be the same dimensionality as the state space expected by the integrator/system used in <code>mapper</code>. E.g., a <a href="@ref"><code>projected_integrator</code></a> could be used for lower dimensional projections, etc. A special case here is a <a href="@ref"><code>poincaremap</code></a> with <code>plane</code> being <code>Tuple{Int, &lt;: Real}</code>. In this special scenario the grid can be one dimension smaller than the state space, in which case the partitioning happens directly on the hyperplane the Poincaré map operates on.</p><p><code>basins_of_attraction</code> function is a convenience 5-lines-of-code wrapper which uses the <code>labels</code> returned by <a href="#Attractors.basins_fractions"><code>basins_fractions</code></a> and simply assings them to a full array corresponding to the state space partitioning indicated by <code>grid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/55e3876e72e19fa5341294ec794f1300b1215a37/src/mapping/attractor_mapping.jl#L147-L166">source</a></section><section><div><pre><code class="nohighlight hljs">basins_of_attraction(mapper::AttractorsViaRecurrences; show_progress = true)</code></pre><p>This is a special method of <code>basins_of_attraction</code> that using recurrences does <em>exactly</em> what is described in the paper by Datseris &amp; Wagemakers <a href="../references/#Datseris2022">Datseris2022</a>. By enforcing that the internal grid of <code>mapper</code> is the same as the grid of initial conditions to map to attractors, the method can further utilize found exit and attraction basins, making the computation faster as the grid is processed more and more.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/55e3876e72e19fa5341294ec794f1300b1215a37/src/mapping/recurrences/attractor_mapping_recurrences.jl#L168-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.statespace_sampler" href="#StateSpaceSets.statespace_sampler"><code>StateSpaceSets.statespace_sampler</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">statespace_sampler(region [, seed = 42]) → sampler, isinside</code></pre><p>A function that facilitates sampling points randomly and uniformly in a state space <code>region</code>. It generates two functions:</p><ul><li><code>sampler</code> is a 0-argument function that when called generates a random point inside a state space <code>region</code>. The point is always a <code>Vector</code> for type stability irrespectively of dimension. Generally, the generated point should be <em>copied</em> if it needs to be stored. (i.e., calling <code>sampler()</code> utilizes a shared vector) <code>sampler</code> is a thread-safe function.</li><li><code>isinside</code> is a 1-argument function that returns <code>true</code> if the given state space point is inside the <code>region</code>.</li></ul><p>The <code>region</code> can be an instance of any of the following types (input arguments if not specified are vectors of length <code>D</code>, with <code>D</code> the state space dimension):</p><ul><li><code>HSphere(radius::Real, center)</code>: points <em>inside</em> the hypersphere (boundary excluded). Convenience method <code>HSphere(radius::Real, D::Int)</code> makes the center a <code>D</code>-long vector of zeros.</li><li><code>HSphereSurface(radius, center)</code>: points on the hypersphere surface. Same convenience method as above is possible.</li><li><code>HRectangle(mins, maxs)</code>: points in [min, max) for the bounds along each dimension.</li></ul><p>The random number generator is always <code>Xoshiro</code> with the given <code>seed</code>.</p></div></section><section><div><pre><code class="nohighlight hljs">statespace_sampler(grid::NTuple{N, AbstractRange} [, seed])</code></pre><p>If given a <code>grid</code> that is a tuple of <code>AbstractVector</code>s, the minimum and maximum of the vectors are used to make an <code>HRectangle</code> region.</p></div></section></article><h2 id="Final-state-sensitivity-/-fractal-boundaries"><a class="docs-heading-anchor" href="#Final-state-sensitivity-/-fractal-boundaries">Final state sensitivity / fractal boundaries</a><a id="Final-state-sensitivity-/-fractal-boundaries-1"></a><a class="docs-heading-anchor-permalink" href="#Final-state-sensitivity-/-fractal-boundaries" title="Permalink"></a></h2><p>Several functions are provided related with analyzing the fractality of the boundaries of the basins of attraction:</p><ul><li><a href="#Attractors.basins_fractal_dimension"><code>basins_fractal_dimension</code></a></li><li><a href="#Attractors.basin_entropy"><code>basin_entropy</code></a></li><li><a href="#Attractors.basins_fractal_test"><code>basins_fractal_test</code></a></li><li><a href="#Attractors.uncertainty_exponent"><code>uncertainty_exponent</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Attractors.basins_fractal_dimension" href="#Attractors.basins_fractal_dimension"><code>Attractors.basins_fractal_dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basins_fractal_dimension(basins; kwargs...) -&gt; V_ε, N_ε, d</code></pre><p>Estimate the fractal dimension <code>d</code> of the boundary between basins of attraction using a box-counting algorithm for the boxes that contain at least two different basin IDs.</p><p><strong>Keyword arguments</strong></p><ul><li><code>range_ε = 2:maximum(size(basins))÷20</code> is the range of sizes of the box to test (in pixels).</li></ul><p><strong>Description</strong></p><p>The output <code>N_ε</code> is a vector with the number of the balls of radius <code>ε</code> (in pixels) that contain at least two initial conditions that lead to different attractors. <code>V_ε</code> is a vector with the corresponding size of the balls. The ouput <code>d</code> is the estimation of the box-counting dimension of the boundary by fitting a line in the <code>log.(N_ε)</code> vs <code>log.(1/V_ε)</code> curve. However it is recommended to analyze the curve directly for more accuracy.</p><p>It is the implementation of the popular algorithm of the estimation of the box-counting dimension. The algorithm search for a covering the boundary with <code>N_ε</code> boxes of size <code>ε</code> in pixels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/55e3876e72e19fa5341294ec794f1300b1215a37/src/basins/fractality_of_basins.jl#L148-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Attractors.basin_entropy" href="#Attractors.basin_entropy"><code>Attractors.basin_entropy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basin_entropy(basins::Array, ε = 20) -&gt; Sb, Sbb</code></pre><p>Compute the basin entropy <a href="../references/#Daza2016">(Daza <em>et al.</em>, 2016)</a> <code>Sb</code> and basin boundary entropy <code>Sbb</code> of the given <code>basins</code> of attraction by considering <code>ε</code> boxes along each dimension.</p><p><strong>Description</strong></p><p>First, the input <code>basins</code> is divided regularly into n-dimensional boxes of side <code>ε</code> (along all dimensions). Then <code>Sb</code> is simply the average of the Gibbs entropy computed over these boxes. The function returns the basin entropy <code>Sb</code> as well as the boundary basin entropy <code>Sbb</code>. The later is the average of the entropy only for boxes that contains at least two different basins, that is, for the boxes on the boundaries.</p><p>The basin entropy is a measure of the uncertainty on the initial conditions of the basins. It is maximum at the value <code>log(n_att)</code> being <code>n_att</code> the number of attractors. In this case the boundary is intermingled: for a given initial condition we can find another initial condition that lead to another basin arbitriraly close. It provides also a simple criterion for fractality: if the boundary basin entropy <code>Sbb</code> is above <code>log(2)</code> then we have a fractal boundary. It doesn&#39;t mean that basins with values below cannot have a fractal boundary, for a more precise test see <a href="#Attractors.basins_fractal_test"><code>basins_fractal_test</code></a>. An important feature of the basin entropy is that it allows comparisons between different basins using the same box size <code>ε</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/55e3876e72e19fa5341294ec794f1300b1215a37/src/basins/fractality_of_basins.jl#L3-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Attractors.basins_fractal_test" href="#Attractors.basins_fractal_test"><code>Attractors.basins_fractal_test</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basins_fractal_test(basins; ε = 20, Ntotal = 1000) -&gt; test_res, Sbb</code></pre><p>Perform an automated test to decide if the boundary of the basins has fractal structures based on the method of Puy et al. <a href="../references/#Puy2021">(Puy <em>et al.</em>, 2021)</a>. Return <code>test_res</code> (<code>:fractal</code> or <code>:smooth</code>) and the mean basin boundary entropy.</p><p><strong>Keyword arguments</strong></p><ul><li><code>ε = 20</code>: size of the box to compute the basin boundary entropy.</li><li><code>Ntotal = 1000</code>: number of balls to test in the boundary for the computation of <code>Sbb</code></li></ul><p><strong>Description</strong></p><p>The test &quot;looks&quot; at the basins with a magnifier of size <code>ε</code> at random. If what we see in the magnifier looks like a smooth boundary (onn average) we decide that the boundary is smooth. If it is not smooth we can say that at the scale <code>ε</code> we have structures, i.e., it is fractal.</p><p>In practice the algorithm computes the boundary basin entropy <code>Sbb</code> <a href="#Attractors.basin_entropy"><code>basin_entropy</code></a> for <code>Ntotal</code> random boxes of radius <code>ε</code>. If the computed value is equal to theoretical value of a smooth boundary (taking into account statistical errors and biases) then we decide that we have a smooth boundary. Notice that the response <code>test_res</code> may depend on the chosen ball radius <code>ε</code>. For larger size, we may observe structures for smooth boundary and we obtain a <em>different</em> answer.</p><p>The output <code>test_res</code> is a symbol describing the nature of the basin and the output <code>Sbb</code> is the estimated value of the boundary basin entropy with the sampling method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/55e3876e72e19fa5341294ec794f1300b1215a37/src/basins/fractality_of_basins.jl#L57-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Attractors.uncertainty_exponent" href="#Attractors.uncertainty_exponent"><code>Attractors.uncertainty_exponent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">uncertainty_exponent(basins; kwargs...) -&gt; ε, N_ε, α</code></pre><p>Estimate the uncertainty exponent<a href="@ref">Grebogi1983</a> of the basins of attraction. This exponent is related to the final state sensitivity of the trajectories in the phase space. An exponent close to <code>1</code> means basins with smooth boundaries whereas an exponent close to <code>0</code> represent completely fractalized basins, also called riddled basins.</p><p>The output <code>N_ε</code> is a vector with the number of the balls of radius <code>ε</code> (in pixels) that contain at least two initial conditions that lead to different attractors. The ouput <code>α</code> is the estimation of the uncertainty exponent using the box-counting dimension of the boundary by fitting a line in the <code>log.(N_ε)</code> vs <code>log.(1/ε)</code> curve. However it is recommended to analyze the curve directly for more accuracy.</p><p><strong>Keyword arguments</strong></p><ul><li><code>range_ε = 2:maximum(size(basins))÷20</code> is the range of sizes of the ball to test (in pixels).</li></ul><p><strong>Description</strong></p><p>A phase space with a fractal boundary may cause a uncertainty on the final state of the dynamical system for a given initial condition. A measure of this final state sensitivity is the uncertainty exponent. The algorithm probes the basin of attraction with balls of size <code>ε</code> at random. If there are a least two initial conditions that lead to different attractors, a ball is tagged &quot;uncertain&quot;. <code>f_ε</code> is the fraction of &quot;uncertain balls&quot; to the total number of tries in the basin. In analogy to the fractal dimension, there is a scaling law between, <code>f_ε ~ ε^α</code>. The number that characterizes this scaling is called the uncertainty exponent <code>α</code>.</p><p>Notice that the uncertainty exponent and the box counting dimension of the boundary are related. We have <code>Δ₀ = D - α</code> where <code>Δ₀</code> is the box counting dimension computed with <a href="#Attractors.basins_fractal_dimension"><code>basins_fractal_dimension</code></a> and <code>D</code> is the dimension of the phase space. The algorithm first estimates the box counting dimension of the boundary and returns the uncertainty exponent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/55e3876e72e19fa5341294ec794f1300b1215a37/src/basins/fractality_of_basins.jl#L209-L243">source</a></section></article><h2 id="Tipping-points"><a class="docs-heading-anchor" href="#Tipping-points">Tipping points</a><a id="Tipping-points-1"></a><a class="docs-heading-anchor-permalink" href="#Tipping-points" title="Permalink"></a></h2><p>This page discusses functionality related with tipping points in dynamical systems with known rule. If instead you are interested in identifying tipping points in measured timeseries, have a look at <a href="https://github.com/JuliaDynamics/TransitionIndicators.jl">TransitionIndicators.jl</a>.</p><article class="docstring"><header><a class="docstring-binding" id="Attractors.tipping_probabilities" href="#Attractors.tipping_probabilities"><code>Attractors.tipping_probabilities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tipping_probabilities(basins_before, basins_after) → P</code></pre><p>Return the tipping probabilities of the computed basins before and after a change in the system parameters (or time forcing), according to the definition of <a href="@cite">Kaszás2019</a>.</p><p>The input <code>basins</code> are integer-valued arrays, where the integers enumerate the attractor, e.g. the output of <a href="#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>.</p><p><strong>Description</strong></p><p>Let <span>$\mathcal{B}_i(p)$</span> denote the basin of attraction of attractor <span>$A_i$</span> at parameter(s) <span>$p$</span>. Kaszás et al <a href="@cite">Kaszás2019</a> define the tipping probability from <span>$A_i$</span> to <span>$A_j$</span>, given a parameter change in the system of <span>$p_- \to p_+$</span>, as</p><p class="math-container">\[P(A_i \to A_j | p_- \to p_+) =
\frac{|\mathcal{B}_j(p_+) \cap \mathcal{B}_i(p_-)|}{|\mathcal{B}_i(p_-)|}\]</p><p>where <span>$|\cdot|$</span> is simply the volume of the enclosed set. The value of <span>$P(A_i \to A_j | p_- \to p_+)$</span> is <code>P[i, j]</code>. The equation describes something quite simple: what is the overlap of the basin of attraction of <span>$A_i$</span> at <span>$p_-$</span> with that of the attractor <span>$A_j$</span> at <span>$p_+$</span>. If <code>basins_before, basins_after</code> contain values of <code>-1</code>, corresponding to trajectories that diverge, this is considered as the last attractor of the system in <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/55e3876e72e19fa5341294ec794f1300b1215a37/src/tipping/tipping_probabilities.jl#L3-L28">source</a></section></article><h2 id="Mimimal-Fatal-Shock"><a class="docs-heading-anchor" href="#Mimimal-Fatal-Shock">Mimimal Fatal Shock</a><a id="Mimimal-Fatal-Shock-1"></a><a class="docs-heading-anchor-permalink" href="#Mimimal-Fatal-Shock" title="Permalink"></a></h2><p>The algorithm to find minimal perturbation for arbitrary initial condition <code>u0</code> which will kick the system into different from the current basin. </p><article class="docstring"><header><a class="docstring-binding" id="Attractors.minimal_fatal_shock" href="#Attractors.minimal_fatal_shock"><code>Attractors.minimal_fatal_shock</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">minimal_fatal_shock(mapper::AttractorMapper, u0, search_area, algorithm) → mfs</code></pre><p>Return the minimal fatal shock <code>mfs</code> for the initial point <code>u0</code> according to the specified <code>algorithm</code> given a <code>mapper</code> that satisfies the <code>id = mapper(u0)</code> interface (see <a href="../attractors/#Attractors.AttractorMapper"><code>AttractorMapper</code></a> if you are not sure which mappers do that). The <code>mapper</code> contains a reference to a <a href="../dynsysref/#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a>. The options for <code>algorithm</code> are: <a href="#Attractors.MFSBruteForce"><code>MFSBruteForce</code></a> or <a href="#Attractors.MFSBlackBoxOptim"><code>MFSBlackBoxOptim</code></a>. Forh high dimensional systems <a href="#Attractors.MFSBlackBoxOptim"><code>MFSBlackBoxOptim</code></a> is likely more accurate.</p><p>The <code>search_area</code> dictates the state space range for the search of the <code>mfs</code>. It can be a 2-tuple of (min, max) values, in which case the same values are used for each dimension of the system in <code>mapper</code>. Otherwise, it can be a vector of 2-tuples, each for each dimension of the system. The search area is defined w.r.t. to <code>u0</code> (i.e., it is the search area for perturbations of <code>u0</code>).</p><p><strong>Description</strong></p><p>The minimal fatal shock is defined as the smallest (smallest norm) perturbation of the initial point <code>u0</code> that will lead it a different basin of attraction. It is inspired by the paper &quot;Minimal fatal shocks in multistable complex networks&quot; <a href="../references/#Halekotte2020">(Halekotte and Feudel, 2020)</a>, however the implementation here is generic: it works for <em>any</em> dynamical system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/55e3876e72e19fa5341294ec794f1300b1215a37/src/tipping/mfs.jl#L5-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Attractors.MFSBlackBoxOptim" href="#Attractors.MFSBlackBoxOptim"><code>Attractors.MFSBlackBoxOptim</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MFSBlackBoxOptim(; kwargs...)</code></pre><p>The black box derivative-free optimization algorithm used in <a href="#Attractors.minimal_fatal_shock"><code>minimal_fatal_shock</code></a>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>guess = nothing</code> a initial guess for the minimal fatal shock given to the optimization algorithm. If not <code>nothing</code>, <code>random_algo</code> below is ignored.</li><li><code>max_steps = 10000</code> maximum number of steps for the optimization algorithm.</li><li><code>penalty</code> penalty value for the objective function, allows to adjust optimization algorithm to find the minimal fatal shock, <code>default = 1000.0</code></li><li><code>print_info</code> boolean value, if true, the optimization algorithm will print information on the evaluation steps of objective function, <code>default = false</code>.</li><li><code>random_algo = MFSBruteForce(100, 100, 0.99)</code>: an instance of <a href="#Attractors.MFSBruteForce"><code>MFSBruteForce</code></a> that can be used to provide an initial guess.</li></ul><p><strong>Description</strong></p><p>The algorithm uses BlackBoxOptim.jl and a penaltized objective function to minimize. y function used as a constraint function. So, if we hit another basin during the search we encourage the algorithm otherwise we punish it with some penalty. The function to minimize is (besides some details):</p><pre><code class="language-julia hljs">function mfs_objective(perturbation, u0, mapper, penalty)
    dist = norm(perturbation)
    if mapper(u0 + perturbation) == mapper(u0)
        # penaltize if we stay in the same basin:
        return dist + penalty
    else
        return dist
    end
end</code></pre><p>Using an initial guess can be beneficial to both performance and accuracy, which is why the output of a crude <a href="#Attractors.MFSBruteForce"><code>MFSBruteForce</code></a> is used to provide a guess. This can be disabled by either passing a <code>guess</code> vector explicitly or by giving <code>nothing</code> as <code>random_algo</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/55e3876e72e19fa5341294ec794f1300b1215a37/src/tipping/mfs.jl#L159-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Attractors.MFSBruteForce" href="#Attractors.MFSBruteForce"><code>Attractors.MFSBruteForce</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MFSBruteForce(; kwargs...)</code></pre><p>The brute force randomized search algorithm used in <a href="#Attractors.minimal_fatal_shock"><code>minimal_fatal_shock</code></a>.</p><p>It consists of two steps: random initialization and sphere radius reduction. On the first step, the algorithm generates random pertubations within the search area and records the perturbation that leads to a different basin but with the smallest magnitude. With this obtained pertubation it proceeds to the second step. On the second step, the algorithm generates random pertubations on the surface of the hypersphere with radius equal to the norm of the pertubation found in the first step. It reduces the radius of the hypersphere and continues searching for the better result with a smaller radius. Each time a better result is found, the radius is reduced further.</p><p>The algorithm records the perturbation with smallest radius that leads to a different basin.</p><p><strong>Keyword arguments</strong></p><ul><li><code>initial_iterations = 10000</code>: number of random pertubations to try in the first step of the algorithm.</li><li><code>sphere_iterations = 10000</code>: number of steps while initializing random points on hypersphere and decreasing its radius.</li><li><code>sphere_decrease_factor = 0.999</code> factor by which the radius of the hypersphere is decreased (at each step the radius is multiplied by this number). Number closer to 1 means more refined accuracy</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/55e3876e72e19fa5341294ec794f1300b1215a37/src/tipping/mfs.jl#L42-L69">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../attractors/">« Finding Attractors</a><a class="docs-footer-nextpage" href="../continuation/">Attractor &amp; Basins Continuation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 5 October 2023 19:58">Thursday 5 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
