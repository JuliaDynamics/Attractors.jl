<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basins of Attraction · Attractors.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Attractors.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Attractors.jl</a></li><li><a class="tocitem" href="../attractors/">Finding Attractors</a></li><li class="is-active"><a class="tocitem" href>Basins of Attraction</a><ul class="internal"><li><a class="tocitem" href="#Basins-of-attraction"><span>Basins of attraction</span></a></li><li><a class="tocitem" href="#Final-state-sensitivity-/-fractal-boundaries"><span>Final state sensitivity / fractal boundaries</span></a></li><li><a class="tocitem" href="#Tipping-points"><span>Tipping points</span></a></li></ul></li><li><a class="tocitem" href="../continuation/">Attractor &amp; Basins Continuation</a></li><li><a class="tocitem" href="../examples/">Examples for Attractors.jl</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Basins of Attraction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Basins of Attraction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/Attractors.jl/blob/main/docs/src/basins.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Basins-of-Attraction"><a class="docs-heading-anchor" href="#Basins-of-Attraction">Basins of Attraction</a><a id="Basins-of-Attraction-1"></a><a class="docs-heading-anchor-permalink" href="#Basins-of-Attraction" title="Permalink"></a></h1><p>This page provides several functions related to the basins of attraction and their boundaries. It requires you to have first understood the <a href="../attractors/#Finding-Attractors">Finding Attractors</a> page.</p><h2 id="Basins-of-attraction"><a class="docs-heading-anchor" href="#Basins-of-attraction">Basins of attraction</a><a id="Basins-of-attraction-1"></a><a class="docs-heading-anchor-permalink" href="#Basins-of-attraction" title="Permalink"></a></h2><p>Calculating basins of attraction, or their state space fractions, can be done with the functions:</p><ul><li><a href="#Attractors.basins_fractions"><code>basins_fractions</code></a></li><li><a href="#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>.</li></ul><article class="docstring"><header><a class="docstring-binding" id="Attractors.basins_fractions" href="#Attractors.basins_fractions"><code>Attractors.basins_fractions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basins_fractions(
    mapper::AttractorMapper,
    ics::Union{StateSpaceSet, Function};
    kwargs...
)</code></pre><p>Approximate the state space fractions <code>fs</code> of the basins of attraction of a dynamical stystem by mapping initial conditions to attractors using <code>mapper</code> (which contains a reference to a <a href="../#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a>). The fractions are simply the ratios of how many initial conditions ended up at each attractor.</p><p>Initial conditions to use are defined by <code>ics</code>. It can be:</p><ul><li>a <code>StateSpaceSet</code> of initial conditions, in which case all are used.</li><li>a 0-argument function <code>ics()</code> that spits out random initial conditions. Then <code>N</code> random initial conditions are chosen. See <a href="#StateSpaceSets.statespace_sampler"><code>statespace_sampler</code></a> to generate such functions.</li></ul><p><strong>Return</strong></p><p>The function will always return <code>fractions</code>, which is a dictionary whose keys are the labels given to each attractor (always integers enumerating the different attractors), and whose values are the respective basins fractions. The label <code>-1</code> is given to any initial condition where <code>mapper</code> could not match to an attractor (this depends on the <code>mapper</code> type).</p><p>If <code>ics</code> is a <code>StateSpaceSet</code> the function will also return <code>labels</code>, which is <em>vector</em>, of equal length to <code>ics</code>, that contains the label each initial condition was mapped to.</p><p>See <a href="../attractors/#Attractors.AttractorMapper"><code>AttractorMapper</code></a> for all possible <code>mapper</code> types, and use <a href="#Attractors.extract_attractors"><code>extract_attractors</code></a> (after calling <code>basins_fractions</code>) to extract the stored attractors from the <code>mapper</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>N = 1000</code>: Number of random initial conditions to generate in case <code>ics</code> is a function.</li><li><code>show_progress = true</code>: Display a progress bar of the process.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/0d09c82d5cbf95dfcfd06d0124f41fb37454b6a2/src/mapping/attractor_mapping.jl#L56-L94">source</a></section><section><div><pre><code class="nohighlight hljs">basins_fractions(basins::AbstractArray) → fs::Dict</code></pre><p>Calculate the state space fraction of the basins of attraction encoded in <code>basins</code>. The elements of <code>basins</code> are integers, enumerating the attractor that the entry of <code>basins</code> converges to (i.e., like the output of <a href="#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>). Return a dictionary that maps attractor IDs to their relative fractions.</p><p>In<sup class="footnote-reference"><a id="citeref-Menck2013" href="#footnote-Menck2013">[Menck2013]</a></sup> the authors use these fractions to quantify the stability of a basin of attraction, and specifically how it changes when a parameter is changed. For this, see <a href="../continuation/#Attractors.continuation"><code>continuation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/0d09c82d5cbf95dfcfd06d0124f41fb37454b6a2/src/basins/basins_utilities.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Attractors.extract_attractors" href="#Attractors.extract_attractors"><code>Attractors.extract_attractors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_attractors(mapper::AttractorsMapper) → attractors</code></pre><p>Return a dictionary mapping label IDs to attractors found by the <code>mapper</code>. This function should be called after calling <a href="#Attractors.basins_fractions"><code>basins_fractions</code></a> with the given <code>mapper</code> so that the attractors have actually been found first.</p><p>For <code>AttractorsViaFeaturizing</code>, the attractors are only stored if the mapper was called with pre-defined initial conditions rather than a sampler (function returning initial conditions).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/0d09c82d5cbf95dfcfd06d0124f41fb37454b6a2/src/mapping/attractor_mapping.jl#L128-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Attractors.basins_of_attraction" href="#Attractors.basins_of_attraction"><code>Attractors.basins_of_attraction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basins_of_attraction(mapper::AttractorMapper, grid::Tuple) → basins, attractors</code></pre><p>Compute the full basins of attraction as identified by the given <code>mapper</code>, which includes a reference to a <a href="@ref"><code>GeneralizedDynamicalSystem</code></a> and return them along with (perhaps approximated) found attractors.</p><p><code>grid</code> is a tuple of ranges defining the grid of initial conditions that partition the state space into boxes with size the step size of each range. For example, <code>grid = (xg, yg)</code> where <code>xg = yg = range(-5, 5; length = 100)</code>. The grid has to be the same dimensionality as the state space expected by the integrator/system used in <code>mapper</code>. E.g., a <a href="@ref"><code>projected_integrator</code></a> could be used for lower dimensional projections, etc. A special case here is a <a href="@ref"><code>poincaremap</code></a> with <code>plane</code> being <code>Tuple{Int, &lt;: Real}</code>. In this special scenario the grid can be one dimension smaller than the state space, in which case the partitioning happens directly on the hyperplane the Poincaré map operates on.</p><p><code>basins_of_attraction</code> function is a convenience 5-lines-of-code wrapper which uses the <code>labels</code> returned by <a href="#Attractors.basins_fractions"><code>basins_fractions</code></a> and simply assings them to a full array corresponding to the state space partitioning indicated by <code>grid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/0d09c82d5cbf95dfcfd06d0124f41fb37454b6a2/src/mapping/attractor_mapping.jl#L145-L164">source</a></section><section><div><pre><code class="nohighlight hljs">basins_of_attraction(mapper::AttractorsViaRecurrences; show_progress = true)</code></pre><p>This is a special method of <code>basins_of_attraction</code> that using recurrences does <em>exactly</em> what is described in the paper by Datseris &amp; Wagemakers<sup class="footnote-reference"><a id="citeref-Datseris2022" href="#footnote-Datseris2022">[Datseris2022]</a></sup>. By enforcing that the internal grid of <code>mapper</code> is the same as the grid of initial conditions to map to attractors, the method can further utilize found exit and attraction basins, making the computation faster as the grid is processed more and more.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/0d09c82d5cbf95dfcfd06d0124f41fb37454b6a2/src/mapping/attractor_mapping_recurrences.jl#L148-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.statespace_sampler" href="#StateSpaceSets.statespace_sampler"><code>StateSpaceSets.statespace_sampler</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">statespace_sampler(rng = Random.GLOBAL_RNG; kwargs...) → sampler, isinside</code></pre><p>Convenience function that creates two functions. <code>sampler</code> is a 0-argument function that generates random points inside a state space region defined by the keywords. <code>isinside</code> is a 1-argument function that decides returns <code>true</code> if the given state space point is inside that region.</p><p>The regions can be:</p><ul><li><strong>Rectangular box</strong>, with edges <code>min_bounds</code> and <code>max_bounds</code>. The sampling of the points inside the box is decided by the keyword <code>method</code> which can be either <code>&quot;uniform&quot;</code> or <code>&quot;multgauss&quot;</code>.</li><li><strong>Sphere</strong>, of <code>spheredims</code> dimensions, radius <code>radius</code> and centered on <code>center</code>.</li></ul></div></section><section><div><pre><code class="nohighlight hljs">statespace_sampler(grid::NTuple{N, AbstractRange} [, rng])</code></pre><p>If given a <code>grid</code> that is a tuple of ranges, the minimum and maximum of the ranges are used as the <code>min_bounds</code> and <code>max_bounds</code> keywords.</p></div></section></article><h2 id="Final-state-sensitivity-/-fractal-boundaries"><a class="docs-heading-anchor" href="#Final-state-sensitivity-/-fractal-boundaries">Final state sensitivity / fractal boundaries</a><a id="Final-state-sensitivity-/-fractal-boundaries-1"></a><a class="docs-heading-anchor-permalink" href="#Final-state-sensitivity-/-fractal-boundaries" title="Permalink"></a></h2><p>Several functions are provided related with analyzing the fractality of the boundaries of the basins of attraction:</p><ul><li><a href="#Attractors.basins_fractal_dimension"><code>basins_fractal_dimension</code></a></li><li><a href="#Attractors.basin_entropy"><code>basin_entropy</code></a></li><li><a href="#Attractors.basins_fractal_test"><code>basins_fractal_test</code></a></li><li><a href="#Attractors.uncertainty_exponent"><code>uncertainty_exponent</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Attractors.basins_fractal_dimension" href="#Attractors.basins_fractal_dimension"><code>Attractors.basins_fractal_dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basins_fractal_dimension(basins; kwargs...) -&gt; V_ε, N_ε ,d</code></pre><p>Estimate the <a href="@ref">Fractal Dimension</a> <code>d</code> of the boundary between basins of attraction using the box-counting algorithm.</p><p>The output <code>N_ε</code> is a vector with the number of the balls of radius <code>ε</code> (in pixels) that contain at least two initial conditions that lead to different attractors. <code>V_ε</code> is a vector with the corresponding size of the balls. The ouput <code>d</code> is the estimation of the box-counting dimension of the boundary by fitting a line in the <code>log.(N_ε)</code> vs <code>log.(1/V_ε)</code> curve. However it is recommended to analyze the curve directly for more accuracy.</p><p><strong>Keyword arguments</strong></p><ul><li><code>range_ε = 2:maximum(size(basins))÷20</code> is the range of sizes of the ball to test (in pixels).</li></ul><p><strong>Description</strong></p><p>It is the implementation of the popular algorithm of the estimation of the box-counting dimension. The algorithm search for a covering the boundary with <code>N_ε</code> boxes of size <code>ε</code> in pixels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/0d09c82d5cbf95dfcfd06d0124f41fb37454b6a2/src/basins/fractality_of_basins.jl#L145-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Attractors.basin_entropy" href="#Attractors.basin_entropy"><code>Attractors.basin_entropy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basin_entropy(basins, ε = 20) -&gt; Sb, Sbb</code></pre><p>This algorithm computes the basin entropy <code>Sb</code> of the basins of attraction. First, the input <code>basins</code> is divided regularly into n-dimensional boxes of side <code>ε</code> (along all dimensions). Then <code>Sb</code> is simply the average of the Gibbs entropy computed over these boxes. The function returns the basin entropy <code>Sb</code> as well as the boundary basin entropy <code>Sbb</code>. The later is the average of the entropy only for boxes that contains at least two different basins, that is, for the boxes on the boundary.</p><p>The basin entropy is a measure of the uncertainty on the initial conditions of the basins. It is maximum at the value <code>log(n_att)</code> being <code>n_att</code> the number of attractors. In this case the boundary is intermingled: for a given initial condition we can find another initial condition that lead to another basin arbitriraly close. It provides also a simple criterion for fractality: if the boundary basin entropy <code>Sbb</code> is above <code>log(2)</code> then we have a fractal boundary. It doesn&#39;t mean that basins with values below cannot have a fractal boundary, for a more precise test see <a href="#Attractors.basins_fractal_test"><code>basins_fractal_test</code></a>. An important feature of the basin entropy is that it allows comparisons between different basins using the same box size <code>ε</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/0d09c82d5cbf95dfcfd06d0124f41fb37454b6a2/src/basins/fractality_of_basins.jl#L3-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Attractors.basins_fractal_test" href="#Attractors.basins_fractal_test"><code>Attractors.basins_fractal_test</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basins_fractal_test(basins; ε = 20, Ntotal = 1000) -&gt; test_res, Sbb</code></pre><p>This is an automated test to decide if the boundary of the basins has fractal structures. The bottom line is to look at the basins with a magnifier of size <code>ε</code> at random in <code>basins</code>. If what we see in the magnifier looks like a smooth boundary (in average) we decide that the boundary is smooth. If it is not smooth we can say that at the scale <code>ε</code> we have structures, i.e., it is fractal.</p><p>In practice the algorithm computes the boundary basin entropy <code>Sbb</code> <a href="#Attractors.basin_entropy"><code>basin_entropy</code></a> for <code>Ntotal</code> random balls of radius <code>ε</code>. If the computed value is equal to theoretical value of a smooth boundary (taking into account statistical errors and biases) then we decide that we have a smooth boundary. Notice that the response <code>test_res</code> may depend on the chosen ball radius <code>ε</code>. For larger size, we may observe structures for smooth boundary and we obtain a <em>different</em> answer.</p><p>The output <code>test_res</code> is a symbol describing the nature of the basin and the output <code>Sbb</code> is the estimated value of the boundary basin entropy with the sampling method.</p><p><sup class="footnote-reference"><a id="citeref-Puy2021" href="#footnote-Puy2021">[Puy2021]</a></sup> Andreu Puy, Alvar Daza, Alexandre Wagemakers, Miguel A. F. Sanjuán. A test for fractal boundaries based on the basin entropy. Commun Nonlinear Sci Numer Simulat, 95, 105588, 2021.</p><p><strong>Keyword arguments</strong></p><ul><li><code>ε = 20</code>: size of the ball for the test of basin. The result of the test may change with the size.</li><li><code>Ntotal = 1000</code>: number of balls to test in the boundary for the computation of <code>Sbb</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/0d09c82d5cbf95dfcfd06d0124f41fb37454b6a2/src/basins/fractality_of_basins.jl#L58-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Attractors.uncertainty_exponent" href="#Attractors.uncertainty_exponent"><code>Attractors.uncertainty_exponent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">uncertainty_exponent(basins; kwargs...) -&gt; ε, N_ε ,α</code></pre><p>Estimate the uncertainty exponent<sup class="footnote-reference"><a id="citeref-Grebogi1983" href="#footnote-Grebogi1983">[Grebogi1983]</a></sup> of the basins of attraction. This exponent is related to the final state sensitivity of the trajectories in the phase space. An exponent close to <code>1</code> means basins with smooth boundaries whereas an exponent close to <code>0</code> represent completely fractalized basins, also called riddled basins.</p><p>The output <code>N_ε</code> is a vector with the number of the balls of radius <code>ε</code> (in pixels) that contain at least two initial conditions that lead to different attractors. The ouput <code>α</code> is the estimation of the uncertainty exponent using the box-counting dimension of the boundary by fitting a line in the <code>log.(N_ε)</code> vs <code>log.(1/ε)</code> curve. However it is recommended to analyze the curve directly for more accuracy.</p><p><strong>Keyword arguments</strong></p><ul><li><code>range_ε = 2:maximum(size(basins))÷20</code> is the range of sizes of the ball to test (in pixels).</li></ul><p><strong>Description</strong></p><p>A phase space with a fractal boundary may cause a uncertainty on the final state of the dynamical system for a given initial condition. A measure of this final state sensitivity is the uncertainty exponent. The algorithm probes the basin of attraction with balls of size <code>ε</code> at random. If there are a least two initial conditions that lead to different attractors, a ball is tagged &quot;uncertain&quot;. <code>f_ε</code> is the fraction of &quot;uncertain balls&quot; to the total number of tries in the basin. In analogy to the fractal dimension, there is a scaling law between, <code>f_ε ~ ε^α</code>. The number that characterizes this scaling is called the uncertainty exponent <code>α</code>.</p><p>Notice that the uncertainty exponent and the box counting dimension of the boundary are related. We have <code>Δ₀ = D - α</code> where <code>Δ₀</code> is the box counting dimension computed with <a href="#Attractors.basins_fractal_dimension"><code>basins_fractal_dimension</code></a> and <code>D</code> is the dimension of the phase space. The algorithm first estimates the box counting dimension of the boundary and returns the uncertainty exponent.</p><p>An obstruction to predictability, Physics Letters A, 99, 9, 1983</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/0d09c82d5cbf95dfcfd06d0124f41fb37454b6a2/src/basins/fractality_of_basins.jl#L204-L240">source</a></section></article><h2 id="Tipping-points"><a class="docs-heading-anchor" href="#Tipping-points">Tipping points</a><a id="Tipping-points-1"></a><a class="docs-heading-anchor-permalink" href="#Tipping-points" title="Permalink"></a></h2><p>This page discusses functionality related with tipping points in dynamical systems with known rule. If instead you are interested in identifying tipping points in measured timeseries, have a look at <a href="https://github.com/JuliaDynamics/TransitionIndicators.jl">TransitionIndicators.jl</a>.</p><article class="docstring"><header><a class="docstring-binding" id="Attractors.tipping_probabilities" href="#Attractors.tipping_probabilities"><code>Attractors.tipping_probabilities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tipping_probabilities(basins_before, basins_after) → P</code></pre><p>Return the tipping probabilities of the computed basins before and after a change in the system parameters (or time forcing), according to the definition of<sup class="footnote-reference"><a id="citeref-Kaszás2019" href="#footnote-Kaszás2019">[Kaszás2019]</a></sup>.</p><p>The input <code>basins</code> are integer-valued arrays, where the integers enumerate the attractor, e.g. the output of <a href="#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>.</p><p><strong>Description</strong></p><p>Let <span>$\mathcal{B}_i(p)$</span> denote the basin of attraction of attractor <span>$A_i$</span> at parameter(s) <span>$p$</span>. Kaszás et al<sup class="footnote-reference"><a id="citeref-Kaszás2019" href="#footnote-Kaszás2019">[Kaszás2019]</a></sup> define the tipping probability from <span>$A_i$</span> to <span>$A_j$</span>, given a parameter change in the system of <span>$p_- \to p_+$</span>, as</p><p class="math-container">\[P(A_i \to A_j | p_- \to p_+) =
\frac{|\mathcal{B}_j(p_+) \cap \mathcal{B}_i(p_-)|}{|\mathcal{B}_i(p_-)|}\]</p><p>where <span>$|\cdot|$</span> is simply the volume of the enclosed set. The value of <span>$P(A_i \to A_j | p_- \to p_+)$</span> is <code>P[i, j]</code>. The equation describes something quite simple: what is the overlap of the basin of attraction of <span>$A_i$</span> at <span>$p_-$</span> with that of the attractor <span>$A_j$</span> at <span>$p_+$</span>. If <code>basins_before, basins_after</code> contain values of <code>-1</code>, corresponding to trajectories that diverge, this is considered as the last attractor of the system in <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/0d09c82d5cbf95dfcfd06d0124f41fb37454b6a2/src/basins/tipping_probabilities.jl#L3-L30">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Menck2013"><a class="tag is-link" href="#citeref-Menck2013">Menck2013</a>Menck, Heitzig, Marwan &amp; Kurths. How basin stability complements the linear stability paradigm. <a href="https://doi.org/10.1038/nphys2516">Nature Physics, 9(2), 89–92</a></li><li class="footnote" id="footnote-Datseris2022"><a class="tag is-link" href="#citeref-Datseris2022">Datseris2022</a>G. Datseris and A. Wagemakers, <em>Effortless estimation of basins of attraction</em>, <a href="https://doi.org/10.1063/5.0076568">Chaos 32, 023104 (2022)</a></li><li class="footnote" id="footnote-Daza2016"><a class="tag is-link" href="#citeref-Daza2016">Daza2016</a>A. Daza, A. Wagemakers, B. Georgeot, D. Guéry-Odelin and M. A. F. Sanjuán, Basin entropy: a new tool to analyze uncertainty in dynamical systems, Sci. Rep., 6, 31416, 2016.</li><li class="footnote" id="footnote-Grebogi1983"><a class="tag is-link" href="#citeref-Grebogi1983">Grebogi1983</a>C. Grebogi, S. W. McDonald, E. Ott and J. A. Yorke, Final state sensitivity:</li><li class="footnote" id="footnote-Kaszás2019"><a class="tag is-link" href="#citeref-Kaszás2019">Kaszás2019</a>Kaszás, Feudel &amp; Tél. Tipping phenomena in typical dynamical systems subjected to parameter drift. <a href="https://doi.org/10.1038/s41598-019-44863-3">Scientific Reports, 9(1)</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../attractors/">« Finding Attractors</a><a class="docs-footer-nextpage" href="../continuation/">Attractor &amp; Basins Continuation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 24 April 2023 13:08">Monday 24 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
