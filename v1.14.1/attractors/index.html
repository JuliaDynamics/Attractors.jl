<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Finding Attractors · Attractors.jl</title><meta name="title" content="Finding Attractors · Attractors.jl"/><meta property="og:title" content="Finding Attractors · Attractors.jl"/><meta property="twitter:title" content="Finding Attractors · Attractors.jl"/><meta name="description" content="Documentation for Attractors.jl."/><meta property="og:description" content="Documentation for Attractors.jl."/><meta property="twitter:description" content="Documentation for Attractors.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Attractors.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Attractors.jl</a></li><li><a class="tocitem" href="../dynsysref/"><code>DynamicalSystem</code> reference</a></li><li class="is-active"><a class="tocitem" href>Finding Attractors</a><ul class="internal"><li><a class="tocitem" href="#Recurrences"><span>Recurrences</span></a></li><li><a class="tocitem" href="#Proximity"><span>Proximity</span></a></li><li><a class="tocitem" href="#Featurizing"><span>Featurizing</span></a></li><li><a class="tocitem" href="#Grouping-configurations"><span>Grouping configurations</span></a></li></ul></li><li><a class="tocitem" href="../basins/">Basins of Attraction</a></li><li><a class="tocitem" href="../continuation/">Attractor &amp; Basins Continuation</a></li><li><a class="tocitem" href="../visualization/">Visualization utilities</a></li><li><a class="tocitem" href="../examples/">Examples for Attractors.jl</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Finding Attractors</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Finding Attractors</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Attractors.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Attractors.jl/blob/main/docs/src/attractors.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Finding-Attractors"><a class="docs-heading-anchor" href="#Finding-Attractors">Finding Attractors</a><a id="Finding-Attractors-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-Attractors" title="Permalink"></a></h1><p>Attractors.jl defines a generic interface for finding attractors of dynamical systems. One first decides the instance of <a href="../dynsysref/#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a> they need. Then, an instance of <a href="#Attractors.AttractorMapper"><code>AttractorMapper</code></a> is created from this dynamical system. This <code>mapper</code> instance can be used to compute e.g., <a href="../basins/#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>, and the output can be further analyzed to get e.g., the <a href="../basins/#Attractors.basin_entropy"><code>basin_entropy</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.AttractorMapper" href="#Attractors.AttractorMapper"><code>Attractors.AttractorMapper</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AttractorMapper(ds::DynamicalSystem, args...; kwargs...) → mapper</code></pre><p>Subtypes of <code>AttractorMapper</code> are structures that map initial conditions of <code>ds</code> to attractors. Currently available mapping methods:</p><ul><li><a href="#Attractors.AttractorsViaProximity"><code>AttractorsViaProximity</code></a></li><li><a href="#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a></li><li><a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a></li></ul><p>All <code>AttractorMapper</code> subtypes can be used with <a href="../basins/#Attractors.basins_fractions"><code>basins_fractions</code></a> or <a href="../basins/#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>.</p><p>In addition, some mappers can be called as a function of an initial condition:</p><pre><code class="language-julia hljs">label = mapper(u0)</code></pre><p>and this will on the fly compute and return the label of the attractor <code>u0</code> converges at. The mappers that can do this are:</p><ul><li><a href="#Attractors.AttractorsViaProximity"><code>AttractorsViaProximity</code></a></li><li><a href="#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a></li><li><a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a> with the <a href="#Attractors.GroupViaHistogram"><code>GroupViaHistogram</code></a> configuration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/mapping/attractor_mapping.jl#L21-L43">source</a></section></article><h2 id="Recurrences"><a class="docs-heading-anchor" href="#Recurrences">Recurrences</a><a id="Recurrences-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrences" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.AttractorsViaRecurrences" href="#Attractors.AttractorsViaRecurrences"><code>Attractors.AttractorsViaRecurrences</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AttractorsViaRecurrences(ds::DynamicalSystem, grid; kwargs...)</code></pre><p>Map initial conditions of <code>ds</code> to attractors by identifying attractors on the fly based on recurrences in the state space, as outlined in (<a href="../references/#Datseris2022">Datseris and Wagemakers, 2022</a>). However, the Description section below for has a more accurate (and simpler) exposition to the algorithm than the paper.</p><p><code>grid</code> is instructions for partitioning the state space into finite-sized cells so that a finite state machine can operate on top of it. Possibilities are:</p><ol><li>A tuple of sorted <code>AbstractRange</code>s for a regular grid.</li></ol><p>Example is <code>grid = (xg, yg)</code> where <code>xg = yg = range(-5, 5; length = 100)</code>   for a two-dimensional system.</p><ol><li>A tuple of sorted <code>AbstractVector</code>s for an irregular grid, for example</li></ol><p><code>grid = (xg, yg)</code> with <code>xg = range(0, 10.0^(1/2); length = 200).^2,   yg = range(-5, 5; length = 100)</code>.</p><ol><li>An instance of the special grid type</li></ol><p><a href="#Attractors.SubdivisionBasedGrid"><code>SubdivisionBasedGrid</code></a>, which can be created either manually or by using   <a href="#Attractors.subdivision_based_grid"><code>subdivision_based_grid</code></a>.   This automatically analyzes and adapts grid discretization   levels in accordance with state space flow speed in different regions.</p><p>The grid has to be the same dimensionality as the state space, use a <a href="../dynsysref/#DynamicalSystemsBase.ProjectedDynamicalSystem"><code>ProjectedDynamicalSystem</code></a> if you want to search for attractors in a lower dimensional subspace.</p><p><strong>Keyword arguments</strong></p><ul><li><code>sparse = true</code>: control the storage type of the state space grid. If true,  uses a sparse array, whose memory usage is in general more efficient than a regular  array obtained with <code>sparse=false</code>. In practice, the sparse representation should  always be preferred when searching for <a href="../basins/#Attractors.basins_fractions"><code>basins_fractions</code></a>. Only for very low  dimensional systems and for computing the full <a href="../basins/#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a> the  non-sparse version should be used.</li></ul><p><strong>Time evolution configuration</strong></p><ul><li><code>Ttr = 0</code>: Skip a transient before the recurrence routine begins.</li><li><code>Δt</code>: Approximate integration time step (second argument of the <code>step!</code> function). The keyword <code>Dt</code> can also be used instead if <code>Δ</code> (<code>\Delta</code>) is not accessible. It is <code>1</code> for discrete time systems. For continuous systems, an automatic value is calculated using <a href="#Attractors.automatic_Δt_basins"><code>automatic_Δt_basins</code></a>. For very fine grids, this can become very small, much smaller than the typical integrator internal step size in case of adaptive integrators. In such cases, use <code>force_non_adaptive = true</code>.</li><li><code>force_non_adaptive = false</code>: Only used if the input dynamical system is <code>CoupledODEs</code>. If <code>true</code> the additional keywords <code>adaptive = false, dt = Δt</code> are given as <code>diffeq</code> to the <code>CoupledODEs</code>. This means that adaptive integration is turned off and <code>Δt</code> is used as the ODE integrator timestep. This is useful in (1) very fine grids, and (2) if some of the attractors are limit cycles. We have noticed that in this case the integrator timestep becomes commensurate with the limit cycle period, leading to incorrectly counting the limit cycle as more than one attractor.</li></ul><p><strong>Finite state machine configuration</strong></p><ul><li><code>consecutive_recurrences = 100</code>: Number of consecutive visits to previously visited unlabeled cells (i.e., recurrences) required before declaring we have converged to a new attractor. This number tunes the accuracy of converging to attractors and should generally be high (and even higher for chaotic systems).</li><li><code>attractor_locate_steps = 1000</code>: Number of subsequent steps taken to locate accurately the new attractor after the convergence phase is over. Once <code>attractor_locate_steps</code> steps have been taken, the new attractor has been identified with sufficient accuracy and iteration stops. This number can be very high without much impact to overall performance.</li><li><code>store_once_per_cell = true</code>: Control if multiple points in state space that belong to the same cell are stored or not in the attractor, when a new attractor is found. If <code>true</code>, each visited cell will only store a point once, which is desirable for fixed points and limit cycles. If <code>false</code> then <code>attractor_locate_steps</code> points are stored per attractor, leading to more densely stored attractors, which may be desirable for instance in chaotic attractors.</li><li><code>consecutive_attractor_steps = 2</code>: Μaximum checks of consecutives hits of an existing attractor cell before declaring convergence to that existing attractor.</li><li><code>consecutive_basin_steps = 10</code>: Number of consecutive visits of the same basin of attraction required before declaring convergence to an existing attractor. This is ignored if <code>sparse = true</code>, as basins are not stored internally in that case.</li><li><code>consecutive_lost_steps = 20</code>: Maximum check of iterations outside the defined grid before we declare the orbit lost outside and hence assign it label <code>-1</code>.</li><li><code>horizon_limit = 1e6</code>: If the norm of the integrator state reaches this limit we declare that the orbit diverged to infinity.</li><li><code>maximum_iterations = Int(1e6)</code>: A safety counter that is always increasing for each initial condition. Once exceeded, the algorithm assigns <code>-1</code> and throws a warning. This clause exists to stop the algorithm never halting for inappropriate grids. It may happen when a newly found attractor orbit intersects in the same cell of a previously found attractor (which leads to infinite resetting of all counters).</li></ul><p><strong>Description</strong></p><p>An initial condition given to an instance of <code>AttractorsViaRecurrences</code> is iterated based on the integrator corresponding to <code>ds</code>. Enough recurrences in the state space (i.e., a trajectory visited a region it has visited before) means that the trajectory has converged to an attractor. This is the basis for finding attractors.</p><p>A finite state machine (FSM) follows the trajectory in the state space, and constantly maps it to a cell in the given <code>grid</code>. The grid cells store information: they are empty, visited, basins, or attractor cells. The state of the FSM is decided based on the cell type and the previous state of the FSM. Whenever the FSM recurs its state, its internal counter is increased, otherwise it is reset to 0. Once the internal counter reaches a threshold, the FSM terminates or changes its state. The possibilities for termination are the following:</p><ul><li>The trajectory hits <code>consecutive_recurrences</code> times in a row previously visited cells:  it is considered that an attractor is found and is labelled with a new ID. Then,  iteration continues for <code>attractor_locate_steps</code> steps. Each cell visited in this period stores  the &quot;attractor&quot; information. Then iteration terminates and the initial condition is  numbered with the attractor&#39;s ID.</li><li>The trajectory hits an already identified attractor <code>consecutive_attractor_steps</code> consecutive times:  the initial condition is numbered with the attractor&#39;s basin ID.</li><li>The trajectory hits a known basin <code>consecutive_basin_steps</code> times in a row: the initial condition  belongs to that basin and is numbered accordingly. Notice that basins are stored and  used only when <code>sparse = false</code> otherwise this clause is ignored.</li><li>The trajectory spends <code>consecutive_lost_steps</code> steps outside the defined grid or the norm  of the dynamical system state becomes &gt; than <code>horizon_limit</code>: the initial  condition is labelled <code>-1</code>.</li><li>If none of the above happens, the initial condition is labelled <code>-1</code> after  <code>maximum_iterations</code> steps.</li></ul><p>There are some special internal optimizations and details that we do not describe here but can be found in comments in the source code. (E.g., a special timer exists for the &quot;lost&quot; state which does not interrupt the main timer of the FSM.)</p><p>A video illustrating how the algorithm works can be found in the online Examples page.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/mapping/recurrences/attractor_mapping_recurrences.jl#L4-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.automatic_Δt_basins" href="#Attractors.automatic_Δt_basins"><code>Attractors.automatic_Δt_basins</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">automatic_Δt_basins(ds::DynamicalSystem, grid; N = 5000) → Δt</code></pre><p>Calculate an optimal <code>Δt</code> value for <a href="../basins/#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>. This is done by evaluating the dynamic rule <code>f</code> (vector field) at <code>N</code> randomly chosen points within the bounding box of the grid. The average <code>f</code> is then compared with the average diagonal length of a grid cell and their ratio provides <code>Δt</code>.</p><p>Notice that <code>Δt</code> should not be too small which happens typically if the grid resolution is high. It is okay if the trajectory skips a few cells. Also, <code>Δt</code> that is smaller than the internal step size of the integrator will cause a performance drop.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/mapping/recurrences/attractor_mapping_recurrences.jl#L294-L307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.SubdivisionBasedGrid" href="#Attractors.SubdivisionBasedGrid"><code>Attractors.SubdivisionBasedGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SubdivisionBasedGrid(grid::NTuple{D, &lt;:AbstractRange}, lvl_array::Array{Int, D})</code></pre><p>Given a coarse <code>grid</code> tesselating the state space, construct a <code>SubdivisionBasedGrid</code> based on the given level array <code>lvl_array</code> that should have the same dimension as <code>grid</code>. The level array has non-negative integer values, with 0 meaning that the corresponding cell of the coarse <code>grid</code> should not be subdivided any further. Value <code>n &gt; 0</code> means that the corresponding cell will be subdivided in total <code>2^n</code> times (along each dimension), resulting in finer cells within the original coarse cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/mapping/recurrences/grids.jl#L34-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.subdivision_based_grid" href="#Attractors.subdivision_based_grid"><code>Attractors.subdivision_based_grid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">subdivision_based_grid(ds::DynamicalSystem, grid; maxlevel = 4, q = 0.99)</code></pre><p>Construct a grid structure <a href="#Attractors.SubdivisionBasedGrid"><code>SubdivisionBasedGrid</code></a> that can be directly passed as a grid to <a href="#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a>. The input <code>grid</code> is an originally coarse grid (a tuple of <code>AbstractRange</code>s). The state space speed is evaluate in all cells of the <code>grid</code>. Cells with small speed (when compared to the &quot;max&quot; speed) resultin in this cell being subdivided more. To avoid problems with spikes in the speed, the <code>q</code>-th quantile of the velocities is used as the &quot;max&quot; speed (use <code>q = 1</code> for true maximum). The subdivisions in the resulting grid are clamped to at most value <code>maxlevel</code>.</p><p>This approach is designed for <em>continuous time</em> systems in which different areas of the state space flow may have significantly different velocity. In case of originally coarse grids, this may lead <a href="#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a> being stuck in some state space regions with a small motion speed and false identification of attractors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/mapping/recurrences/grids.jl#L56-L73">source</a></section></article><h2 id="Proximity"><a class="docs-heading-anchor" href="#Proximity">Proximity</a><a id="Proximity-1"></a><a class="docs-heading-anchor-permalink" href="#Proximity" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.AttractorsViaProximity" href="#Attractors.AttractorsViaProximity"><code>Attractors.AttractorsViaProximity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AttractorsViaProximity(ds::DynamicalSystem, attractors::Dict [, ε]; kwargs...)</code></pre><p>Map initial conditions to attractors based on whether the trajectory reaches <code>ε</code>-distance close to any of the user-provided <code>attractors</code>. They have to be in a form of a dictionary mapping attractor labels to <code>StateSpaceSet</code>s containing the attractors.</p><p>The system gets stepped, and at each step the minimum distance to all attractors is computed. If any of these distances is <code>&lt; ε</code>, then the label of the nearest attractor is returned.</p><p>If an <code>ε::Real</code> is not provided by the user, a value is computed automatically as half of the minimum distance between all attractors. This operation can be expensive for large <code>StateSpaceSet</code>s. If <code>length(attractors) == 1</code>, then <code>ε</code> becomes 1/10 of the diagonal of the box containing the attractor. If <code>length(attractors) == 1</code> and the attractor is a single point, an error is thrown.</p><p><strong>Keywords</strong></p><ul><li><code>Ttr = 100</code>: Transient time to first evolve the system for before checking for proximity.</li><li><code>Δt = 1</code>: Step time given to <code>step!</code>.</li><li><code>horizon_limit = 1e3</code>: If the maximum distance of the trajectory from any of the given attractors exceeds this limit, it is assumed that the trajectory diverged (gets labelled as <code>-1</code>).</li><li><code>consecutive_lost_steps = 1000</code>: If the integrator has been stepped this many times without coming <code>ε</code>-near to any attractor,  it is assumed that the trajectory diverged (gets labelled as <code>-1</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/mapping/attractor_mapping_proximity.jl#L1-L29">source</a></section></article><h2 id="Featurizing"><a class="docs-heading-anchor" href="#Featurizing">Featurizing</a><a id="Featurizing-1"></a><a class="docs-heading-anchor-permalink" href="#Featurizing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.AttractorsViaFeaturizing" href="#Attractors.AttractorsViaFeaturizing"><code>Attractors.AttractorsViaFeaturizing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AttractorsViaFeaturizing(
    ds::DynamicalSystem, featurizer::Function,
    grouping_config = GroupViaClustering(); kwargs...
)</code></pre><p>Initialize a <code>mapper</code> that maps initial conditions to attractors using a featurizing and grouping approach. This is a supercase of the featurizing and clustering approach that is utilized by bSTAB (<a href="../references/#Stender2021">Stender and Hoffmann, 2021</a>) and MCBB (<a href="../references/#Gelbrecht2020">Gelbrecht <em>et al.</em>, 2020</a>). See <a href="#Attractors.AttractorMapper"><code>AttractorMapper</code></a> for how to use the <code>mapper</code>. This <code>mapper</code> also allows the syntax <code>mapper(u0)</code> but only if the <code>grouping_config</code> is <em>not</em> <code>GroupViaClustering</code>.</p><p><code>featurizer</code> is a function <code>f(A, t) that takes as an input an integrated trajectory</code>A::StateSpaceSet<code>and the corresponding time vector</code>t<code>and returns a vector</code>v<code>of features describing the trajectory. For better performance, it is strongly recommended that</code>v  isa SVector{&lt;:Real}`.</p><p><code>grouping_config</code> is an instance of any subtype of <a href="#Attractors.GroupingConfig"><code>GroupingConfig</code></a> and decides how features will be grouped into attractors, see below.</p><p>See also the intermediate functions <a href="#Attractors.extract_features"><code>extract_features</code></a> and <a href="#Attractors.group_features"><code>group_features</code></a>, which can be utilized when wanting to work directly with features.</p><p><strong>Keyword arguments</strong></p><ul><li><code>T=100, Ttr=100, Δt=1</code>: Propagated to <a href="@ref"><code>trajectory</code></a>.</li><li><code>threaded = true</code>: Whether to run the generation of features over threads by integrating trajectories in parallel.</li></ul><p><strong>Description</strong></p><p>The trajectory <code>X</code> of an initial condition is transformed into features. Each feature is a number useful in <em>characterizing the attractor</em> the initial condition ends up at, and distinguishing it from other attractors. Example features are the mean or standard deviation of some the dimensions of the trajectory, the entropy of some of the dimensions, the fractal dimension of <code>X</code>, or anything else you may fancy.</p><p>All feature vectors (each initial condition = 1 vector) are then grouped using one of the sevaral available grouping configurations. Each group is assumed to be a unique attractor, and hence each initial condition is labelled according to the group it is part of. The method thus relies on the user having at least some basic idea about what attractors to expect in order to pick the right features, and the right way to group them, in contrast to <a href="#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/mapping/grouping/attractor_mapping_featurizing.jl#L22-L66">source</a></section></article><h2 id="Grouping-configurations"><a class="docs-heading-anchor" href="#Grouping-configurations">Grouping configurations</a><a id="Grouping-configurations-1"></a><a class="docs-heading-anchor-permalink" href="#Grouping-configurations" title="Permalink"></a></h2><h3 id="Grouping-types"><a class="docs-heading-anchor" href="#Grouping-types">Grouping types</a><a id="Grouping-types-1"></a><a class="docs-heading-anchor-permalink" href="#Grouping-types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.GroupingConfig" href="#Attractors.GroupingConfig"><code>Attractors.GroupingConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><p>GroupingConfig</p><p>Supertype for configuration structs on how to group features together. Used in several occasions such as <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a> or <a href="../continuation/#Attractors.aggregate_attractor_fractions"><code>aggregate_attractor_fractions</code></a>.</p><p>Currently available grouping configurations are:</p><ul><li><a href="#Attractors.GroupViaClustering"><code>GroupViaClustering</code></a></li><li><a href="#Attractors.GroupViaNearestFeature"><code>GroupViaNearestFeature</code></a></li><li><a href="#Attractors.GroupViaHistogram"><code>GroupViaHistogram</code></a></li><li><a href="#Attractors.GroupViaPairwiseComparison"><code>GroupViaPairwiseComparison</code></a></li></ul><p><code>GroupingConfig</code> defines an extendable interface. The only thing necessary for a new grouping configuration is to:</p><ol><li>Make a new type and subtype <code>GroupingConfig</code>.</li><li>If the grouping allows for mapping individual initial conditions to IDs, then instead extend the <strong>internal function</strong> <code>feature_to_group(feature, config)</code>. This will allow doing <code>id = mapper(u0)</code> with <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a>.</li><li>Else, extend the function <code>group_features(features, config)</code>. You could still extend <code>group_features</code> even if (2.) is satisfied, if there are any performance benefits.</li><li>Include the new grouping file in the <code>grouping/all_grouping_configs.jl</code> and list it in this documentation string.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/mapping/grouping/all_grouping_configs.jl#L3-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.GroupViaClustering" href="#Attractors.GroupViaClustering"><code>Attractors.GroupViaClustering</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GroupViaClustering(; kwargs...)</code></pre><p>Initialize a struct that contains instructions on how to group features in <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a>. <code>GroupViaClustering</code> clusters features into groups using DBSCAN, similar to the original work by bSTAB (<a href="../references/#Stender2021">Stender and Hoffmann, 2021</a>) and MCBB (<a href="../references/#Gelbrecht2020">Gelbrecht <em>et al.</em>, 2020</a>). Several options on clustering are available, see keywords below.</p><p>The defaults are a significant improvement over existing literature, see Description.</p><p><strong>Keyword arguments</strong></p><ul><li><code>clust_distance_metric = Euclidean()</code>: A metric to be used in the clustering. It can be any function <code>f(a, b)</code> that returns the distance between real-valued vectors <code>a, b</code>. All metrics from Distances.jl can be used here.</li><li><code>rescale_features = true</code>: if true, rescale each dimension of the extracted features separately into the range <code>[0,1]</code>. This typically leads to more accurate clustering.</li><li><code>min_neighbors = 10</code>: minimum number of neighbors (i.e. of similar features) each feature needs to have, including counting its own self, in order to be considered in a cluster (fewer than this, it is labeled as an outlier, <code>-1</code>).</li><li><code>use_mmap = false</code>: whether to use an on-disk map for creating the distance matrix of the features. Useful when the features are so many where a matrix with side their length would not fit to memory.</li></ul><p><strong>Keywords for optimal radius estimation</strong></p><ul><li><code>optimal_radius_method::Union{Real, String} = &quot;silhouettes_optim&quot;</code>: if a real number, it is the radius used to cluster features. Otherwise, it determines the method used to automatically determine that radius. Possible values are:<ul><li><code>&quot;silhouettes&quot;</code>: Performs a linear (sequential) search for the radius that maximizes a   statistic of the silhouette values of clusters (typically the mean). This can be chosen   with <code>silhouette_statistic</code>. The linear search may take some time to finish. To   increase speed, the number of radii iterated through can be reduced by decreasing   <code>num_attempts_radius</code> (see its entry below).</li><li><code>&quot;silhouettes_optim&quot;</code>: Same as <code>&quot;silhouettes&quot;</code> but performs an optimized search via   Optim.jl. It&#39;s faster than <code>&quot;silhouettes&quot;</code>, with typically the same accuracy (the   search here is not guaranteed to always find the global maximum, though it typically   gets close).</li><li><code>&quot;knee&quot;</code>: chooses the the radius according to the knee (a.k.a. elbow,   highest-derivative method) and is quicker, though generally leading to much worse   clustering. It requires that <code>min_neighbors</code> &gt; 1.</li></ul></li><li><code>num_attempts_radius = 100</code>: number of radii that the <code>optimal_radius_method</code> will try out in its iterative procedure. Higher values increase the accuracy of clustering, though not necessarily much, while always reducing speed.</li><li><code>silhouette_statistic::Function = mean</code>: statistic (e.g. mean or minimum) of the silhouettes that is maximized in the &quot;optimal&quot; clustering. The original implementation in (<a href="../references/#Stender2021">Stender and Hoffmann, 2021</a>) used the <code>minimum</code> of the silhouettes, and typically performs less accurately than the <code>mean</code>.</li><li><code>max_used_features = 0</code>: if not <code>0</code>, it should be an <code>Int</code> denoting the max amount of features to be used when finding the optimal radius. Useful when clustering a very large number of features (e.g., high accuracy estimation of fractions of basins of attraction).</li></ul><p><strong>Description</strong></p><p>The DBSCAN clustering algorithm is used to automatically identify clusters of similar features. Each feature vector is a point in a feature space. Each cluster then basically groups points that are closely packed together. Closely packed means that the points have at least <code>min_neighbors</code> inside a ball of radius <code>optimal_radius</code> centered on them. This method typically works well if the radius is chosen well, which is not necessarily an easy task. Currently, three methods are implemented to automatically estimate an &quot;optimal&quot; radius.</p><p><strong>Estimating the optimal radius</strong></p><p>The default method is the <strong>silhouettes method</strong>, which includes keywords <code>silhouette</code> and <code>silhouette_optim</code>. Both of them search for the radius that optimizes the clustering, meaning the one that maximizes a statistic <code>silhouette_statistic</code> (e.g. mean value) of a quantifier for the quality of each cluster. This quantifier is the silhouette value of each identified cluster. A silhouette value measures how similar a point is to the cluster it currently belongs to, compared to the other clusters, and ranges from -1 (worst matching) to +1 (ideal matching). If only one cluster is found, the assigned silhouette is zero. So for each attempted radius in the search the clusters are computed, their silhouettes calculated, and the statistic of these silhouettes computed. The algorithm then finds the radius that leads to the maximum such statistic. For <code>optimal_radius_method = &quot;silhouettes&quot;</code>, the search is done linearly, from a minimum to a maximum candidate radius for <code>optimal_radius_method = &quot;silhouettes&quot;</code>; <code>optimal_radius_method = silhouettes_optim</code>, it is done via an optimized search performed by Optim.jl which is typically faster and with similar accuracy. A third alternative is the<code>&quot;elbow&quot;</code> method, which works by calculating the distance of each point to its k-nearest-neighbors (with <code>k=min_neighbors</code>) and finding the distance corresponding to the highest derivative in the curve of the distances, sorted in ascending order. This distance is chosen as the optimal radius. It is described in (<a href="../references/#Ester1996">Ester <em>et al.</em>, 1996</a>) and (<a href="../references/#Schubert2017">Schubert <em>et al.</em>, 2017</a>). It typically performs considerably worse than the <code>&quot;silhouette&quot;</code> methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/mapping/grouping/cluster_config.jl#L5-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.GroupViaHistogram" href="#Attractors.GroupViaHistogram"><code>Attractors.GroupViaHistogram</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GroupViaHistogram(binning::FixedRectangularBinning)</code></pre><p>Initialize a struct that contains instructions on how to group features in <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a>. <code>GroupViaHistogram</code> performs a histogram in feature space. Then, all features that are in the same histogram bin get the same label. The <code>binning</code> is an instance of <a href="@ref"><code>FixedRectangularBinning</code></a> from ComplexityMeasures.jl. (the reason to not allow <code>RectangularBinning</code> is because during continuation we need to ensure that bins remain identical).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/mapping/grouping/histogram_config.jl#L5-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.GroupViaNearestFeature" href="#Attractors.GroupViaNearestFeature"><code>Attractors.GroupViaNearestFeature</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GroupViaNearestFeature(templates; kwargs...)</code></pre><p>Initialize a struct that contains instructions on how to group features in <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a>. <code>GroupViaNearestFeature</code> accepts a <code>template</code>, which is a vector of features. Then, generated features from initial conditions in <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a> are labelled according to the feature in <code>templates</code> that is closest (the label is the index of the closest template).</p><p><code>templates</code> can be a vector or dictionary mapping keys to templates. Internally all templates are converted to <code>SVector</code> for performance. Hence, it is strongly recommended that both <code>templates</code> and the output of the <code>featurizer</code> function in <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a> return <code>SVector</code> types.</p><p><strong>Keyword arguments</strong></p><ul><li><code>metric = Euclidean()</code>: metric to be used to quantify distances in the feature space.</li><li><code>max_distance = Inf</code>: Maximum allowed distance between a feature and its nearest template for it to be assigned to that template. By default, <code>Inf</code> guarantees that a feature is assigned to its nearest template regardless of the distance. Features that exceed <code>max_distance</code> to their nearest template get labelled <code>-1</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/mapping/grouping/nearest_feature_config.jl#L4-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.GroupViaPairwiseComparison" href="#Attractors.GroupViaPairwiseComparison"><code>Attractors.GroupViaPairwiseComparison</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GroupViaPairwiseComparison(; threshold::Real, kwargs...)</code></pre><p>Initialize a struct that contains instructions on how to group features in <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a>. <code>GroupViaPairwiseComparison</code> groups features and identifies clusters by considering the pairwise distance between features. It can be used as an alternative to the clustering method in <code>GroupViaClustering</code>, having the advantage that it is simpler, typically faster and uses less memory.</p><p><strong>Keyword arguments</strong></p><ul><li><code>threshold</code> (mandatory): A real number defining the maximum distance two features can be to be considered in the same cluster - above the threshold, features are different. This value simply needs to be large enough to differentiate clusters.</li><li><code>metric = Euclidean()</code>: A function <code>metric(a, b)</code> that returns the distance between two features <code>a</code> and <code>b</code>, outputs of <code>featurizer</code>. Any <code>Metric</code> from Distances.jl can be used here.</li><li><code>rescale_features = true</code>: if true, rescale each dimension of the extracted features separately into the range <code>[0,1]</code>. This typically leads to more accurate grouping.</li></ul><p><strong>Description</strong></p><p>This algorithm assumes that the features are well-separated into distinct clouds, with the maximum radius of the cloud controlled by <code>threshold</code>. Since the systems are deterministic, this is achievable with a good-enough <code>featurizer</code> function, by removing transients, and running the trajectories for sufficiently long. It then considers that features belong to the same attractor when their pairwise distance, computed using <code>metric</code>, is smaller than or equal to <code>threshold</code>, and that they belong to different attractors when the distance is bigger. Attractors correspond to each grouping of similar features. In this way, the key parameter <code>threshold</code> is basically the amount of variation permissible in the features belonging to the same attractor. If they are well-chosen, the value can be relatively small and does not need to be fine tuned.</p><p>The <code>threshold</code> should achieve a balance: one one hand, it should be large enough to account for variations in the features from the same attractor - if it&#39;s not large enough, the algorithm will find duplicate attractors. On the other hand, it should be small enough to not group together features from distinct attractors. This requires some knowledge of how spread the features are. If it&#39;s too big, the algorithm will miss some attractors, as it groups 2+ distinct attractors together. Therefore, as a rule of thumb, one can repeat the procedure a few times, starting with a relatively large value and reducing it until no more attractors are found and no duplicates appear.</p><p>The method uses relatively little memory, as it only stores vectors whose size is on order of the number of attractors of the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/mapping/grouping/pairwise_comparison.jl#L3-L48">source</a></section></article><h3 id="Grouping-utility-functions"><a class="docs-heading-anchor" href="#Grouping-utility-functions">Grouping utility functions</a><a id="Grouping-utility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Grouping-utility-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.group_features" href="#Attractors.group_features"><code>Attractors.group_features</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">group_features(features, group_config::GroupingConfig) → labels</code></pre><p>Group the given vector of feature vectors according to the configuration and return the labels (vector of equal length as <code>features</code>). See <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a> for possible configurations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/mapping/grouping/all_grouping_configs.jl#L32-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.extract_features" href="#Attractors.extract_features"><code>Attractors.extract_features</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_features(mapper, ics; N = 1000, show_progress = true)</code></pre><p>Return a vector of the features of each initial condition in <code>ics</code> (as in <a href="../basins/#Attractors.basins_fractions"><code>basins_fractions</code></a>), using the configuration of <code>mapper::AttractorsViaFeaturizing</code>. Keyword <code>N</code> is ignored if <code>ics isa StateSpaceSet</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/mapping/grouping/attractor_mapping_featurizing.jl#L121-L127">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../dynsysref/">« <code>DynamicalSystem</code> reference</a><a class="docs-footer-nextpage" href="../basins/">Basins of Attraction »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Monday 26 February 2024 16:46">Monday 26 February 2024</span>. Using Julia version 1.10.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
