<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basins of Attraction · Attractors.jl</title><meta name="title" content="Basins of Attraction · Attractors.jl"/><meta property="og:title" content="Basins of Attraction · Attractors.jl"/><meta property="twitter:title" content="Basins of Attraction · Attractors.jl"/><meta name="description" content="Documentation for Attractors.jl."/><meta property="og:description" content="Documentation for Attractors.jl."/><meta property="twitter:description" content="Documentation for Attractors.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Attractors.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Attractors.jl</a></li><li><a class="tocitem" href="../dynsysref/"><code>DynamicalSystem</code> reference</a></li><li><a class="tocitem" href="../attractors/">Finding Attractors</a></li><li class="is-active"><a class="tocitem" href>Basins of Attraction</a><ul class="internal"><li><a class="tocitem" href="#Basins-of-attraction"><span>Basins of attraction</span></a></li><li><a class="tocitem" href="#Final-state-sensitivity-/-fractal-boundaries"><span>Final state sensitivity / fractal boundaries</span></a></li><li><a class="tocitem" href="#Edge-tracking-and-edge-states"><span>Edge tracking and edge states</span></a></li><li><a class="tocitem" href="#Tipping-points"><span>Tipping points</span></a></li><li><a class="tocitem" href="#Minimal-Fatal-Shock"><span>Minimal Fatal Shock</span></a></li></ul></li><li><a class="tocitem" href="../continuation/">Attractor &amp; Basins Continuation</a></li><li><a class="tocitem" href="../visualization/">Visualization utilities</a></li><li><a class="tocitem" href="../examples/">Examples for Attractors.jl</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Basins of Attraction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Basins of Attraction</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Attractors.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Attractors.jl/blob/main/docs/src/basins.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Basins-of-Attraction"><a class="docs-heading-anchor" href="#Basins-of-Attraction">Basins of Attraction</a><a id="Basins-of-Attraction-1"></a><a class="docs-heading-anchor-permalink" href="#Basins-of-Attraction" title="Permalink"></a></h1><p>This page provides several functions related to the basins of attraction and their boundaries. It requires you to have first understood the <a href="../attractors/#Finding-Attractors">Finding Attractors</a> page.</p><h2 id="Basins-of-attraction"><a class="docs-heading-anchor" href="#Basins-of-attraction">Basins of attraction</a><a id="Basins-of-attraction-1"></a><a class="docs-heading-anchor-permalink" href="#Basins-of-attraction" title="Permalink"></a></h2><p>Calculating basins of attraction, or their state space fractions, can be done with the functions:</p><ul><li><a href="#Attractors.basins_fractions"><code>basins_fractions</code></a></li><li><a href="#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>.</li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.basins_fractions" href="#Attractors.basins_fractions"><code>Attractors.basins_fractions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basins_fractions(
    mapper::AttractorMapper,
    ics::Union{StateSpaceSet, Function};
    kwargs...
)</code></pre><p>Approximate the state space fractions <code>fs</code> of the basins of attraction of a dynamical system by mapping initial conditions to attractors using <code>mapper</code> (which contains a reference to a <a href="../dynsysref/#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a>). The fractions are simply the ratios of how many initial conditions ended up at each attractor.</p><p>Initial conditions to use are defined by <code>ics</code>. It can be:</p><ul><li>a <code>StateSpaceSet</code> of initial conditions, in which case all are used.</li><li>a 0-argument function <code>ics()</code> that spits out random initial conditions. Then <code>N</code> random initial conditions are chosen. See <a href="#StateSpaceSets.statespace_sampler"><code>statespace_sampler</code></a> to generate such functions.</li></ul><p><strong>Return</strong></p><p>The function will always return <code>fractions</code>, which is a dictionary whose keys are the labels given to each attractor (always integers enumerating the different attractors), and whose values are the respective basins fractions. The label <code>-1</code> is given to any initial condition where <code>mapper</code> could not match to an attractor (this depends on the <code>mapper</code> type).</p><p>If <code>ics</code> is a <code>StateSpaceSet</code> the function will also return <code>labels</code>, which is <em>vector</em>, of equal length to <code>ics</code>, that contains the label each initial condition was mapped to.</p><p>See <a href="../attractors/#Attractors.AttractorMapper"><code>AttractorMapper</code></a> for all possible <code>mapper</code> types, and use <a href="#Attractors.extract_attractors"><code>extract_attractors</code></a> (after calling <code>basins_fractions</code>) to extract the stored attractors from the <code>mapper</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>N = 1000</code>: Number of random initial conditions to generate in case <code>ics</code> is a function.</li><li><code>show_progress = true</code>: Display a progress bar of the process.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/mapping/attractor_mapping.jl#L59-L97">source</a></section><section><div><pre><code class="language-julia hljs">basins_fractions(basins::AbstractArray) → fs::Dict</code></pre><p>Calculate the state space fraction of the basins of attraction encoded in <code>basins</code>. The elements of <code>basins</code> are integers, enumerating the attractor that the entry of <code>basins</code> converges to (i.e., like the output of <a href="#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>). Return a dictionary that maps attractor IDs to their relative fractions.</p><p>In (<a href="../references/#Menck2013">Menck <em>et al.</em>, 2013</a>) the authors use these fractions to quantify the stability of a basin of attraction, and specifically how it changes when a parameter is changed. For this, see <a href="../continuation/#Attractors.continuation"><code>continuation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/basins/basins_utilities.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.extract_attractors" href="#Attractors.extract_attractors"><code>Attractors.extract_attractors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_attractors(mapper::AttractorsMapper) → attractors</code></pre><p>Return a dictionary mapping label IDs to attractors found by the <code>mapper</code>. This function should be called after calling <a href="#Attractors.basins_fractions"><code>basins_fractions</code></a> with the given <code>mapper</code> so that the attractors have actually been found first.</p><p>For <code>AttractorsViaFeaturizing</code>, the attractors are only stored if the mapper was called with pre-defined initial conditions rather than a sampler (function returning initial conditions).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/mapping/attractor_mapping.jl#L131-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.basins_of_attraction" href="#Attractors.basins_of_attraction"><code>Attractors.basins_of_attraction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basins_of_attraction(mapper::AttractorMapper, grid::Tuple) → basins, attractors</code></pre><p>Compute the full basins of attraction as identified by the given <code>mapper</code>, which includes a reference to a <a href="../dynsysref/#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a> and return them along with (perhaps approximated) found attractors.</p><p><code>grid</code> is a tuple of ranges defining the grid of initial conditions that partition the state space into boxes with size the step size of each range. For example, <code>grid = (xg, yg)</code> where <code>xg = yg = range(-5, 5; length = 100)</code>. The grid has to be the same dimensionality as the state space expected by the integrator/system used in <code>mapper</code>. E.g., a <a href="../dynsysref/#DynamicalSystemsBase.ProjectedDynamicalSystem"><code>ProjectedDynamicalSystem</code></a> could be used for lower dimensional projections, etc. A special case here is a <a href="../dynsysref/#DynamicalSystemsBase.PoincareMap"><code>PoincareMap</code></a> with <code>plane</code> being <code>Tuple{Int, &lt;: Real}</code>. In this special scenario the grid can be one dimension smaller than the state space, in which case the partitioning happens directly on the hyperplane the Poincaré map operates on.</p><p><code>basins_of_attraction</code> function is a convenience 5-lines-of-code wrapper which uses the <code>labels</code> returned by <a href="#Attractors.basins_fractions"><code>basins_fractions</code></a> and simply assigns them to a full array corresponding to the state space partitioning indicated by <code>grid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/mapping/attractor_mapping.jl#L159-L179">source</a></section><section><div><pre><code class="language-julia hljs">basins_of_attraction(mapper::AttractorsViaRecurrences; show_progress = true)</code></pre><p>This is a special method of <code>basins_of_attraction</code> that using recurrences does <em>exactly</em> what is described in the paper by Datseris &amp; Wagemakers (<a href="../references/#Datseris2022">Datseris and Wagemakers, 2022</a>). By enforcing that the internal grid of <code>mapper</code> is the same as the grid of initial conditions to map to attractors, the method can further utilize found exit and attraction basins, making the computation faster as the grid is processed more and more.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/mapping/recurrences/attractor_mapping_recurrences.jl#L180-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.convergence_and_basins_of_attraction" href="#Attractors.convergence_and_basins_of_attraction"><code>Attractors.convergence_and_basins_of_attraction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convergence_and_basins_of_attraction(mapper::AttractorsViaRecurrences, grid) -&gt; basins, attractors, iterations</code></pre><p>An extension of <a href="#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>. This version also returns <code>iterations</code>, which is the number of iterations each initial condition took to converge to the attractor. Useful to give to <a href="@ref"><code>shaded_basins_heatmap</code></a>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>show_progress = true</code>: show progress bar</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/basins/basins_utilities.jl#L22-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.iterations_to_converge" href="#Attractors.iterations_to_converge"><code>Attractors.iterations_to_converge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iterations_to_converge(mapper::AttractorMapper) → n::Int</code></pre><p>Return the number of iterations the <code>mapper</code> took to converge to an attractor. This function should be called just right after <code>mapper(u0)</code> was called with <code>u0</code> the initial condition of interest. Hence it is only valid with <code>AttractorMapper</code> subtypes that support this syntax.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/mapping/attractor_mapping.jl#L145-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceSets.statespace_sampler" href="#StateSpaceSets.statespace_sampler"><code>StateSpaceSets.statespace_sampler</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">statespace_sampler(region [, seed = 42]) → sampler, isinside</code></pre><p>A function that facilitates sampling points randomly and uniformly in a state space <code>region</code>. It generates two functions:</p><ul><li><code>sampler</code> is a 0-argument function that when called generates a random point inside a state space <code>region</code>. The point is always a <code>Vector</code> for type stability irrespectively of dimension. Generally, the generated point should be <em>copied</em> if it needs to be stored. (i.e., calling <code>sampler()</code> utilizes a shared vector) <code>sampler</code> is a thread-safe function.</li><li><code>isinside</code> is a 1-argument function that returns <code>true</code> if the given state space point is inside the <code>region</code>.</li></ul><p>The <code>region</code> can be an instance of any of the following types (input arguments if not specified are vectors of length <code>D</code>, with <code>D</code> the state space dimension):</p><ul><li><code>HSphere(radius::Real, center)</code>: points <em>inside</em> the hypersphere (boundary excluded). Convenience method <code>HSphere(radius::Real, D::Int)</code> makes the center a <code>D</code>-long vector of zeros.</li><li><code>HSphereSurface(radius, center)</code>: points on the hypersphere surface. Same convenience method as above is possible.</li><li><code>HRectangle(mins, maxs)</code>: points in [min, max) for the bounds along each dimension.</li></ul><p>The random number generator is always <code>Xoshiro</code> with the given <code>seed</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/v1.4.5/src/sampler.jl#L9-L37">source</a></section><section><div><pre><code class="language-julia hljs">statespace_sampler(grid::NTuple{N, AbstractRange} [, seed])</code></pre><p>If given a <code>grid</code> that is a tuple of <code>AbstractVector</code>s, the minimum and maximum of the vectors are used to make an <code>HRectangle</code> region.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/v1.4.5/src/sampler.jl#L139-L144">source</a></section></article><h2 id="Final-state-sensitivity-/-fractal-boundaries"><a class="docs-heading-anchor" href="#Final-state-sensitivity-/-fractal-boundaries">Final state sensitivity / fractal boundaries</a><a id="Final-state-sensitivity-/-fractal-boundaries-1"></a><a class="docs-heading-anchor-permalink" href="#Final-state-sensitivity-/-fractal-boundaries" title="Permalink"></a></h2><p>Several functions are provided related with analyzing the fractality of the boundaries of the basins of attraction:</p><ul><li><a href="#Attractors.basins_fractal_dimension"><code>basins_fractal_dimension</code></a></li><li><a href="#Attractors.basin_entropy"><code>basin_entropy</code></a></li><li><a href="#Attractors.basins_fractal_test"><code>basins_fractal_test</code></a></li><li><a href="#Attractors.uncertainty_exponent"><code>uncertainty_exponent</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.basins_fractal_dimension" href="#Attractors.basins_fractal_dimension"><code>Attractors.basins_fractal_dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basins_fractal_dimension(basins; kwargs...) -&gt; V_ε, N_ε, d</code></pre><p>Estimate the fractal dimension <code>d</code> of the boundary between basins of attraction using a box-counting algorithm for the boxes that contain at least two different basin IDs.</p><p><strong>Keyword arguments</strong></p><ul><li><code>range_ε = 2:maximum(size(basins))÷20</code> is the range of sizes of the box to test (in pixels).</li></ul><p><strong>Description</strong></p><p>The output <code>N_ε</code> is a vector with the number of the balls of radius <code>ε</code> (in pixels) that contain at least two initial conditions that lead to different attractors. <code>V_ε</code> is a vector with the corresponding size of the balls. The output <code>d</code> is the estimation of the box-counting dimension of the boundary by fitting a line in the <code>log.(N_ε)</code> vs <code>log.(1/V_ε)</code> curve. However it is recommended to analyze the curve directly for more accuracy.</p><p>It is the implementation of the popular algorithm of the estimation of the box-counting dimension. The algorithm search for a covering the boundary with <code>N_ε</code> boxes of size <code>ε</code> in pixels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/basins/fractality_of_basins.jl#L148-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.basin_entropy" href="#Attractors.basin_entropy"><code>Attractors.basin_entropy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basin_entropy(basins::Array, ε = 20) -&gt; Sb, Sbb</code></pre><p>Compute the basin entropy (<a href="../references/#Daza2016">Daza <em>et al.</em>, 2016</a>) <code>Sb</code> and basin boundary entropy <code>Sbb</code> of the given <code>basins</code> of attraction by considering <code>ε</code> boxes along each dimension.</p><p><strong>Description</strong></p><p>First, the input <code>basins</code> is divided regularly into n-dimensional boxes of side <code>ε</code> (along all dimensions). Then <code>Sb</code> is simply the average of the Gibbs entropy computed over these boxes. The function returns the basin entropy <code>Sb</code> as well as the boundary basin entropy <code>Sbb</code>. The later is the average of the entropy only for boxes that contains at least two different basins, that is, for the boxes on the boundaries.</p><p>The basin entropy is a measure of the uncertainty on the initial conditions of the basins. It is maximum at the value <code>log(n_att)</code> being <code>n_att</code> the number of attractors. In this case the boundary is intermingled: for a given initial condition we can find another initial condition that lead to another basin arbitrarily close. It provides also a simple criterion for fractality: if the boundary basin entropy <code>Sbb</code> is above <code>log(2)</code> then we have a fractal boundary. It doesn&#39;t mean that basins with values below cannot have a fractal boundary, for a more precise test see <a href="#Attractors.basins_fractal_test"><code>basins_fractal_test</code></a>. An important feature of the basin entropy is that it allows comparisons between different basins using the same box size <code>ε</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/basins/fractality_of_basins.jl#L3-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.basins_fractal_test" href="#Attractors.basins_fractal_test"><code>Attractors.basins_fractal_test</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basins_fractal_test(basins; ε = 20, Ntotal = 1000) -&gt; test_res, Sbb</code></pre><p>Perform an automated test to decide if the boundary of the basins has fractal structures based on the method of Puy et al. (<a href="../references/#Puy2021">Puy <em>et al.</em>, 2021</a>). Return <code>test_res</code> (<code>:fractal</code> or <code>:smooth</code>) and the mean basin boundary entropy.</p><p><strong>Keyword arguments</strong></p><ul><li><code>ε = 20</code>: size of the box to compute the basin boundary entropy.</li><li><code>Ntotal = 1000</code>: number of balls to test in the boundary for the computation of <code>Sbb</code></li></ul><p><strong>Description</strong></p><p>The test &quot;looks&quot; at the basins with a magnifier of size <code>ε</code> at random. If what we see in the magnifier looks like a smooth boundary (onn average) we decide that the boundary is smooth. If it is not smooth we can say that at the scale <code>ε</code> we have structures, i.e., it is fractal.</p><p>In practice the algorithm computes the boundary basin entropy <code>Sbb</code> <a href="#Attractors.basin_entropy"><code>basin_entropy</code></a> for <code>Ntotal</code> random boxes of radius <code>ε</code>. If the computed value is equal to theoretical value of a smooth boundary (taking into account statistical errors and biases) then we decide that we have a smooth boundary. Notice that the response <code>test_res</code> may depend on the chosen ball radius <code>ε</code>. For larger size, we may observe structures for smooth boundary and we obtain a <em>different</em> answer.</p><p>The output <code>test_res</code> is a symbol describing the nature of the basin and the output <code>Sbb</code> is the estimated value of the boundary basin entropy with the sampling method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/basins/fractality_of_basins.jl#L57-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.uncertainty_exponent" href="#Attractors.uncertainty_exponent"><code>Attractors.uncertainty_exponent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">uncertainty_exponent(basins; kwargs...) -&gt; ε, N_ε, α</code></pre><p>Estimate the uncertainty exponent(<a href="../references/#Grebogi1983">Grebogi <em>et al.</em>, 1983</a>) of the basins of attraction. This exponent is related to the final state sensitivity of the trajectories in the phase space. An exponent close to <code>1</code> means basins with smooth boundaries whereas an exponent close to <code>0</code> represent completely fractalized basins, also called riddled basins.</p><p>The output <code>N_ε</code> is a vector with the number of the balls of radius <code>ε</code> (in pixels) that contain at least two initial conditions that lead to different attractors. The output <code>α</code> is the estimation of the uncertainty exponent using the box-counting dimension of the boundary by fitting a line in the <code>log.(N_ε)</code> vs <code>log.(1/ε)</code> curve. However it is recommended to analyze the curve directly for more accuracy.</p><p><strong>Keyword arguments</strong></p><ul><li><code>range_ε = 2:maximum(size(basins))÷20</code> is the range of sizes of the ball to test (in pixels).</li></ul><p><strong>Description</strong></p><p>A phase space with a fractal boundary may cause a uncertainty on the final state of the dynamical system for a given initial condition. A measure of this final state sensitivity is the uncertainty exponent. The algorithm probes the basin of attraction with balls of size <code>ε</code> at random. If there are a least two initial conditions that lead to different attractors, a ball is tagged &quot;uncertain&quot;. <code>f_ε</code> is the fraction of &quot;uncertain balls&quot; to the total number of tries in the basin. In analogy to the fractal dimension, there is a scaling law between, <code>f_ε ~ ε^α</code>. The number that characterizes this scaling is called the uncertainty exponent <code>α</code>.</p><p>Notice that the uncertainty exponent and the box counting dimension of the boundary are related. We have <code>Δ₀ = D - α</code> where <code>Δ₀</code> is the box counting dimension computed with <a href="#Attractors.basins_fractal_dimension"><code>basins_fractal_dimension</code></a> and <code>D</code> is the dimension of the phase space. The algorithm first estimates the box counting dimension of the boundary and returns the uncertainty exponent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/basins/fractality_of_basins.jl#L209-L243">source</a></section></article><h2 id="Edge-tracking-and-edge-states"><a class="docs-heading-anchor" href="#Edge-tracking-and-edge-states">Edge tracking and edge states</a><a id="Edge-tracking-and-edge-states-1"></a><a class="docs-heading-anchor-permalink" href="#Edge-tracking-and-edge-states" title="Permalink"></a></h2><p>The edge tracking algorithm allows to locate and construct so-called edge states (also referred to as <em>Melancholia states</em>) embedded in the basin boundary separating different basins of attraction. These could be saddle points, unstable periodic orbits or chaotic saddles. The general idea is that these sets can be found because they act as attractors when restricting to the basin boundary.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.edgetracking" href="#Attractors.edgetracking"><code>Attractors.edgetracking</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">edgetracking(ds::DynamicalSystem, attractors::Dict; kwargs...)</code></pre><p>Track along a basin boundary in a dynamical system <code>ds</code> with two or more attractors in order to find an <em>edge state</em>. Results are returned in the form of <a href="#Attractors.EdgeTrackingResults"><code>EdgeTrackingResults</code></a>, which contains the pseudo-trajectory <code>edge</code> representing the track on the basin boundary, along with additional output (see below).</p><p>The system&#39;s <code>attractors</code> are specified as a <code>Dict</code> of <code>StateSpaceSet</code>s, as in <a href="../attractors/#Attractors.AttractorsViaProximity"><code>AttractorsViaProximity</code></a> or the output of <a href="#Attractors.extract_attractors"><code>extract_attractors</code></a>. By default, the algorithm is initialized from the first and second attractor in <code>attractors</code>. Alternatively, the initial states can be set via keyword arguments <code>u1</code>, <code>u2</code> (see below). Note that the two initial states must belong to different basins of attraction.</p><p><strong>Keyword arguments</strong></p><ul><li><code>bisect_thresh = 1e-7</code>: distance threshold for bisection</li><li><code>diverge_thresh = 1e-6</code>: distance threshold for parallel integration</li><li><code>u1</code>: first initial state (defaults to first point in first entry of <code>attractors</code>)</li><li><code>u2</code>: second initial state (defaults to first point in second entry of <code>attractors</code>)</li><li><code>maxiter = 100</code>: maximum number of iterations before the algorithm stops</li><li><code>abstol = 0.0</code>: distance threshold for convergence of the updated edge state</li><li><code>T_transient = 0.0</code>: transient time before the algorithm starts saving the edge track</li><li><code>tmax = Inf</code>: maximum integration time of parallel trajectories until re-bisection </li><li><code>Δt = 0.01</code>: time step passed to <a href="../dynsysref/#CommonSolve.step!-Tuple{DynamicalSystem, Vararg{Any}}"><code>step!</code></a> when evolving the two trajectories</li><li><code>ϵ_mapper = nothing</code>: <code>ϵ</code> parameter in <a href="../attractors/#Attractors.AttractorsViaProximity"><code>AttractorsViaProximity</code></a></li><li><code>show_progress = true</code>: if true, shows progress bar and information while running</li><li><code>verbose = true</code>: if false, silences print output and warnings while running</li><li><code>kwargs...</code>: additional keyword arguments to be passed to <a href="../attractors/#Attractors.AttractorsViaProximity"><code>AttractorsViaProximity</code></a></li></ul><p><strong>Description</strong></p><p>The edge tracking algorithm is a numerical method to find an <em>edge state</em> or (possibly chaotic) saddle on the boundary between two basins of attraction. Introduced by (<a href="../references/#Battelino1988">Battelino <em>et al.</em>, 1988</a>) and further described by (<a href="../references/#Skufca2006">Skufca <em>et al.</em>, 2006</a>), the algorithm has been applied to, e.g., the laminar-turbulent boundary in plane Couette flow (<a href="../references/#Schneider2008">Schneider <em>et al.</em>, 2008</a>), Wada basins (<a href="../references/#Wagemakers2020">Wagemakers <em>et al.</em>, 2020</a>), as well as Melancholia states in conceptual (<a href="../references/#Mehling2023">Mehling <em>et al.</em>, 2023</a>) and intermediate-complexity (<a href="../references/#Lucarini2017">Lucarini and Bódai, 2017</a>)  climate models.  Relying only on forward integration of the system, it works even in high-dimensional systems with complicated fractal basin boundary structures.</p><p>The algorithm consists of two main steps: bisection and tracking. First, it iteratively  bisects along a straight line in state space between the intial states <code>u1</code> and <code>u2</code> to find the separating basin boundary. The bisection stops when the two updated states are less than <code>bisect_thresh</code> (Euclidean distance in state space) apart from each other. Next, a <code>ParallelDynamicalSystem</code> is initialized from these two updated states and integrated forward until the two trajectories diverge from each other by more than <code>diverge_thresh</code> (Euclidean distance). The two final states of the parallel integration are then used as new states <code>u1</code> and <code>u2</code> for a new bisection, and  so on, until a stopping criterion is fulfilled. </p><p>Two stopping criteria are implemented via the keyword arguments <code>maxiter</code> and <code>abstol</code>. Either the algorithm stops when the number of iterations reaches <code>maxiter</code>, or when the state space position of the updated edge point changes by less than <code>abstol</code> (in Euclidean distance) compared to the previous iteration. Convergence below <code>abstol</code> happens after sufficient iterations if the edge state is a saddle point. However, the edge state may also be an unstable limit cycle or a chaotic saddle. In these cases, the algorithm will never actually converge to a point but (after a transient period) continue populating the set constituting the edge state by tracking along it.</p><p>A central idea behind this algorithm is that basin boundaries are typically the stable manifolds of unstable sets, namely edge states or saddles. The flow along the basin boundary  will thus lead to these sets, and the iterative bisection neutralizes the unstable direction of the flow away from the basin boundary. If the system possesses multiple edge  states, the algorithm will find one of them depending on where the initial bisection locates the boundary.</p><p><strong>Output</strong></p><p>Returns a data type <a href="#Attractors.EdgeTrackingResults"><code>EdgeTrackingResults</code></a> containing the results.</p><p>Sometimes, the AttractorMapper used in the algorithm may erroneously identify both states <code>u1</code> and <code>u2</code> with the same basin of attraction due to being very close to the basin boundary. If this happens, a warning is raised and <code>EdgeTrackingResults.success = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/boundaries/edgetracking.jl#L28-L101">source</a></section><section><div><pre><code class="language-julia hljs">edgetracking(pds::ParallelDynamicalSystem, mapper::AttractorMapper; kwargs...)</code></pre><p>Low-level function for running the edge tracking algorithm, see <a href="#Attractors.edgetracking"><code>edgetracking</code></a> for a description, keyword arguments and output type.</p><p><code>pds</code> is a <code>ParallelDynamicalSystem</code> with two states. The <code>mapper</code> must be an <code>AttractorMapper</code> of subtype <code>AttractorsViaProximity</code> or <code>AttractorsViaRecurrences</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/boundaries/edgetracking.jl#L125-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.EdgeTrackingResults" href="#Attractors.EdgeTrackingResults"><code>Attractors.EdgeTrackingResults</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EdgeTrackingResults(edge, track1, track2, time, bisect_idx)</code></pre><p>Data type that stores output of the <a href="#Attractors.edgetracking"><code>edgetracking</code></a> algorithm.</p><p><strong>Fields</strong></p><ul><li><code>edge::StateSpaceSet</code>: the pseudo-trajectory representing the tracked edge segment (given by the average in state space between <code>track1</code> and <code>track2</code>)</li><li><code>track1::StateSpaceSet</code>: the pseudo-trajectory tracking the edge within basin 1</li><li><code>track2::StateSpaceSet</code>: the pseudo-trajectory tracking the edge within basin 2</li><li><code>time::Vector</code>: time points of the above <code>StateSpaceSet</code>s</li><li><code>bisect_idx::Vector</code>: indices of <code>time</code> at which a re-bisection occurred</li><li><code>success::Bool</code>: indicates whether the edge tracking has been successful or not</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/boundaries/edgetracking.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.bisect_to_edge" href="#Attractors.bisect_to_edge"><code>Attractors.bisect_to_edge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bisect_to_edge(pds::ParallelDynamicalSystem, mapper::AttractorMapper; kwargs...) -&gt; u1, u2</code></pre><p>Finds the basin boundary between two states <code>u1, u2 = current_states(pds)</code> by bisecting along a straight line in phase space. The states <code>u1</code> and <code>u2</code> must belong to different basins.</p><p>Returns a triple <code>u1, u2, success</code>, where <code>u1, u2</code> are two new states located on either side of the basin boundary that lie less than <code>bisect_thresh</code> (Euclidean distance in state space) apart from each other, and <code>success</code> is a Bool indicating whether the bisection was successful (it may fail if the <code>mapper</code> maps both states to the same basin of attraction, in which case a warning is raised).</p><p><strong>Keyword arguments</strong></p><ul><li><code>bisect_thresh = 1e-7</code>: The maximum (Euclidean) distance between the two returned states.</li></ul><p><strong>Description</strong></p><p><code>pds</code> is a <code>ParallelDynamicalSystem</code> with two states. The <code>mapper</code> must be an <code>AttractorMapper</code> of subtype <code>AttractorsViaProximity</code> or <code>AttractorsViaRecurrences</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>If the straight line between <code>u1</code> and <code>u2</code> intersects the basin boundary multiple times, the method will find one of these intersection points. If more than two attractors exist, one of the two returned states may belong to a different basin than the initial conditions <code>u1</code> and <code>u2</code>. A warning is raised if the bisection involves a third basin.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/boundaries/edgetracking.jl#L222-L246">source</a></section></article><h2 id="Tipping-points"><a class="docs-heading-anchor" href="#Tipping-points">Tipping points</a><a id="Tipping-points-1"></a><a class="docs-heading-anchor-permalink" href="#Tipping-points" title="Permalink"></a></h2><p>This page discusses functionality related with tipping points in dynamical systems with known rule. If instead you are interested in identifying tipping points in measured timeseries, have a look at <a href="https://github.com/JuliaDynamics/TransitionIndicators.jl">TransitionIndicators.jl</a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.tipping_probabilities" href="#Attractors.tipping_probabilities"><code>Attractors.tipping_probabilities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tipping_probabilities(basins_before, basins_after) → P</code></pre><p>Return the tipping probabilities of the computed basins before and after a change in the system parameters (or time forcing), according to the definition of (<a href="../references/#Kaszas2019">Kaszás <em>et al.</em>, 2019</a>).</p><p>The input <code>basins</code> are integer-valued arrays, where the integers enumerate the attractor, e.g. the output of <a href="#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>.</p><p><strong>Description</strong></p><p>Let <span>$\mathcal{B}_i(p)$</span> denote the basin of attraction of attractor <span>$A_i$</span> at parameter(s) <span>$p$</span>. Kaszás et al (<a href="../references/#Kaszas2019">Kaszás <em>et al.</em>, 2019</a>) define the tipping probability from <span>$A_i$</span> to <span>$A_j$</span>, given a parameter change in the system of <span>$p_- \to p_+$</span>, as</p><p class="math-container">\[P(A_i \to A_j | p_- \to p_+) =
\frac{|\mathcal{B}_j(p_+) \cap \mathcal{B}_i(p_-)|}{|\mathcal{B}_i(p_-)|}\]</p><p>where <span>$|\cdot|$</span> is simply the volume of the enclosed set. The value of <span>$P(A_i \to A_j | p_- \to p_+)$</span> is <code>P[i, j]</code>. The equation describes something quite simple: what is the overlap of the basin of attraction of <span>$A_i$</span> at <span>$p_-$</span> with that of the attractor <span>$A_j$</span> at <span>$p_+$</span>. If <code>basins_before, basins_after</code> contain values of <code>-1</code>, corresponding to trajectories that diverge, this is considered as the last attractor of the system in <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/tipping/tipping_probabilities.jl#L3-L28">source</a></section></article><h2 id="Minimal-Fatal-Shock"><a class="docs-heading-anchor" href="#Minimal-Fatal-Shock">Minimal Fatal Shock</a><a id="Minimal-Fatal-Shock-1"></a><a class="docs-heading-anchor-permalink" href="#Minimal-Fatal-Shock" title="Permalink"></a></h2><p>The algorithm to find minimal perturbation for arbitrary initial condition <code>u0</code> which will kick the system into different from the current basin.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.minimal_fatal_shock" href="#Attractors.minimal_fatal_shock"><code>Attractors.minimal_fatal_shock</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">minimal_fatal_shock(mapper::AttractorMapper, u0, search_area, algorithm) → mfs</code></pre><p>Return the minimal fatal shock <code>mfs</code> for the initial point <code>u0</code> according to the specified <code>algorithm</code> given a <code>mapper</code> that satisfies the <code>id = mapper(u0)</code> interface (see <a href="../attractors/#Attractors.AttractorMapper"><code>AttractorMapper</code></a> if you are not sure which mappers do that). The <code>mapper</code> contains a reference to a <a href="../dynsysref/#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a>. The options for <code>algorithm</code> are: <a href="#Attractors.MFSBruteForce"><code>MFSBruteForce</code></a> or <a href="#Attractors.MFSBlackBoxOptim"><code>MFSBlackBoxOptim</code></a>. Forh high dimensional systems <a href="#Attractors.MFSBlackBoxOptim"><code>MFSBlackBoxOptim</code></a> is likely more accurate.</p><p>The <code>search_area</code> dictates the state space range for the search of the <code>mfs</code>. It can be a 2-tuple of (min, max) values, in which case the same values are used for each dimension of the system in <code>mapper</code>. Otherwise, it can be a vector of 2-tuples, each for each dimension of the system. The search area is defined w.r.t. to <code>u0</code> (i.e., it is the search area for perturbations of <code>u0</code>).</p><p><strong>Description</strong></p><p>The minimal fatal shock is defined as the smallest (smallest norm) perturbation of the initial point <code>u0</code> that will lead it a different basin of attraction. It is inspired by the paper &quot;Minimal fatal shocks in multistable complex networks&quot; (<a href="../references/#Halekotte2020">Halekotte and Feudel, 2020</a>), however the implementation here is generic: it works for <em>any</em> dynamical system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/tipping/mfs.jl#L5-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.MFSBlackBoxOptim" href="#Attractors.MFSBlackBoxOptim"><code>Attractors.MFSBlackBoxOptim</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MFSBlackBoxOptim(; kwargs...)</code></pre><p>The black box derivative-free optimization algorithm used in <a href="#Attractors.minimal_fatal_shock"><code>minimal_fatal_shock</code></a>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>guess = nothing</code> a initial guess for the minimal fatal shock given to the optimization algorithm. If not <code>nothing</code>, <code>random_algo</code> below is ignored.</li><li><code>max_steps = 10000</code> maximum number of steps for the optimization algorithm.</li><li><code>penalty</code> penalty value for the objective function, allows to adjust optimization algorithm to find the minimal fatal shock, <code>default = 1000.0</code></li><li><code>print_info</code> boolean value, if true, the optimization algorithm will print information on the evaluation steps of objective function, <code>default = false</code>.</li><li><code>random_algo = MFSBruteForce(100, 100, 0.99)</code>: an instance of <a href="#Attractors.MFSBruteForce"><code>MFSBruteForce</code></a> that can be used to provide an initial guess.</li></ul><p><strong>Description</strong></p><p>The algorithm uses BlackBoxOptim.jl and a penalized objective function to minimize. y function used as a constraint function. So, if we hit another basin during the search we encourage the algorithm otherwise we punish it with some penalty. The function to minimize is (besides some details):</p><pre><code class="language-julia hljs">function mfs_objective(perturbation, u0, mapper, penalty)
    dist = norm(perturbation)
    if mapper(u0 + perturbation) == mapper(u0)
        # penalize if we stay in the same basin:
        return dist + penalty
    else
        return dist
    end
end</code></pre><p>Using an initial guess can be beneficial to both performance and accuracy, which is why the output of a crude <a href="#Attractors.MFSBruteForce"><code>MFSBruteForce</code></a> is used to provide a guess. This can be disabled by either passing a <code>guess</code> vector explicitly or by giving <code>nothing</code> as <code>random_algo</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/tipping/mfs.jl#L159-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.MFSBruteForce" href="#Attractors.MFSBruteForce"><code>Attractors.MFSBruteForce</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MFSBruteForce(; kwargs...)</code></pre><p>The brute force randomized search algorithm used in <a href="#Attractors.minimal_fatal_shock"><code>minimal_fatal_shock</code></a>.</p><p>It consists of two steps: random initialization and sphere radius reduction. On the first step, the algorithm generates random perturbations within the search area and records the perturbation that leads to a different basin but with the smallest magnitude. With this obtained perturbation it proceeds to the second step. On the second step, the algorithm generates random perturbations on the surface of the hypersphere with radius equal to the norm of the perturbation found in the first step. It reduces the radius of the hypersphere and continues searching for the better result with a smaller radius. Each time a better result is found, the radius is reduced further.</p><p>The algorithm records the perturbation with smallest radius that leads to a different basin.</p><p><strong>Keyword arguments</strong></p><ul><li><code>initial_iterations = 10000</code>: number of random perturbations to try in the first step of the algorithm.</li><li><code>sphere_iterations = 10000</code>: number of steps while initializing random points on hypersphere and decreasing its radius.</li><li><code>sphere_decrease_factor = 0.999</code> factor by which the radius of the hypersphere is decreased (at each step the radius is multiplied by this number). Number closer to 1 means more refined accuracy</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/c90125bff8a400d80aab39421871c7158c156125/src/tipping/mfs.jl#L42-L69">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../attractors/">« Finding Attractors</a><a class="docs-footer-nextpage" href="../continuation/">Attractor &amp; Basins Continuation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Monday 26 February 2024 16:46">Monday 26 February 2024</span>. Using Julia version 1.10.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
