var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Battelino, P. M.; Grebogi, C.; Ott, E.; Yorke, J. A. and Yorke, E. D. (1988). Multiple coexisting attractors, basin boundaries and basic sets. Physica D: Nonlinear Phenomena 32, 296–305.\n\n\n\nDatseris, G.; Rossi, K. L. and Wagemakers, A. (2023). Framework for global stability analysis of dynamical systems. Chaos: An Interdisciplinary Journal of Nonlinear Science 33.\n\n\n\nDatseris, G. and Wagemakers, A. (2022). Effortless estimation of basins of attraction. Chaos: An Interdisciplinary Journal of Nonlinear Science 32, 023104.\n\n\n\nDaza, A.; Wagemakers, A.; Georgeot, B.; Guéry-Odelin, D. and Sanjuán, M. A. (2016). Basin entropy: a new tool to analyze uncertainty in dynamical systems. Scientific Reports 6.\n\n\n\nDaza, A.; Wagemakers, A. and Sanjuán, M. A. (2018). Ascertaining when a basin is Wada: the merging method. Scientific Reports 8, 9954.\n\n\n\nEster, M.; Kriegel, H.-P.; Sander, J. and Xu, X. (1996). A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise. In: Proceedings of the Second International Conference on Knowledge Discovery and Data Mining, KDD'96 (AAAI Press); pp. 226–231.\n\n\n\nGelbrecht, M.; Kurths, J. and Hellmann, F. (2020). Monte Carlo basin bifurcation analysis. New Journal of Physics 22, 033032.\n\n\n\nGrebogi, C.; McDonald, S. W.; Ott, E. and Yorke, J. A. (1983). Final state sensitivity: An obstruction to predictability. Physics Letters A 99, 415–418.\n\n\n\nHalekotte, L. and Feudel, U. (2020). Minimal fatal shocks in multistable complex networks. Scientific Reports 10.\n\n\n\nKaszás, B.; Feudel, U. and Tél, T. (2019). Tipping phenomena in typical dynamical systems subjected to parameter drift. Scientific Reports 9.\n\n\n\nLucarini, V. and Bódai, T. (2017). Edge states in the climate system: exploring global instabilities and critical transitions. Nonlinearity 30, R32.\n\n\n\nMehling, O.; Börner, R. and Lucarini, V. (2023). Limits to predictability of the asymptotic state of the Atlantic Meridional Overturning Circulation in a conceptual climate model, arXiv preprint arXiv:2308.16251.\n\n\n\nMenck, P. J.; Heitzig, J.; Marwan, N. and Kurths, J. (2013). How basin stability complements the linear-stability paradigm. Nature Physics 9, 89–92.\n\n\n\nPuy, A.; Daza, A.; Wagemakers, A. and Sanjuán, M. A. (2021). A test for fractal boundaries based on the basin entropy. Communications in Nonlinear Science and Numerical Simulation 95, 105588.\n\n\n\nSchneider, T. M.; Gibson, J. F.; Lagha, M.; De Lillo, F. and Eckhardt, B. (2008). Laminar-turbulent boundary in plane Couette flow. Physical Review E 78, 037301.\n\n\n\nSchubert, E.; Sander, J.; Ester, M.; Kriegel, H. P. and Xu, X. (2017). DBSCAN Revisited,  Revisited. ACM Transactions on Database Systems 42, 1–21.\n\n\n\nSkufca, J. D.; Yorke, J. A. and Eckhardt, B. (2006). Edge of chaos in a parallel shear flow. Physical review letters 96, 174101.\n\n\n\nStender, M. and Hoffmann, N. (2021), bSTAB: an open-source software for computing the basin stability of multi-stable dynamical systems. Nonlinear Dynamics 107, 1451–1468.\n\n\n\nWagemakers, A.; Daza, A. and Sanjuán, M. A. (2020). The saddle-straddle method to test for Wada basins. Communications in Nonlinear Science and Numerical Simulation 84, 105167.\n\n\n\n","category":"page"},{"location":"basins/#Basins-of-Attraction","page":"Basins of Attraction","title":"Basins of Attraction","text":"","category":"section"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"This page provides several functions related to the basins of attraction and their boundaries. It requires you to have first understood the Finding Attractors page.","category":"page"},{"location":"basins/#Basins-of-attraction","page":"Basins of Attraction","title":"Basins of attraction","text":"","category":"section"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"Calculating basins of attraction, or their state space fractions, can be done with the functions:","category":"page"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"basins_fractions\nbasins_of_attraction.","category":"page"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"basins_fractions\nextract_attractors\nbasins_of_attraction\nstatespace_sampler","category":"page"},{"location":"basins/#Attractors.basins_fractions","page":"Basins of Attraction","title":"Attractors.basins_fractions","text":"basins_fractions(\n    mapper::AttractorMapper,\n    ics::Union{StateSpaceSet, Function};\n    kwargs...\n)\n\nApproximate the state space fractions fs of the basins of attraction of a dynamical system by mapping initial conditions to attractors using mapper (which contains a reference to a DynamicalSystem). The fractions are simply the ratios of how many initial conditions ended up at each attractor.\n\nInitial conditions to use are defined by ics. It can be:\n\na StateSpaceSet of initial conditions, in which case all are used.\na 0-argument function ics() that spits out random initial conditions. Then N random initial conditions are chosen. See statespace_sampler to generate such functions.\n\nReturn\n\nThe function will always return fractions, which is a dictionary whose keys are the labels given to each attractor (always integers enumerating the different attractors), and whose values are the respective basins fractions. The label -1 is given to any initial condition where mapper could not match to an attractor (this depends on the mapper type).\n\nIf ics is a StateSpaceSet the function will also return labels, which is a vector, of equal length to ics, that contains the label each initial condition was mapped to.\n\nSee AttractorMapper for all possible mapper types, and use extract_attractors (after calling basins_fractions) to extract the stored attractors from the mapper. See also convergence_and_basins_fractions.\n\nKeyword arguments\n\nN = 1000: Number of random initial conditions to generate in case ics is a function.\nshow_progress = true: Display a progress bar of the process.\n\n\n\n\n\nbasins_fractions(basins::AbstractArray [,ids]) → fs::Dict\n\nCalculate the state space fraction of the basins of attraction encoded in basins. The elements of basins are integers, enumerating the attractor that the entry of basins converges to (i.e., like the output of basins_of_attraction). Return a dictionary that maps attractor IDs to their relative fractions. Optionally you may give a vector of ids to calculate the fractions of only the chosen ids (by default ids = unique(basins)).\n\nIn (Menck et al., 2013) the authors use these fractions to quantify the stability of a basin of attraction, and specifically how it changes when a parameter is changed. For this, see continuation.\n\n\n\n\n\n","category":"function"},{"location":"basins/#Attractors.extract_attractors","page":"Basins of Attraction","title":"Attractors.extract_attractors","text":"extract_attractors(mapper::AttractorsMapper) → attractors\n\nReturn a dictionary mapping label IDs to attractors found by the mapper. This function should be called after calling basins_fractions with the given mapper so that the attractors have actually been found first.\n\nFor AttractorsViaFeaturizing, the attractors are only stored if the mapper was called with pre-defined initial conditions rather than a sampler (function returning initial conditions).\n\n\n\n\n\n","category":"function"},{"location":"basins/#Attractors.basins_of_attraction","page":"Basins of Attraction","title":"Attractors.basins_of_attraction","text":"basins_of_attraction(mapper::AttractorMapper, grid::Tuple) → basins, attractors\n\nCompute the full basins of attraction as identified by the given mapper, which includes a reference to a DynamicalSystem and return them along with (perhaps approximated) found attractors.\n\ngrid is a tuple of ranges defining the grid of initial conditions that partition the state space into boxes with size the step size of each range. For example, grid = (xg, yg) where xg = yg = range(-5, 5; length = 100). The grid has to be the same dimensionality as the state space expected by the integrator/system used in mapper. E.g., a ProjectedDynamicalSystem could be used for lower dimensional projections, etc. A special case here is a PoincareMap with plane being Tuple{Int, <: Real}. In this special scenario the grid can be one dimension smaller than the state space, in which case the partitioning happens directly on the hyperplane the Poincaré map operates on.\n\nbasins_of_attraction function is a convenience 5-lines-of-code wrapper which uses the labels returned by basins_fractions and simply assigns them to a full array corresponding to the state space partitioning indicated by grid.\n\nSee also convergence_and_basins_of_attraction.\n\n\n\n\n\nbasins_of_attraction(mapper::AttractorsViaRecurrences; show_progress = true)\n\nThis is a special method of basins_of_attraction that using recurrences does exactly what is described in the paper by Datseris & Wagemakers (Datseris and Wagemakers, 2022). By enforcing that the internal grid of mapper is the same as the grid of initial conditions to map to attractors, the method can further utilize found exit and attraction basins, making the computation faster as the grid is processed more and more.\n\n\n\n\n\n","category":"function"},{"location":"basins/#StateSpaceSets.statespace_sampler","page":"Basins of Attraction","title":"StateSpaceSets.statespace_sampler","text":"statespace_sampler(region [, seed = 42]) → sampler, isinside\n\nA function that facilitates sampling points randomly and uniformly in a state space region. It generates two functions:\n\nsampler is a 0-argument function that when called generates a random point inside a state space region. The point is always a Vector for type stability irrespectively of dimension. Generally, the generated point should be copied if it needs to be stored. (i.e., calling sampler() utilizes a shared vector) sampler is a thread-safe function.\nisinside is a 1-argument function that returns true if the given state space point is inside the region.\n\nThe region can be an instance of any of the following types (input arguments if not specified are vectors of length D, with D the state space dimension):\n\nHSphere(radius::Real, center): points inside the hypersphere (boundary excluded). Convenience method HSphere(radius::Real, D::Int) makes the center a D-long vector of zeros.\nHSphereSurface(radius, center): points on the hypersphere surface. Same convenience method as above is possible.\nHRectangle(mins, maxs): points in [min, max) for the bounds along each dimension.\n\nThe random number generator is always Xoshiro with the given seed.\n\n\n\n\n\nstatespace_sampler(grid::NTuple{N, AbstractRange} [, seed])\n\nIf given a grid that is a tuple of AbstractVectors, the minimum and maximum of the vectors are used to make an HRectangle region.\n\n\n\n\n\n","category":"function"},{"location":"basins/#Convergence-times","page":"Basins of Attraction","title":"Convergence times","text":"","category":"section"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"convergence_and_basins_fractions\nconvergence_and_basins_of_attraction\nconvergence_time","category":"page"},{"location":"basins/#Attractors.convergence_and_basins_fractions","page":"Basins of Attraction","title":"Attractors.convergence_and_basins_fractions","text":"convergence_and_basins_fractions(mapper::AttractorMapper, ics::StateSpaceSet)\n\nAn extension of basins_fractions. Return fs, labels, convergence. The first two are as in basins_fractions, and convergence is a vector containing the time each initial condition took to converge to its attractor. Only usable with mappers that support id = mapper(u0).\n\nSee also convergence_time.\n\nKeyword arguments\n\nshow_progress = true: show progress bar.\n\n\n\n\n\n","category":"function"},{"location":"basins/#Attractors.convergence_and_basins_of_attraction","page":"Basins of Attraction","title":"Attractors.convergence_and_basins_of_attraction","text":"convergence_and_basins_of_attraction(mapper::AttractorMapper, grid)\n\nAn extension of basins_of_attraction. Return basins, attractors, convergence, with basins, attractors as in basins_of_attraction, and convergence being an array with same shape as basins. It contains the time each initial condition took to converge to its attractor. It is useful to give to shaded_basins_heatmap.\n\nSee also convergence_time.\n\nKeyword arguments\n\nshow_progress = true: show progress bar.\n\n\n\n\n\n","category":"function"},{"location":"basins/#Attractors.convergence_time","page":"Basins of Attraction","title":"Attractors.convergence_time","text":"convergence_time(mapper::AttractorMapper) → t\n\nReturn the approximate time the mapper took to converge to an attractor. This function should be called just right after mapper(u0) was called with u0 the initial condition of interest. Hence it is only valid with AttractorMapper subtypes that support this syntax.\n\nObtaining the convergence time is computationally free, so that convergence_and_basins_fractions can always be used instead of basins_fractions.\n\n\n\n\n\n","category":"function"},{"location":"basins/#Final-state-sensitivity-/-fractal-boundaries","page":"Basins of Attraction","title":"Final state sensitivity / fractal boundaries","text":"","category":"section"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"Several functions are provided related with analyzing the fractality of the boundaries of the basins of attraction:","category":"page"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"basins_fractal_dimension\nbasin_entropy\nbasins_fractal_test\nuncertainty_exponent\ntest_wada_merge","category":"page"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"basins_fractal_dimension\nbasin_entropy\nbasins_fractal_test\nuncertainty_exponent\ntest_wada_merge","category":"page"},{"location":"basins/#Attractors.basins_fractal_dimension","page":"Basins of Attraction","title":"Attractors.basins_fractal_dimension","text":"basins_fractal_dimension(basins; kwargs...) -> V_ε, N_ε, d\n\nEstimate the fractal dimension d of the boundary between basins of attraction using a box-counting algorithm for the boxes that contain at least two different basin IDs.\n\nKeyword arguments\n\nrange_ε = 2:maximum(size(basins))÷20 is the range of sizes of the box to test (in pixels).\n\nDescription\n\nThe output N_ε is a vector with the number of the balls of radius ε (in pixels) that contain at least two initial conditions that lead to different attractors. V_ε is a vector with the corresponding size of the balls. The output d is the estimation of the box-counting dimension of the boundary by fitting a line in the log.(N_ε) vs log.(1/V_ε) curve. However it is recommended to analyze the curve directly for more accuracy.\n\nIt is the implementation of the popular algorithm of the estimation of the box-counting dimension. The algorithm search for a covering the boundary with N_ε boxes of size ε in pixels.\n\n\n\n\n\n","category":"function"},{"location":"basins/#Attractors.basin_entropy","page":"Basins of Attraction","title":"Attractors.basin_entropy","text":"basin_entropy(basins::Array, ε = 20) -> Sb, Sbb\n\nCompute the basin entropy (Daza et al., 2016) Sb and basin boundary entropy Sbb of the given basins of attraction by considering ε boxes along each dimension.\n\nDescription\n\nFirst, the input basins is divided regularly into n-dimensional boxes of side ε (along all dimensions). Then Sb is simply the average of the Gibbs entropy computed over these boxes. The function returns the basin entropy Sb as well as the boundary basin entropy Sbb. The later is the average of the entropy only for boxes that contains at least two different basins, that is, for the boxes on the boundaries.\n\nThe basin entropy is a measure of the uncertainty on the initial conditions of the basins. It is maximum at the value log(n_att) being n_att the number of attractors. In this case the boundary is intermingled: for a given initial condition we can find another initial condition that lead to another basin arbitrarily close. It provides also a simple criterion for fractality: if the boundary basin entropy Sbb is above log(2) then we have a fractal boundary. It doesn't mean that basins with values below cannot have a fractal boundary, for a more precise test see basins_fractal_test. An important feature of the basin entropy is that it allows comparisons between different basins using the same box size ε.\n\n\n\n\n\n","category":"function"},{"location":"basins/#Attractors.basins_fractal_test","page":"Basins of Attraction","title":"Attractors.basins_fractal_test","text":"basins_fractal_test(basins; ε = 20, Ntotal = 1000) -> test_res, Sbb\n\nPerform an automated test to decide if the boundary of the basins has fractal structures based on the method of Puy et al. (Puy et al., 2021). Return test_res (:fractal or :smooth) and the mean basin boundary entropy.\n\nKeyword arguments\n\nε = 20: size of the box to compute the basin boundary entropy.\nNtotal = 1000: number of balls to test in the boundary for the computation of Sbb\n\nDescription\n\nThe test \"looks\" at the basins with a magnifier of size ε at random. If what we see in the magnifier looks like a smooth boundary (onn average) we decide that the boundary is smooth. If it is not smooth we can say that at the scale ε we have structures, i.e., it is fractal.\n\nIn practice the algorithm computes the boundary basin entropy Sbb basin_entropy for Ntotal random boxes of radius ε. If the computed value is equal to theoretical value of a smooth boundary (taking into account statistical errors and biases) then we decide that we have a smooth boundary. Notice that the response test_res may depend on the chosen ball radius ε. For larger size, we may observe structures for smooth boundary and we obtain a different answer.\n\nThe output test_res is a symbol describing the nature of the basin and the output Sbb is the estimated value of the boundary basin entropy with the sampling method.\n\n\n\n\n\n","category":"function"},{"location":"basins/#Attractors.uncertainty_exponent","page":"Basins of Attraction","title":"Attractors.uncertainty_exponent","text":"uncertainty_exponent(basins; kwargs...) -> ε, N_ε, α\n\nEstimate the uncertainty exponent(Grebogi et al., 1983) of the basins of attraction. This exponent is related to the final state sensitivity of the trajectories in the phase space. An exponent close to 1 means basins with smooth boundaries whereas an exponent close to 0 represent completely fractalized basins, also called riddled basins.\n\nThe output N_ε is a vector with the number of the balls of radius ε (in pixels) that contain at least two initial conditions that lead to different attractors. The output α is the estimation of the uncertainty exponent using the box-counting dimension of the boundary by fitting a line in the log.(N_ε) vs log.(1/ε) curve. However it is recommended to analyze the curve directly for more accuracy.\n\nKeyword arguments\n\nrange_ε = 2:maximum(size(basins))÷20 is the range of sizes of the ball to test (in pixels).\n\nDescription\n\nA phase space with a fractal boundary may cause a uncertainty on the final state of the dynamical system for a given initial condition. A measure of this final state sensitivity is the uncertainty exponent. The algorithm probes the basin of attraction with balls of size ε at random. If there are a least two initial conditions that lead to different attractors, a ball is tagged \"uncertain\". f_ε is the fraction of \"uncertain balls\" to the total number of tries in the basin. In analogy to the fractal dimension, there is a scaling law between, f_ε ~ ε^α. The number that characterizes this scaling is called the uncertainty exponent α.\n\nNotice that the uncertainty exponent and the box counting dimension of the boundary are related. We have Δ₀ = D - α where Δ₀ is the box counting dimension computed with basins_fractal_dimension and D is the dimension of the phase space. The algorithm first estimates the box counting dimension of the boundary and returns the uncertainty exponent.\n\n\n\n\n\n","category":"function"},{"location":"basins/#Attractors.test_wada_merge","page":"Basins of Attraction","title":"Attractors.test_wada_merge","text":"test_wada_merge(basins, r) -> p\n\nTest if the 2D array basins has the Wada property using the merging technique of (Daza et al., 2018).\n\nDescription\n\nThe technique consists in computing the generalized basins of each attractor. These new basins are formed with on of the basins and the union of the other basins. A new boundary is defined by these two objects. The algorithm then computes the distance between each boundaries of these basins pairwise. If all the boundaries are within some distance r, there is a unique boundary separating the basins and we have the wada property. The algorithm returns the maximum proportion of pixels of a boundary with distance strictly greater than r from another boundary.\n\nIf p == 0,  we have the Wada property for this value of r. If p > 0, the criteria to decide if the basins are Wada is left to the user. Numerical inaccuracies may be responsible for a small percentage of points with distance larger than r\n\n\n\n\n\n","category":"function"},{"location":"basins/#Edge-tracking-and-edge-states","page":"Basins of Attraction","title":"Edge tracking and edge states","text":"","category":"section"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"The edge tracking algorithm allows to locate and construct so-called edge states (also referred to as Melancholia states) embedded in the basin boundary separating different basins of attraction. These could be saddle points, unstable periodic orbits or chaotic saddles. The general idea is that these sets can be found because they act as attractors when restricting to the basin boundary.","category":"page"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"edgetracking\nEdgeTrackingResults\nbisect_to_edge","category":"page"},{"location":"basins/#Attractors.edgetracking","page":"Basins of Attraction","title":"Attractors.edgetracking","text":"edgetracking(ds::DynamicalSystem, attractors::Dict; kwargs...)\n\nTrack along a basin boundary in a dynamical system ds with two or more attractors in order to find an edge state. Results are returned in the form of EdgeTrackingResults, which contains the pseudo-trajectory edge representing the track on the basin boundary, along with additional output (see below).\n\nThe system's attractors are specified as a Dict of StateSpaceSets, as in AttractorsViaProximity or the output of extract_attractors. By default, the algorithm is initialized from the first and second attractor in attractors. Alternatively, the initial states can be set via keyword arguments u1, u2 (see below). Note that the two initial states must belong to different basins of attraction.\n\nKeyword arguments\n\nbisect_thresh = 1e-7: distance threshold for bisection\ndiverge_thresh = 1e-6: distance threshold for parallel integration\nu1: first initial state (defaults to first point in first entry of attractors)\nu2: second initial state (defaults to first point in second entry of attractors)\nmaxiter = 100: maximum number of iterations before the algorithm stops\nabstol = 0.0: distance threshold for convergence of the updated edge state\nT_transient = 0.0: transient time before the algorithm starts saving the edge track\ntmax = Inf: maximum integration time of parallel trajectories until re-bisection \nΔt = 0.01: time step passed to step! when evolving the two trajectories\nϵ_mapper = nothing: ϵ parameter in AttractorsViaProximity\nshow_progress = true: if true, shows progress bar and information while running\nverbose = true: if false, silences print output and warnings while running\nkwargs...: additional keyword arguments to be passed to AttractorsViaProximity\n\nDescription\n\nThe edge tracking algorithm is a numerical method to find an edge state or (possibly chaotic) saddle on the boundary between two basins of attraction. Introduced by (Battelino et al., 1988) and further described by (Skufca et al., 2006), the algorithm has been applied to, e.g., the laminar-turbulent boundary in plane Couette flow (Schneider et al., 2008), Wada basins (Wagemakers et al., 2020), as well as Melancholia states in conceptual (Mehling et al., 2023) and intermediate-complexity (Lucarini and Bódai, 2017)  climate models.  Relying only on forward integration of the system, it works even in high-dimensional systems with complicated fractal basin boundary structures.\n\nThe algorithm consists of two main steps: bisection and tracking. First, it iteratively  bisects along a straight line in state space between the intial states u1 and u2 to find the separating basin boundary. The bisection stops when the two updated states are less than bisect_thresh (Euclidean distance in state space) apart from each other. Next, a ParallelDynamicalSystem is initialized from these two updated states and integrated forward until the two trajectories diverge from each other by more than diverge_thresh (Euclidean distance). The two final states of the parallel integration are then used as new states u1 and u2 for a new bisection, and  so on, until a stopping criterion is fulfilled. \n\nTwo stopping criteria are implemented via the keyword arguments maxiter and abstol. Either the algorithm stops when the number of iterations reaches maxiter, or when the state space position of the updated edge point changes by less than abstol (in Euclidean distance) compared to the previous iteration. Convergence below abstol happens after sufficient iterations if the edge state is a saddle point. However, the edge state may also be an unstable limit cycle or a chaotic saddle. In these cases, the algorithm will never actually converge to a point but (after a transient period) continue populating the set constituting the edge state by tracking along it.\n\nA central idea behind this algorithm is that basin boundaries are typically the stable manifolds of unstable sets, namely edge states or saddles. The flow along the basin boundary  will thus lead to these sets, and the iterative bisection neutralizes the unstable direction of the flow away from the basin boundary. If the system possesses multiple edge  states, the algorithm will find one of them depending on where the initial bisection locates the boundary.\n\nOutput\n\nReturns a data type EdgeTrackingResults containing the results.\n\nSometimes, the AttractorMapper used in the algorithm may erroneously identify both states u1 and u2 with the same basin of attraction due to being very close to the basin boundary. If this happens, a warning is raised and EdgeTrackingResults.success = false.\n\n\n\n\n\nedgetracking(pds::ParallelDynamicalSystem, mapper::AttractorMapper; kwargs...)\n\nLow-level function for running the edge tracking algorithm, see edgetracking for a description, keyword arguments and output type.\n\npds is a ParallelDynamicalSystem with two states. The mapper must be an AttractorMapper of subtype AttractorsViaProximity or AttractorsViaRecurrences.\n\n\n\n\n\n","category":"function"},{"location":"basins/#Attractors.EdgeTrackingResults","page":"Basins of Attraction","title":"Attractors.EdgeTrackingResults","text":"EdgeTrackingResults(edge, track1, track2, time, bisect_idx)\n\nData type that stores output of the edgetracking algorithm.\n\nFields\n\nedge::StateSpaceSet: the pseudo-trajectory representing the tracked edge segment (given by the average in state space between track1 and track2)\ntrack1::StateSpaceSet: the pseudo-trajectory tracking the edge within basin 1\ntrack2::StateSpaceSet: the pseudo-trajectory tracking the edge within basin 2\ntime::Vector: time points of the above StateSpaceSets\nbisect_idx::Vector: indices of time at which a re-bisection occurred\nsuccess::Bool: indicates whether the edge tracking has been successful or not\n\n\n\n\n\n","category":"type"},{"location":"basins/#Attractors.bisect_to_edge","page":"Basins of Attraction","title":"Attractors.bisect_to_edge","text":"bisect_to_edge(pds::ParallelDynamicalSystem, mapper::AttractorMapper; kwargs...) -> u1, u2\n\nFinds the basin boundary between two states u1, u2 = current_states(pds) by bisecting along a straight line in phase space. The states u1 and u2 must belong to different basins.\n\nReturns a triple u1, u2, success, where u1, u2 are two new states located on either side of the basin boundary that lie less than bisect_thresh (Euclidean distance in state space) apart from each other, and success is a Bool indicating whether the bisection was successful (it may fail if the mapper maps both states to the same basin of attraction, in which case a warning is raised).\n\nKeyword arguments\n\nbisect_thresh = 1e-7: The maximum (Euclidean) distance between the two returned states.\n\nDescription\n\npds is a ParallelDynamicalSystem with two states. The mapper must be an AttractorMapper of subtype AttractorsViaProximity or AttractorsViaRecurrences.\n\ninfo: Info\nIf the straight line between u1 and u2 intersects the basin boundary multiple times, the method will find one of these intersection points. If more than two attractors exist, one of the two returned states may belong to a different basin than the initial conditions u1 and u2. A warning is raised if the bisection involves a third basin.\n\n\n\n\n\n","category":"function"},{"location":"basins/#Tipping-points","page":"Basins of Attraction","title":"Tipping points","text":"","category":"section"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"This page discusses functionality related with tipping points in dynamical systems with known rule. If instead you are interested in identifying tipping points in measured timeseries, have a look at TransitionIndicators.jl.","category":"page"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"tipping_probabilities","category":"page"},{"location":"basins/#Attractors.tipping_probabilities","page":"Basins of Attraction","title":"Attractors.tipping_probabilities","text":"tipping_probabilities(basins_before, basins_after) → P\n\nReturn the tipping probabilities of the computed basins before and after a change in the system parameters (or time forcing), according to the definition of (Kaszás et al., 2019).\n\nThe input basins are integer-valued arrays, where the integers enumerate the attractor, e.g. the output of basins_of_attraction.\n\nDescription\n\nLet mathcalB_i(p) denote the basin of attraction of attractor A_i at parameter(s) p. Kaszás et al (Kaszás et al., 2019) define the tipping probability from A_i to A_j, given a parameter change in the system of p_- to p_+, as\n\nP(A_i to A_j  p_- to p_+) =\nfracmathcalB_j(p_+) cap mathcalB_i(p_-)mathcalB_i(p_-)\n\nwhere cdot is simply the volume of the enclosed set. The value of P(A_i to A_j  p_- to p_+) is P[i, j]. The equation describes something quite simple: what is the overlap of the basin of attraction of A_i at p_- with that of the attractor A_j at p_+. If basins_before, basins_after contain values of -1, corresponding to trajectories that diverge, this is considered as the last attractor of the system in P.\n\n\n\n\n\n","category":"function"},{"location":"basins/#Minimal-Fatal-Shock","page":"Basins of Attraction","title":"Minimal Fatal Shock","text":"","category":"section"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"The algorithm to find minimal perturbation for arbitrary initial condition u0 which will kick the system into different from the current basin.","category":"page"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"minimal_fatal_shock\nMFSBlackBoxOptim\nMFSBruteForce","category":"page"},{"location":"basins/#Attractors.minimal_fatal_shock","page":"Basins of Attraction","title":"Attractors.minimal_fatal_shock","text":"minimal_fatal_shock(mapper::AttractorMapper, u0, search_area, algorithm; kw...)\n\nReturn the minimal fatal shock mfs (also known as excitability threshold) for the initial point u0 according to the specified algorithm given a mapper that satisfies the id = mapper(u0) interface (see AttractorMapper if you are not sure which mappers do that). The mapper contains a reference to a DynamicalSystem. The options for algorithm are: MFSBruteForce or MFSBlackBoxOptim. For high dimensional systems MFSBlackBoxOptim is likely more accurate.\n\nThe search_area dictates the state space range for the search of the mfs. It can be a 2-tuple of (min, max) values, in which case the same values are used for each dimension of the system in mapper. Otherwise, it can be a vector of 2-tuples, each for each dimension of the system. The search area is defined w.r.t. to u0 (i.e., it is the search area for perturbations of u0).\n\nAn alias to minimal_fata_shock is excitability_threshold.\n\nKeyword arguments\n\nmetric = LinearAlgebra.norm: a metric function that gives the norm of a perturbation vector. This keyword is ignored for the MFSBruteForce algorithm.\ntarget_id = nothing: when not nothing, it should be an integer or a vector of integers corresponding to target attractor label(s). Then, the MFS is estimated based only on perturbations that lead to the target attractor(s).\n\nDescription\n\nThe minimal fatal shock is defined as the smallest-norm perturbation of the initial point u0 that will lead it a different basin of attraction. It is inspired by the paper \"Minimal fatal shocks in multistable complex networks\" (Halekotte and Feudel, 2020), however the implementation here is generic: it works for any dynamical system.\n\nThe excitability threshold is a concept nearly identical, however, instead of looking for a perturbation that simply brings us out of the basin, we look for the smallest perturbation that brings us into specified basin(s). This is enabled via the keyword target_id.\n\n\n\n\n\n","category":"function"},{"location":"basins/#Attractors.MFSBlackBoxOptim","page":"Basins of Attraction","title":"Attractors.MFSBlackBoxOptim","text":"MFSBlackBoxOptim(; kwargs...)\n\nThe black box derivative-free optimization algorithm used in minimal_fatal_shock.\n\nKeyword arguments\n\nguess = nothing: a initial guess for the minimal fatal shock given to the optimization algorithm. If not nothing, random_algo below is ignored.\nmax_steps = 10000: maximum number of steps for the optimization algorithm.\npenalty = 1000.0: penalty value for the objective function for perturbations that do not lead to a different basin of attraction. This value is added to the norm of the perturbation and its value should be much larger than the typical sizes of the basins of attraction.\nprint_info: boolean value, if true, the optimization algorithm will print information on the evaluation steps of objective function, default = false.\nrandom_algo = MFSBruteForce(100, 100, 0.99): an instance of MFSBruteForce that can be used to provide an initial guess.\nbbkwargs = NamedTuple(): additional keyword arguments propagated to BlackBoxOptim.bboptimize for selecting solver, accuracy, and more.\n\nDescription\n\nThe algorithm uses BlackBoxOptim.jl and a penalized objective function to minimize. y function used as a constraint function. So, if we hit another basin during the search we encourage the algorithm otherwise we punish it with some penalty. The function to minimize is (besides some details):\n\nfunction mfs_objective(perturbation, u0, mapper, penalty)\n    dist = norm(perturbation)\n    if mapper(u0 + perturbation) == mapper(u0)\n        # penalize if we stay in the same basin:\n        return dist + penalty\n    else\n        return dist\n    end\nend\n\nUsing an initial guess can be beneficial to both performance and accuracy, which is why the output of a crude MFSBruteForce is used to provide a guess. This can be disabled by either passing a guess vector explicitly or by giving nothing as random_algo.\n\n\n\n\n\n","category":"type"},{"location":"basins/#Attractors.MFSBruteForce","page":"Basins of Attraction","title":"Attractors.MFSBruteForce","text":"MFSBruteForce(; kwargs...)\n\nThe brute force randomized search algorithm used in minimal_fatal_shock.\n\nIt consists of two steps: random initialization and sphere radius reduction. On the first step, the algorithm generates random perturbations within the search area and records the perturbation that leads to a different basin but with the smallest magnitude. With this obtained perturbation it proceeds to the second step. On the second step, the algorithm generates random perturbations on the surface of the hypersphere with radius equal to the norm of the perturbation found in the first step. It reduces the radius of the hypersphere and continues searching for the better result with a smaller radius. Each time a better result is found, the radius is reduced further.\n\nThe algorithm records the perturbation with smallest radius that leads to a different basin.\n\nKeyword arguments\n\ninitial_iterations = 10000: number of random perturbations to try in the first step of the algorithm.\nsphere_iterations = 10000: number of steps while initializing random points on hypersphere and decreasing its radius.\nsphere_decrease_factor = 0.999 factor by which the radius of the hypersphere is decreased (at each step the radius is multiplied by this number). Number closer to 1 means more refined accuracy\n\n\n\n\n\n","category":"type"},{"location":"continuation/#Attractor-and-Basins-Continuation","page":"Attractor & Basins Continuation","title":"Attractor & Basins Continuation","text":"","category":"section"},{"location":"continuation/#A-new-kind-of-continuation","page":"Attractor & Basins Continuation","title":"A new kind of continuation","text":"","category":"section"},{"location":"continuation/","page":"Attractor & Basins Continuation","title":"Attractor & Basins Continuation","text":"If you have heard before the word \"continuation\", then you are likely aware of the traditional continuation-based bifurcation analysis (CBA) offered by many software, such as AUTO, MatCont, and in Julia BifurcationKit.jl. Here we offer a completely different kind of continuation called attractors & basins continuation.","category":"page"},{"location":"continuation/","page":"Attractor & Basins Continuation","title":"Attractor & Basins Continuation","text":"A direct comparison of the two approaches is not truly possible, because they do different things. The traditional linearized continuation analysis continues the curves of individual fixed points across the joint state-parameter space. The attractor and basins continuation first finds all attractors at all parameter values and then matches appropriately similar attractors across different parameters, giving the illusion of continuing them individually. Additionally, the curves of stable fixed points in the joint parameter space is only a small by-product of the attractor basins continuation, and the main information is the basin fractions and how these change in the parameter space.","category":"page"},{"location":"continuation/","page":"Attractor & Basins Continuation","title":"Attractor & Basins Continuation","text":"A more detailed comparison between these two fundamentally different approaches in is given in high detail in our paper.","category":"page"},{"location":"continuation/#Continuation-API","page":"Attractor & Basins Continuation","title":"Continuation API","text":"","category":"section"},{"location":"continuation/","page":"Attractor & Basins Continuation","title":"Attractor & Basins Continuation","text":"continuation","category":"page"},{"location":"continuation/#Attractors.continuation","page":"Attractor & Basins Continuation","title":"Attractors.continuation","text":"continuation(abc::AttractorsBasinsContinuation, prange, pidx, ics; kwargs...)\n\nFind and continue attractors (or feature-based representations of attractors) and the fractions of their basins of attraction across a parameter range. continuation is the central function of the framework for global stability analysis illustrated in (Datseris et al., 2023).\n\nThe continuation type abc is a subtype of AttractorsBasinsContinuation and contains an AttractorMapper. The mapper contains information on how to find the attractors and basins of a dynamical system. Additional arguments and keyword arguments given when creating abc further tune the continuation and how attractors are matched across different parameter values.\n\nThe basin fractions and the attractors (or some representation of them) are continued across the parameter range prange, for the parameter of the system with index pidx (any index valid in set_parameter! can be used).\n\nics is a 0-argument function generating initial conditions for the dynamical system (as in basins_fractions).\n\nPossible subtypes of AttractorsBasinsContinuation are:\n\nRecurrencesFindAndMatch\nFeaturizeGroupAcrossParameter\n\nReturn\n\nfractions_curves::Vector{Dict{Int, Float64}}. The fractions of basins of attraction. fractions_curves[i] is a dictionary mapping attractor IDs to their basin fraction at the i-th parameter.\nattractors_info::Vector{Dict{Int, <:Any}}. Information about the attractors. attractors_info[i] is a dictionary mapping attractor ID to information about the attractor at the i-th parameter. The type of information stored depends on the chosen continuation type.\n\nKeyword arguments\n\nshow_progress = true: display a progress bar of the computation.\nsamples_per_parameter = 100: amount of initial conditions sampled at each parameter from ics.\n\n\n\n\n\n","category":"function"},{"location":"continuation/#Recurrences-continuation-(best)","page":"Attractor & Basins Continuation","title":"Recurrences continuation (best)","text":"","category":"section"},{"location":"continuation/","page":"Attractor & Basins Continuation","title":"Attractor & Basins Continuation","text":"RecurrencesFindAndMatch","category":"page"},{"location":"continuation/#Attractors.RecurrencesFindAndMatch","page":"Attractor & Basins Continuation","title":"Attractors.RecurrencesFindAndMatch","text":"RecurrencesFindAndMatch <: AttractorsBasinsContinuation\nRecurrencesFindAndMatch(mapper::AttractorsViaRecurrences; kwargs...)\n\nA method for continuation as in (Datseris et al., 2023) that is based on the recurrences algorithm for finding attractors (AttractorsViaRecurrences) and the \"matching attractors\" functionality offered by match_continuation!.\n\nYou can use RAFM as an alias.\n\nKeyword arguments\n\ndistance = Centroid(), threshold = Inf, use_vanished = !isinf(threshold): propagated to match_continuation!.\ninfo_extraction = identity: A function that takes as an input an attractor (StateSpaceSet) and outputs whatever information should be stored. It is used to return the attractors_info in continuation. Note that the same attractors that are stored in attractors_info are also used to perform the matching in match_continuation!, hence this keyword should be altered with care.\nseeds_from_attractor: A function that takes as an input an attractor and returns an iterator of initial conditions to be seeded from the attractor for the next parameter slice. By default, we sample only the first stored point on the attractor.\n\nDescription\n\nAt the first parameter slice of the continuation process, attractors and their fractions are found as described in the AttractorsViaRecurrences mapper using recurrences in state space. At each subsequent parameter slice, new attractors are found by seeding initial conditions from the previously found attractors and then running these initial conditions through the recurrences algorithm of the mapper. Seeding initial conditions close to previous attractors accelerates the main bottleneck of AttractorsViaRecurrences, which is finding the attractors.\n\nAfter the special initial conditions are mapped to attractors, attractor basin fractions are computed by sampling random initial conditions using the provided sampler in continuation) and mapping them to attractors using the AttractorsViaRecurrences mapper. I.e., exactly as in basins_fractions. Naturally, during this step new attractors may be found, besides those found using the \"seeding from previous attractors\". Once the basins fractions are computed, the parameter is incremented again and we perform the steps as before.\n\nThis process continues for all parameter values. After all parameters are exhausted, the found attractors (and their fractions) are \"matched\" to the previous ones. I.e., their IDs are changed, so that attractors that are \"similar\" to those at a previous parameter get assigned the same ID. Matching is done by the match_continuation! function and is an orthogonal step. This means, that if you don't like the initial outcome of the matching process, you may call match_continuation! again on the outcome with different matching-related keywords. You do not need to compute attractors and basins again!\n\nMatching is a very sophisticated process that can be understood in detail by reading the docstrings of match_statespacesets! first and then match_continuation!. Here is a short summary: attractors from previous and current parameter are matched based on their \"distance\". By default this is distance in state space, but any measure of \"distance\" may be used, such as the distance between Lyapunov spectra. Matching prioritizes new->old pairs with smallest distance: once these are matched the next available new->old pair with smallest distance is matched, until all new/old attractors have been matched. The threshold keyword establishes that attractors with distance > threshold do not get matched. Additionally, use use_vanished = true if you want to include as matching candidates attractors that have vanished during the continuation process.\n\n\n\n\n\n","category":"type"},{"location":"continuation/#Matching-attractors","page":"Attractor & Basins Continuation","title":"Matching attractors","text":"","category":"section"},{"location":"continuation/","page":"Attractor & Basins Continuation","title":"Attractor & Basins Continuation","text":"match_statespacesets!\nCentroid\nHausdorff\nStrictlyMinimumDistance\nreplacement_map\nset_distance\nsetsofsets_distances\nmatch_continuation!\nmatch_basins_ids!","category":"page"},{"location":"continuation/#Attractors.match_statespacesets!","page":"Attractor & Basins Continuation","title":"Attractors.match_statespacesets!","text":"match_statespacesets!(a₊::AbstractDict, a₋; distance = Centroid(), threshold = Inf)\n\nGiven dictionaries a₊, a₋ mapping IDs to StateSpaceSet instances, match the IDs in dictionary a₊ so that its sets that are the closest to those in dictionary a₋ get assigned the same key as in a₋. Typically the +,- mean after and before some change of parameter of a system.\n\nReturn the replacement map, a dictionary mapping old keys of a₊ to the new ones that they were mapped to. You can obtain this map, without modifying the dictionaries, by calling the replacement_map function directly.\n\nKeyword arguments\n\ndistance = Centroid(): given to setsofsets_distances.\nthreshold = Inf: attractors with distance larger than the threshold are guaranteed to not be mapped to each other.\n\nDescription\n\nThe distance between all possible pairs of sets between the \"old\" and \"new\" containers is computed using setsofsets_distances with the keyword distance. distance can be whatever that function accepts, i.e., one of Centroid, Hausdorff, StrictlyMinimumDistance or any arbitrary user- provided function that given two sets it returns a positive number (their distance). State space sets are then matched according to this distance. First, all possible pairs (old, new, distance) are sorted according to their distance. The pair with smallest distance is matched. Sets in matched pairs are removed from the matching pool to ensure a unique mapping. Then, the next pair with least remaining distance is matched, and the process repeats until all pairs are exhausted.\n\nAdditionally, you can provide a threshold value. If the distance between two attractors is larger than this threshold, then it is guaranteed that the attractors will get assigned different key in the dictionary a₊ (which is the next available integer).\n\n\n\n\n\n","category":"function"},{"location":"continuation/#StateSpaceSets.Centroid","page":"Attractor & Basins Continuation","title":"StateSpaceSets.Centroid","text":"Centroid(metric = Euclidean())\n\nA distance that can be used in set_distance. The Centroid method returns the distance (according to metric) between the centroids (a.k.a. centers of mass) of the sets.\n\nmetric can be any function that takes in two static vectors are returns a positive definite number to use as a distance (and typically is a Metric from Distances.jl).\n\n\n\n\n\n","category":"type"},{"location":"continuation/#StateSpaceSets.Hausdorff","page":"Attractor & Basins Continuation","title":"StateSpaceSets.Hausdorff","text":"Hausdorff(metric = Euclidean())\n\nA distance that can be used in set_distance. The Hausdorff distance is the greatest of all the distances from a point in one set to the closest point in the other set. The distance is calculated with the metric given to Hausdorff which defaults to Euclidean.\n\nHausdorff is 2x slower than StrictlyMinimumDistance, however it is a proper metric in the space of sets of state space sets.\n\n\n\n\n\n","category":"type"},{"location":"continuation/#StateSpaceSets.StrictlyMinimumDistance","page":"Attractor & Basins Continuation","title":"StateSpaceSets.StrictlyMinimumDistance","text":"StrictlyMinimumDistance([brute = false,] [metric = Euclidean(),])\n\nA distance that can be used in set_distance. The StrictlyMinimumDistance returns the minimum distance of all the distances from a point in one set to the closest point in the other set. The distance is calculated with the given metric.\n\nThe brute::Bool argument switches the computation between a KDTree-based version, or brute force (i.e., calculation of all distances and picking the smallest one). Brute force performs better for datasets that are either large dimensional or have a small amount of points. Deciding a cutting point is not trivial, and is recommended to simply benchmark the set_distance function to make a decision.\n\n\n\n\n\n","category":"type"},{"location":"continuation/#Attractors.replacement_map","page":"Attractor & Basins Continuation","title":"Attractors.replacement_map","text":"replacement_map(a₊, a₋; distance = Centroid(), threshold = Inf) → rmap\n\nReturn a dictionary mapping keys in a₊ to new keys in a₋, as explained in match_statespacesets!.\n\n\n\n\n\n","category":"function"},{"location":"continuation/#StateSpaceSets.set_distance","page":"Attractor & Basins Continuation","title":"StateSpaceSets.set_distance","text":"set_distance(ssset1, ssset2 [, distance])\n\nCalculate a distance between two StateSpaceSets, i.e., a distance defined between sets of points, as dictated by distance.\n\nPossible distance types are:\n\nCentroid, which is the default, and 100s of times faster than the rest\nHausdorff\nStrictlyMinimumDistance\n\n\n\n\n\n","category":"function"},{"location":"continuation/#StateSpaceSets.setsofsets_distances","page":"Attractor & Basins Continuation","title":"StateSpaceSets.setsofsets_distances","text":"setsofsets_distances(a₊, a₋ [, distance]) → distances\n\nCalculate distances between sets of StateSpaceSets. Here  a₊, a₋ are containers of StateSpaceSets, and the returned distances are dictionaries of distances. Specifically, distances[i][j] is the distance of the set in the i key of a₊ to the j key of a₋. Notice that distances from a₋ to a₊ are not computed at all (assumming symmetry in the distance function).\n\nThe distance can be as in set_distance, or it can be an arbitrary function that takes as input two state space sets and returns any positive-definite number as their \"distance\".\n\n\n\n\n\n","category":"function"},{"location":"continuation/#Attractors.match_continuation!","page":"Attractor & Basins Continuation","title":"Attractors.match_continuation!","text":"match_continuation!(fractions_curves::Vector{<:Dict}, attractors_info::Vector{<:Dict}; kwargs...)\n\nLoop over all entries in the given arguments (which are typically the direct outputs of continuation), and match the attractor IDs in both the attractors container and the basins fractions container. This means that we loop over each entry of the vectors (skipping the first), and in each entry we attempt to match the current dictionary keys to the keys of the previous dictionary using match_statespacesets!.\n\nThe keywords distance, threshold are propagated to match_statespacesets!. However, there are two unique keywords for match_continuation!:\n\nuse_vanished::Bool\nretract_keys::Bool\n\nIf use_vanised = true, then attractors that existed before but have vanished are kept in \"memory\" when it comes to matching: the new attractors are compared to the latest instance of all attractors that have ever existed, and get matched to their closest ones as per match_statespacesets!. If false, vanished attractors are ignored. Note that in this case new attractors that cannot be matched to any previous attractors will get an appropriately incremented ID. E.g., if we started with three attractors, and attractor 3 vanished, and at some later parameter value we again have three attractors, the new third attractor will not have ID 3, but 4 (i.e., the next available ID).\n\nBy default use_vanished = !isinf(threshold) and since the default value for threshold is Inf, use_vanished is false.\n\nThe last keyword is retract_keys = true which will \"retract\" keys (i.e., make the integers smaller integers) so that all unique IDs are the 1-incremented positive integers. E.g., if the IDs where 1, 6, 8, they will become 1, 2, 3. The special id -1 is unaffected by this.\n\nmatch_continuation!(attractors_info::Vector{<:Dict}; kwargs...)\n\nThis is a convenience method that only uses and modifies the state space set dictionary container without the need for a basins fractions container.\n\n\n\n\n\n","category":"function"},{"location":"continuation/#Attractors.match_basins_ids!","page":"Attractor & Basins Continuation","title":"Attractors.match_basins_ids!","text":"match_basins_ids!(b₊::AbstractArray, b₋; threshold = Inf)\n\nSimilar to match_statespacesets! but operate on basin arrays instead (the arrays typically returned by basins_of_attraction).\n\nThis method matches IDs of attractors whose basins of attraction before and after b₋,b₊ have the most overlap (in pixels). This overlap is normalized in 0-1 (with 1 meaning 100% overlap of pixels). The threshold in this case is compared to the inverse of the overlap (so, for threshold = 2 attractors that have less than 50% overlap get different IDs guaranteed).\n\n\n\n\n\n","category":"function"},{"location":"continuation/#Aggregating-attractors-and-fractions","page":"Attractor & Basins Continuation","title":"Aggregating attractors and fractions","text":"","category":"section"},{"location":"continuation/","page":"Attractor & Basins Continuation","title":"Attractor & Basins Continuation","text":"aggregate_attractor_fractions","category":"page"},{"location":"continuation/#Attractors.aggregate_attractor_fractions","page":"Attractor & Basins Continuation","title":"Attractors.aggregate_attractor_fractions","text":"aggregate_attractor_fractions(\n    fractions_curves, attractors_info, featurizer, group_config [, info_extraction]\n)\n\nAggregate the already-estimated curves of fractions of basins of attraction of similar attractors using the same pipeline used by GroupingConfig. The most typical application of this function is to transform the output of RecurrencesFindAndMatch so that similar attractors, even across parameter space, are grouped into one \"attractor\". Thus, the fractions of their basins are aggregated.\n\nYou could also use this function to aggregate attractors and their fractions even in a single parameter configuration, i.e., using the output of basins_fractions.\n\nThis function is useful in cases where you want the accuracy and performance of AttractorsViaRecurrences, but you also want the convenience of \"grouping\" similar attractrors like in AttractorsViaFeaturizing for presentation or analysis purposes. For example, a high dimensional model of competition dynamics across multispecies may have extreme multistability. After finding this multistability however, one may care about aggregating all attractors into two groups: where a given species is extinct or not. This is the example highlighted in our documentation, in Extinction of a species in a multistable competition model.\n\nInput\n\nfractions_curves: a vector of dictionaries mapping labels to basin fractions.\nattractors_info: a vector of dictionaries mapping labels to attractors. 1st and 2nd argument are exactly like the return values of continuation with RecurrencesFindAndMatch (or, they can be the return of basins_fractions).\nfeaturizer: a 1-argument function to map an attractor into an appropriate feature to be grouped later. Features expected by GroupingConfig are SVector.\ngroup_config: a subtype of GroupingConfig.\ninfo_extraction: a function accepting a vector of features and returning a description of the features. I.e., exactly as in FeaturizeGroupAcrossParameter. The 5th argument is optional and defaults to the centroid of the features.\n\nReturn\n\naggregated_fractions: same as fractions_curves but now contains the fractions of the aggregated attractors.\naggregated_info: dictionary mapping the new labels of aggregated_fractions to the extracted information using info_extraction.\n\nClustering attractors directly\n\n(this is rather advanced)\n\nYou may also use the DBSCAN clustering approach here to group attractors based on their state space distance (the set_distance) by making a distance matrix as expected by the DBSCAN implementation. For this, use identity as featurizer, and choose GroupViaClustering as the group_config with clust_distance_metric = set_distance and provide a numerical value for optimal_radius_method when initializing the GroupViaClustering, and also, for the info_extraction argument, you now need to provide a function that expects a vector of StateSpaceSets and outputs a descriptor. E.g., info_extraction = vector -> mean(mean(x) for x in vector).\n\n\n\n\n\n","category":"function"},{"location":"continuation/#Grouping-continuation","page":"Attractor & Basins Continuation","title":"Grouping continuation","text":"","category":"section"},{"location":"continuation/","page":"Attractor & Basins Continuation","title":"Attractor & Basins Continuation","text":"FeaturizeGroupAcrossParameter","category":"page"},{"location":"continuation/#Attractors.FeaturizeGroupAcrossParameter","page":"Attractor & Basins Continuation","title":"Attractors.FeaturizeGroupAcrossParameter","text":"FeaturizeGroupAcrossParameter <: AttractorsBasinsContinuation\nFeaturizeGroupAcrossParameter(mapper::AttractorsViaFeaturizing; kwargs...)\n\nA method for continuation. It uses the featurizing approach discussed in AttractorsViaFeaturizing and hence requires an instance of that mapper as an input. When used in continuation, features are extracted and then grouped across a parameter range. Said differently, all features of all initial conditions across all parameter values are put into the same \"pool\" and then grouped as dictated by the group_config of the mapper. After the grouping is finished the feature label fractions are distributed to each parameter value they came from.\n\nKeyword arguments\n\ninfo_extraction::Function a function that takes as an input a vector of feature-vectors (corresponding to a cluster) and returns a description of the cluster. By default, the centroid of the cluster is used.\npar_weight = 0: See below the section on MCBB.\n\nMCBB special version\n\nIf the chosen grouping method is GroupViaClustering, the additional keyword par_weight::Real can be used. If it is ≠ 0, the distance matrix between features obtains an extra weight that is proportional to the distance par_weight*|p[i] - p[j]| between the parameters used when extracting features. The range of parameters is normalized to 0-1 such that the largest distance in the parameter space is 1. The normalization is done because the feature space is also (by default) normalized to 0-1.\n\nThis version of the algorithm is the original \"MCBB\" continuation method described in (Gelbrecht et al., 2020), besides the improvements of clustering accuracy and performance done by the developer team of Attractors.jl.\n\n\n\n\n\n","category":"type"},{"location":"examples/#Examples-for-Attractors.jl","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Note that the examples utilize some convenience plotting functions offered by Attractors.jl which come into scope when using Makie (or any of its backends such as CairoMakie), see the visualization utilities for more.","category":"page"},{"location":"examples/#Newton's-fractal-(basins-of-2D-map)","page":"Examples for Attractors.jl","title":"Newton's fractal (basins of 2D map)","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using Attractors\nfunction newton_map(z, p, n)\n    z1 = z[1] + im*z[2]\n    dz1 = newton_f(z1, p[1])/newton_df(z1, p[1])\n    z1 = z1 - dz1\n    return SVector(real(z1), imag(z1))\nend\nnewton_f(x, p) = x^p - 1\nnewton_df(x, p)= p*x^(p-1)\n\nds = DiscreteDynamicalSystem(newton_map, [0.1, 0.2], [3.0])\nxg = yg = range(-1.5, 1.5; length = 400)\ngrid = (xg, yg)\n# Use non-sparse for using `basins_of_attraction`\nmapper_newton = AttractorsViaRecurrences(ds, grid;\n    sparse = false, consecutive_lost_steps = 1000\n)\nbasins, attractors = basins_of_attraction(mapper_newton; show_progress = false)\nbasins","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"attractors","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Now let's plot this as a heatmap, and on top of the heatmap, let's scatter plot the attractors. We do this in one step by utilizing one of the pre-defined plotting functions offered by Attractors.jl","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using CairoMakie\nfig = heatmap_basins_attractors(grid, basins, attractors)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Instead of computing the full basins, we could get only the fractions of the basins of attractions using basins_fractions, which is typically the more useful thing to do in a high dimensional system. In such cases it is also typically more useful to define a sampler that generates initial conditions on the fly instead of pre-defining some initial conditions (as is done in basins_of_attraction. This is simple to do:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"sampler, = statespace_sampler(grid)\n\nbasins = basins_fractions(mapper_newton, sampler)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"in this case, to also get the attractors we simply extract them from the underlying storage of the mapper:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"attractors = extract_attractors(mapper_newton)","category":"page"},{"location":"examples/#Shading-basins-according-to-convergence-time","page":"Examples for Attractors.jl","title":"Shading basins according to convergence time","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Continuing from above, we can utilize the convergence_and_basins_of_attraction function, and the shaded_basins_heatmap plotting utility function, to shade the basins of attraction based on the convergence time, with lighter colors indicating faster convergence to the attractor.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"mapper_newton = AttractorsViaRecurrences(ds, grid;\n    sparse = false, consecutive_lost_steps = 1000\n)\n\nbasins, attractors, iterations = convergence_and_basins_of_attraction(\n    mapper_newton, grid; show_progress = false\n)\n\nshaded_basins_heatmap(grid, basins, attractors, iterations)","category":"page"},{"location":"examples/#Minimal-Fatal-Shock","page":"Examples for Attractors.jl","title":"Minimal Fatal Shock","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Here we find the Minimal Fatal Shock (MFS, see minimal_fatal_shock) for the attractors (i.e., fixed points) of Newton's fractal","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"shocks = Dict()\nalgo_bb = Attractors.MFSBlackBoxOptim()\nfor atr in values(attractors)\n    u0 = atr[1]\n    shocks[u0] = minimal_fatal_shock(mapper_newton, u0, (-1.5,1.5), algo_bb)\nend\nshocks","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"To visualize results we can make use of previously defined heatmap","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"ax =  content(fig[1,1])\nfor (atr, shock) in shocks\n    lines!(ax, [atr, atr + shock]; color = :orange, linewidth = 3)\nend\nfig","category":"page"},{"location":"examples/#Fractality-of-2D-basins-of-the-(4D)-magnetic-pendulum","page":"Examples for Attractors.jl","title":"Fractality of 2D basins of the (4D) magnetic pendulum","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"In this section we will calculate the basins of attraction of the four-dimensional magnetic pendulum. We know that the attractors of this system are all individual fixed points on the (x, y) plane so we will only compute the basins there. We can also use this opportunity to highlight a different method, the AttractorsViaProximity which works when we already know where the attractors are. Furthermore we will also use a ProjectedDynamicalSystem to project the 4D system onto a 2D plane, saving a lot of computational time!","category":"page"},{"location":"examples/#Computing-the-basins","page":"Examples for Attractors.jl","title":"Computing the basins","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"First we need to load in the magnetic pendulum from the predefined dynamical systems library","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using Attractors, CairoMakie\nusing PredefinedDynamicalSystems\nds = PredefinedDynamicalSystems.magnetic_pendulum(d=0.2, α=0.2, ω=0.8, N=3)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Then, we create a projected system on the x-y plane","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"psys = ProjectedDynamicalSystem(ds, [1, 2], [0.0, 0.0])","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"For this systems we know the attractors are close to the magnet positions. The positions can be obtained from the equations of the system, provided that one has seen the source code (not displayed here), like so:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"attractors = Dict(i => StateSpaceSet([dynamic_rule(ds).magnets[i]]) for i in 1:3)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"and then create a","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"mapper = AttractorsViaProximity(psys, attractors)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"and as before, get the basins of attraction","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"xg = yg = range(-4, 4; length = 201)\ngrid = (xg, yg)\nbasins, = basins_of_attraction(mapper, grid; show_progress = false)\n\nheatmap_basins_attractors(grid, basins, attractors)","category":"page"},{"location":"examples/#Computing-the-uncertainty-exponent","page":"Examples for Attractors.jl","title":"Computing the uncertainty exponent","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Let's now calculate the uncertainty_exponent for this system as well. The calculation is straightforward:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using CairoMakie\nε, f_ε, α = uncertainty_exponent(basins)\nfig, ax = lines(log.(ε), log.(f_ε))\nax.title = \"α = $(round(α; digits=3))\"\nfig","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"The actual uncertainty exponent is the slope of the curve (α) and indeed we get an exponent near 0 as we know a-priory the basins have fractal boundaries for the magnetic pendulum.","category":"page"},{"location":"examples/#Computing-the-tipping-probabilities","page":"Examples for Attractors.jl","title":"Computing the tipping probabilities","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"We will compute the tipping probabilities using the magnetic pendulum's example as the \"before\" state. For the \"after\" state we will change the γ parameter of the third magnet to be so small, its basin of attraction will virtually disappear. As we don't know when the basin of the third magnet will disappear, we switch the attractor finding algorithm back to AttractorsViaRecurrences.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"set_parameter!(psys, :γs, [1.0, 1.0, 0.1])\nmapper = AttractorsViaRecurrences(psys, (xg, yg); Δt = 1)\nbasins_after, attractors_after = basins_of_attraction(\n    mapper, (xg, yg); show_progress = false\n)\n# matching attractors is important!\nrmap = match_statespacesets!(attractors_after, attractors)\n# Don't forget to update the labels of the basins as well!\nreplace!(basins_after, rmap...)\n\n# now plot\nheatmap_basins_attractors(grid, basins_after, attractors_after)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"And let's compute the tipping \"probabilities\":","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"P = tipping_probabilities(basins, basins_after)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"As you can see P has size 3×2, as after the change only 2 attractors have been identified in the system (3 still exist but our state space discretization isn't fine enough to find the 3rd because it has such a small basin). Also, the first row of P is 50% probability to each other magnet, as it should be due to the system's symmetry.","category":"page"},{"location":"examples/#3D-basins-via-recurrences","page":"Examples for Attractors.jl","title":"3D basins via recurrences","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"To showcase the true power of AttractorsViaRecurrences we need to use a system whose attractors span higher-dimensional space. An example is","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using Attractors\nusing PredefinedDynamicalSystems\nds = PredefinedDynamicalSystems.thomas_cyclical(b = 0.1665)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"which, for this parameter, contains 3 coexisting attractors which are entangled periodic orbits that span across all three dimensions.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"To compute the basins we define a three-dimensional grid and call on it basins_of_attraction.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"# This computation takes about an hour\nxg = yg = zg = range(-6.0, 6.0; length = 251)\nmapper = AttractorsViaRecurrences(ds, (xg, yg, zg); sparse = false)\nbasins, attractors = basins_of_attraction(mapper)\nattractors","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Dict{Int16, StateSpaceSet{3, Float64}} with 5 entries:\n  5 => 3-dimensional StateSpaceSet{Float64} with 1 points\n  4 => 3-dimensional StateSpaceSet{Float64} with 379 points\n  6 => 3-dimensional StateSpaceSet{Float64} with 1 points\n  2 => 3-dimensional StateSpaceSet{Float64} with 538 points\n  3 => 3-dimensional StateSpaceSet{Float64} with 537 points\n  1 => 3-dimensional StateSpaceSet{Float64} with 1 points","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Note: the reason we have 6 attractors here is because the algorithm also finds 3 unstable fixed points and labels them as attractors. This happens because we have provided initial conditions on the grid xg, yg, zg that start exactly on the unstable fixed points, and hence stay there forever, and hence are perceived as attractors by the recurrence algorithm. As you will see in the video below, they don't have any basin fractions","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"The basins of attraction are very complicated. We can try to visualize them by animating the 2D slices at each z value, to obtain:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"<video width=\"75%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/attractors/cyclical_basins.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Then, we visualize the attractors to obtain:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"<video width=\"75%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/attractors/cyclical_attractors.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"In the animation above, the scattered points are the attractor values the function AttractorsViaRecurrences found by itself. Of course, for the periodic orbits these points are incomplete. Once the function's logic understood we are on an attractor, it stops computing. However, we also simulated lines, by evolving initial conditions colored appropriately with the basins output.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"The animation was produced with the code:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using GLMakie\nfig = Figure()\ndisplay(fig)\nax = fig[1,1] = Axis3(fig; title = \"found attractors\")\ncmap = cgrad(:dense, 6; categorical = true)\n\nfor i in keys(attractors)\n    tr = attractors[i]\n    markersize = length(attractors[i]) > 10 ? 2000 : 6000\n    marker = length(attractors[i]) > 10 ? :circle : :rect\n    scatter!(ax, columns(tr)...; markersize, marker, transparency = true, color = cmap[i])\n    j = findfirst(isequal(i), bsn)\n    x = xg[j[1]]\n    y = yg[j[2]]\n    z = zg[j[3]]\n    tr = trajectory(ds, 100, SVector(x,y,z); Ttr = 100)\n    lines!(ax, columns(tr)...; linewidth = 1.0, color = cmap[i])\nend\n\na = range(0, 2π; length = 200) .+ π/4\n\nrecord(fig, \"cyclical_attractors.mp4\", 1:length(a)) do i\n    ax.azimuth = a[i]\nend","category":"page"},{"location":"examples/#Basins-of-attraction-of-a-Poincaré-map","page":"Examples for Attractors.jl","title":"Basins of attraction of a Poincaré map","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"PoincareMap is just another discrete time dynamical system within the DynamicalSystems.jl ecosystem. With respect to Attractors.jl functionality, there is nothing special about Poincaré maps. You simply initialize one use it like any other type of system. Let's continue from the above example  of the Thomas cyclical system","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using Attractors\nusing PredefinedDynamicalSystems\nds = PredefinedDynamicalSystems.thomas_cyclical(b = 0.1665);","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"The three limit cycles attractors we have above become fixed points in the Poincaré map (for appropriately chosen hyperplanes). Since we already know the 3D structure of the basins, we can see that an appropriately chosen hyperplane is just the plane z = 0. Hence, we define a Poincaré map on this plane:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"plane = (3, 0.0)\npmap = PoincareMap(ds, plane)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"We define the same grid as before, but now only we only use the x-y coordinates. This is because we can utilize the special reinit! method of the PoincareMap, that allows us to initialize a new state directly on the hyperplane (and then the remaining variable of the dynamical system takes its value from the hyperplane itself).","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"xg = yg = range(-6.0, 6.0; length = 250)\ngrid = (xg, yg)\nmapper = AttractorsViaRecurrences(pmap, grid; sparse = false)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"All that is left to do is to call basins_of_attraction:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"basins, attractors = basins_of_attraction(mapper; show_progress = false);","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"heatmap_basins_attractors(grid, basins, attractors)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"just like in the example above, there is a fourth attractor with 0 basin fraction. This is an unstable fixed point, and exists exactly because we provided a grid with the unstable fixed point exactly on this grid","category":"page"},{"location":"examples/#Irregular-grid-for-AttractorsViaRecurrences","page":"Examples for Attractors.jl","title":"Irregular grid for AttractorsViaRecurrences","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"It is possible to provide an irregularly spaced grid to AttractorsViaRecurrences. This can make algorithm performance better for continuous time systems where the state space flow has significantly different speed in some state space regions versus others.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"In the following example the dynamical system has only one attractor: a limit cycle. However, near the origin (0, 0) the timescale of the dynamics becomes very slow. As the trajectory is stuck there for quite a while, the recurrences algorithm may identify this region as an \"attractor\" (incorrectly). The solutions vary and can be to increase drastically the max time checks for finding attractors, or making the grid much more fine. Alternatively, one can provide a grid that is only more fine near the origin and not fine elsewhere.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"The example below highlights that for rather coarse settings of grid and convergence thresholds, using a grid that is finer near (0, 0) gives correct results:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using Attractors, CairoMakie\n\nfunction predator_prey_fastslow(u, p, t)\n    α, γ, ϵ, ν, h, K, m = p\n    N, P = u\n    du1 = α*N*(1 - N/K) - γ*N*P / (N+h)\n    du2 = ϵ*(ν*γ*N*P/(N+h) - m*P)\n    return SVector(du1, du2)\nend\nγ = 2.5\nh = 1\nν = 0.5\nm = 0.4\nϵ = 1.0\nα = 0.8\nK = 15\nu0 = rand(2)\np0 = [α, γ, ϵ, ν, h, K, m]\nds = CoupledODEs(predator_prey_fastslow, u0, p0)\n\nfig = Figure()\nax = Axis(fig[1,1])\n\n# when pow > 1, the grid is finer close to zero\nfor pow in (1, 2)\n    xg = yg = range(0, 18.0^(1/pow); length = 200).^pow\n    mapper = AttractorsViaRecurrences(ds, (xg, yg);\n        Dt = 0.1, sparse = true,\n        consecutive_recurrences = 10, attractor_locate_steps = 10,\n        maximum_iterations = 1000,\n    )\n\n    # Find attractor and its fraction (fraction is always 1 here)\n    sampler, _ = statespace_sampler(HRectangle(zeros(2), fill(18.0, 2)), 42)\n    fractions = basins_fractions(mapper, sampler; N = 100, show_progress = false)\n    attractors = extract_attractors(mapper)\n    scatter!(ax, vec(attractors[1]); markersize = 16/pow, label = \"pow = $(pow)\")\nend\n\naxislegend(ax)\n\nfig","category":"page"},{"location":"examples/#Subdivision-Based-Grid-for-AttractorsViaRecurrences","page":"Examples for Attractors.jl","title":"Subdivision Based Grid for AttractorsViaRecurrences","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"To achieve even better results for this kind of problematic systems than with previuosly introduced Irregular Grids  we provide a functionality to construct Subdivision Based Grids in which one can obtain more coarse or dense structure not only along some axis but for a specific regions where the state space flow has significantly different speed. subdivision_based_grid enables automatic evaluation of velocity vectors for regions of originally user specified grid to further treat those areas as having more dense or coarse structure than others.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using Attractors, CairoMakie\n\nfunction predator_prey_fastslow(u, p, t)\n    α, γ, ϵ, ν, h, K, m = p\n    N, P = u\n    du1 = α*N*(1 - N/K) - γ*N*P / (N+h)\n    du2 = ϵ*(ν*γ*N*P/(N+h) - m*P)\nreturn SVector(du1, du2)\nend\nγ = 2.5\nh = 1\nν = 0.5\nm = 0.4\nϵ = 1.0\nα = 0.8\nK = 15\nu0 = rand(2)\np0 = [α, γ, ϵ, ν, h, K, m]\nds = CoupledODEs(predator_prey_fastslow, u0, p0)\n\nxg = yg = range(0, 18, length = 30)\n# Construct `Subdivision Based Grid`\ngrid = subdivision_based_grid(ds, (xg, yg))\ngrid.lvl_array","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"The constructed array corresponds to levels of discretization for specific regions of the grid as a powers of 2, meaning that if area index is assigned to be 3, for example, the algorithm will treat the region as one being 2^3 = 8 times more dense than originally user provided grid (xg, yg).","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Now upon the construction of this structure, one can simply pass it into mapper function as usual.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"fig = Figure()\nax = Axis(fig[1,1])\n# passing SubdivisionBasedGrid into mapper\nmapper = AttractorsViaRecurrences(ds, grid;\n        Dt = 0.1, sparse = true,\n        consecutive_recurrences = 10, attractor_locate_steps = 10,\n        maximum_iterations = 1000,\n    )\n\n# Find attractor and its fraction (fraction is always 1 here)\nsampler, _ = statespace_sampler(HRectangle(zeros(2), fill(18.0, 2)), 42)\nfractions = basins_fractions(mapper, sampler; N = 100, show_progress = false)\nattractors_SBD = extract_attractors(mapper)\nscatter!(ax, vec(attractors_SBD[1]); label = \"SubdivisionBasedGrid\")\n\n\n# to compare the results we also construct RegularGrid of same length here\nxg = yg = range(0, 18, length = 30)\nmapper = AttractorsViaRecurrences(ds, (xg, yg);\n        Dt = 0.1, sparse = true,\n        consecutive_recurrences = 10, attractor_locate_steps = 10,\n        maximum_iterations = 1000,\n    )\n\nsampler, _ = statespace_sampler(HRectangle(zeros(2), fill(18.0, 2)), 42)\nfractions = basins_fractions(mapper, sampler; N = 100, show_progress = false)\nattractors_reg = extract_attractors(mapper)\nscatter!(ax, vec(attractors_reg[1]); label = \"RegularGrid\")\n\naxislegend(ax)\nfig\n","category":"page"},{"location":"examples/#Basin-fractions-continuation-in-the-magnetic-pendulum","page":"Examples for Attractors.jl","title":"Basin fractions continuation in the magnetic pendulum","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Perhaps the simplest application of continuation is to produce a plot of how the fractions of attractors change as we continuously change the parameter we changed above to calculate tipping probabilities.","category":"page"},{"location":"examples/#Computing-the-fractions","page":"Examples for Attractors.jl","title":"Computing the fractions","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"This is what the following code does:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"# initialize projected magnetic pendulum\nusing Attractors, PredefinedDynamicalSystems\nusing Random: Xoshiro\nds = Systems.magnetic_pendulum(; d = 0.3, α = 0.2, ω = 0.5)\nxg = yg = range(-3, 3; length = 101)\nds = ProjectedDynamicalSystem(ds, 1:2, [0.0, 0.0])\n# Choose a mapper via recurrences\nmapper = AttractorsViaRecurrences(ds, (xg, yg); Δt = 1.0)\n# What parameter to change, over what range\nγγ = range(1, 0; length = 101)\nprange = [[1, 1, γ] for γ in γγ]\npidx = :γs\n# important to make a sampler that respects the symmetry of the system\nregion = HSphere(3.0, 2)\nsampler, = statespace_sampler(region, 1234)\n# continue attractors and basins:\n# `Inf` threshold fits here, as attractors move smoothly in parameter space\nrsc = RecurrencesFindAndMatch(mapper; threshold = Inf)\nfractions_curves, attractors_info = continuation(\n    rsc, prange, pidx, sampler;\n    show_progress = false, samples_per_parameter = 100\n)\n# Show some characteristic fractions:\nfractions_curves[[1, 50, 101]]","category":"page"},{"location":"examples/#Plotting-the-fractions","page":"Examples for Attractors.jl","title":"Plotting the fractions","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"We visualize them using a predefined function that you can find in docs/basins_plotting.jl","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"# careful; `prange` isn't a vector of reals!\nplot_basins_curves(fractions_curves, γγ)","category":"page"},{"location":"examples/#Fixed-point-curves","page":"Examples for Attractors.jl","title":"Fixed point curves","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"A by-product of the analysis is that we can obtain the curves of the position of fixed points for free. However, only the stable branches can be obtained!","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using CairoMakie\nfig = Figure()\nax = Axis(fig[1,1]; xlabel = L\"\\gamma_3\", ylabel = \"fixed point\")\n# choose how to go from attractor to real number representation\nfunction real_number_repr(attractor)\n    p = attractor[1]\n    return (p[1] + p[2])/2\nend\n\nfor (i, γ) in enumerate(γγ)\n    for (k, attractor) in attractors_info[i]\n        scatter!(ax, γ, real_number_repr(attractor); color = Cycled(k))\n    end\nend\nfig","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"as you can see, two of the three fixed points, and their stability, do not depend at all on the parameter value, since this parameter value tunes the magnetic strength of only the third magnet. Nevertheless, the fractions of basin of attraction of all attractors depend strongly on the parameter. This is a simple example that highlights excellently how this new approach we propose here should be used even if one has already done a standard linearized bifurcation analysis.","category":"page"},{"location":"examples/#Extinction-of-a-species-in-a-multistable-competition-model","page":"Examples for Attractors.jl","title":"Extinction of a species in a multistable competition model","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"In this advanced example we utilize both RecurrencesFindAndMatch and aggregate_attractor_fractions in analyzing species extinction in a dynamical model of competition between multiple species. The final goal is to show the percentage of how much of the state space leads to the extinction or not of a pre-determined species, as we vary a parameter. The model however displays extreme multistability, a feature we want to measure and preserve before aggregating information into \"extinct or not\".","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"To measure and preserve this we will apply RecurrencesFindAndMatch as-is first. Then we can aggregate information. First we have","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using Attractors, OrdinaryDiffEq\nusing PredefinedDynamicalSystems\nusing Random: Xoshiro\n# arguments to algorithms\nsamples_per_parameter = 1000\ntotal_parameter_values = 101\ndiffeq = (alg = Vern9(), reltol = 1e-9, abstol = 1e-9, maxiters = Inf)\nrecurrences_kwargs = (; Δt= 1.0, consecutive_recurrences=9, diffeq);\n# initialize dynamical system and sampler\nds = PredefinedDynamicalSystems.multispecies_competition() # 8-dimensional\nds = CoupledODEs(ODEProblem(ds), diffeq)\n# define grid in state space\nxg = range(0, 60; length = 300)\ngrid = ntuple(x -> xg, 8)\nprange = range(0.2, 0.3; length = total_parameter_values)\npidx = :D\nsampler, = statespace_sampler(grid, 1234)\n# initialize mapper\nmapper = AttractorsViaRecurrences(ds, grid; recurrences_kwargs...)\n# perform continuation of attractors and their basins\ncontinuation = RecurrencesFindAndMatch(mapper; threshold = Inf)\nfractions_curves, attractors_info = continuation(\n    continuation, prange, pidx, sampler;\n    show_progress = true, samples_per_parameter\n);\nplot_basins_curves(fractions_curves, prange; separatorwidth = 1)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"this example is not actually run when building the docs, because it takes about 60 minutes to complete depending on the computer; we load precomputed results instead","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"As you can see, the system has extreme multistability with 64 unique attractors (according to the default matching behavior in RecurrencesFindAndMatch; a stricter matching with less than Inf threshold would generate more \"distinct\" attractors). One could also isolate a specific parameter slice, and do the same as what we do in the Fractality of 2D basins of the (4D) magnetic pendulum example, to prove that the basin boundaries are fractal, thereby indeed confirming the paper title \"Fundamental Unpredictability\".","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Regardless, we now want to continue our analysis to provide a figure similar to the above but only with two colors: fractions of attractors where a species is extinct or not. Here's how:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"species = 3 # species we care about its existence\n\nfeaturizer = (A) -> begin\n    i = isextinct(A, species)\n    return SVector(Int32(i))\nend\nisextinct(A, idx = unitidxs) = all(a -> a <= 1e-2, A[:, idx])\n\n# `minneighbors = 1` is crucial for grouping single attractors\ngroupingconfig = GroupViaClustering(; min_neighbors=1, optimal_radius_method=0.5)\n\naggregated_fractions, aggregated_info = aggregate_attractor_fractions(\n    fractions_curves, attractors_info, featurizer, groupingconfig\n)\n\nplot_basins_curves(aggregated_fractions, prange;\n    separatorwidth = 1, colors = [\"green\", \"black\"],\n    labels = Dict(1 => \"extinct\", 2 => \"alive\"),\n)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"(in hindsight, the labels are reversed; attractor 1 is the alive one, but oh well)","category":"page"},{"location":"examples/#Trivial-featurizing-and-grouping-for-basins-fractions","page":"Examples for Attractors.jl","title":"Trivial featurizing and grouping for basins fractions","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"This is a rather trivial example showcasing the usage of AttractorsViaFeaturizing. Let us use once again the magnetic pendulum example. For it, we have a really good idea of what features will uniquely describe each attractor: the last points of a trajectory (which should be very close to the magnetic the trajectory converged to). To provide this information to the AttractorsViaFeaturizing we just create a julia function that returns this last point","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using Attractors\nusing PredefinedDynamicalSystems\n\nds = Systems.magnetic_pendulum(d=0.2, α=0.2, ω=0.8, N=3)\npsys = ProjectedDynamicalSystem(ds, [1, 2], [0.0, 0.0])\n\nfunction featurizer(X, t)\n    return X[end]\nend\n\nmapper = AttractorsViaFeaturizing(psys, featurizer; Ttr = 200, T = 1)\n\nxg = yg = range(-4, 4; length = 101)\n\nregion = HRectangle([-4, 4], [4, 4])\nsampler, = statespace_sampler(region)\n\nfs = basins_fractions(mapper, sampler; show_progress = false)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"As expected, the fractions are each about 1/3 due to the system symmetry.","category":"page"},{"location":"examples/#Featurizing-and-grouping-across-parameters-(MCBB)","page":"Examples for Attractors.jl","title":"Featurizing and grouping across parameters (MCBB)","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Here we showcase the example of the Monte Carlo Basin Bifurcation publication. For this, we will use FeaturizeGroupAcrossParameter while also providing a par_weight = 1 keyword. However, we will not use a network of 2nd order Kuramoto oscillators (as done in the paper by Gelbrecht et al.) because it is too costly to run on CI. Instead, we will use \"dummy\" system which we know analytically the attractors and how they behave versus a parameter.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"the Henon map and try to group attractors into period 1 (fixed point), period 3, and divergence to infinity. We will also use a pre-determined optimal radius for clustering, as we know a-priory the expected distances of features in feature space (due to the contrived form of the featurizer function below).","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using Attractors, Random\n\nfunction dumb_map(dz, z, p, n)\n    x, y = z\n    r = p[1]\n    if r < 0.5\n        dz[1] = dz[2] = 0.0\n    else\n        if x > 0\n            dz[1] = r\n            dz[2] = r\n        else\n            dz[1] = -r\n            dz[2] = -r\n        end\n    end\n    return\nend\n\nr = 3.833\nds = DiscreteDynamicalSystem(dumb_map, [0., 0.], [r])","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"sampler, = statespace_sampler(HRectangle([-3.0, -3.0], [3.0, 3.0]), 1234)\n\nrrange = range(0, 2; length = 21)\nridx = 1\n\nfeaturizer(a, t) = a[end]\nclusterspecs = GroupViaClustering(optimal_radius_method = \"silhouettes\", max_used_features = 200)\nmapper = AttractorsViaFeaturizing(ds, featurizer, clusterspecs; T = 20, threaded = true)\ngap = FeaturizeGroupAcrossParameter(mapper; par_weight = 1.0)\nfractions_curves, clusters_info = continuation(\n    gap, rrange, ridx, sampler; show_progress = false\n)\nfractions_curves","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Looking at the information of the \"attractors\" (here the clusters of the grouping procedure) does not make it clear which label corresponds to which kind of attractor, but we can look at the:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"clusters_info","category":"page"},{"location":"examples/#Using-histograms-and-histogram-distances-as-features","page":"Examples for Attractors.jl","title":"Using histograms and histogram distances as features","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"One of the aspects discussed in the original MCBB paper and implementation was the usage of histograms of the means of the variables of a dynamical system as the feature vector. This is useful in very high dimensional systems, such as oscillator networks, where the histogram of the means is significantly different in synchronized or unsychronized states.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"This is possible to do with current interface without any modifications, by using two more packages: ComplexityMeasures.jl to compute histograms, and Distances.jl for the Kullback-Leibler divergence (or any other measure of distance in the space of probability distributions you fancy).","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"The only code we need to write to achieve this feature is a custom featurizer and providing an alternative distance to GroupViaClustering. The code would look like this:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using Distances: KLDivergence\nusing ComplexityMeasures: ValueHistogram, FixedRectangularBinning, probabilities\n\n# you decide the binning for the histogram, but for a valid estimation of\n# distances, all histograms must have exactly the same bins, and hence be\n# computed with fixed ranges, i.e., using the `FixedRectangularBinning`\nconst binning = FixedRectangularBinning(range(-5, 5; length = 11))\n\nfunction histogram_featurizer(A, t)\n    ms = mean.(columns(A)) # vector of mean of each variable\n    p = probabilities(ValueHistogram(binning), ms) # this is the histogram\n    return vec(p) # because Distances.jl doesn't know `Probabilities`\nend\n\ngconfig = GroupViaClustering(;\n    clust_distance_metric = KLDivergence(), # or any other PDF distance\n)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"You can then pass the histogram_featurizer and gconfig to an AttractorsViaFeaturizing and use the rest of the library as usual.","category":"page"},{"location":"examples/#Animation-illustrating-AttractorsViaRecurrences","page":"Examples for Attractors.jl","title":"Animation illustrating AttractorsViaRecurrences","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"The following Julia script inputs a 2D continuous time dynamical system and animates its time evolution while illustrating how AttractorsViaRecurrences works.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using Attractors, CairoMakie\nusing PredefinedDynamicalSystems\nusing OrdinaryDiffEq\n\n# Set up dynamical system: bi-stable predator pray\nfunction predator_prey_rule(u, p, t)\n    r, c, μ, ν, α, β, χ, δ = p\n    N, P = u\n    common = α*N*P/(β+N)\n    dN = r*N*(1 - (c/r)*N)*((N-μ)/(N+ν)) - common\n    dP = χ*common - δ*P\n    return SVector(dN, dP)\nend\n\nu0 = SVector(8.0, 0.01)\nr = 2.0\n# r, c, μ, ν, α, β, χ, δ = p\np = [r, 0.19, 0.03, 0.003, 800, 1.5, 0.004, 2.2]\n\ndiffeq = (alg = Rodas5P(), abstol = 1e-9, rtol = 1e-9)\nds = CoupledODEs(predator_prey_rule, u0, p; diffeq)\n\nu0s = [ # animation will start from these initial conditions\n    [10, 0.012],\n    [15, 0.02],\n    [12, 0.01],\n    [13, 0.015],\n    [5, 0.02],\n]\n\ndensity = 31\nxg = range(-0.1, 20; length = density)\nyg = range(-0.001, 0.03; length = density)\nΔt = 0.1\ngrid = (xg, yg)\nmapper = AttractorsViaRecurrences(ds, grid;\n    Δt, consecutive_attractor_steps = 10, consecutive_basin_steps = 10, sparse = false,\n    consecutive_recurrences = 100, attractor_locate_steps = 100,\n)\n\n##########################################################################\n\nfunction animate_attractors_via_recurrences(\n        mapper::AttractorsViaRecurrences, u0s;\n        colors = [\"#FFFFFF\", \"#7143E0\",\"#0A9A84\",\"#AF9327\",\"#791457\", \"#6C768C\", \"#4287f5\",],\n        filename = \"recurrence_algorithm.mp4\",\n    )\n\n    grid_nfo = mapper.bsn_nfo.grid_nfo\n\n    fig = Figure()\n    ax = Axis(fig[1,1])\n\n    # Populate the grid with poly! rectangle plots. However! The rectangles\n    # correspond to the same \"cells\" of the grid. Additionally, all\n    # rectangles are colored with an _observable_, that can be accessed\n    # later using the `basin_cell_index` function. The observable\n    # holds the face color of the rectangle!\n\n    # Only 6 colors; need 3 for base, and extra 2 for each attractor.\n    # will choose initial conditions that are only in the first 2 attractors\n    COLORS = map(c -> Makie.RGBA(Makie.RGB(to_color(c)), 0.9), colors)\n\n    function initialize_cells2!(ax, grid; kwargs...)\n        # These are all possible outputs of the `basin_cell_index` function\n        idxs = all_cartesian_idxs(grid)\n        color_obs = Matrix{Any}(undef, size(idxs)...)\n        # We now need to reverse-engineer\n        for i in idxs\n            rect = cell_index_to_rect(i, grid)\n            color = Observable(COLORS[1])\n            color_obs[i] = color\n            poly!(ax, rect; color = color, strokecolor = :black, strokewidth = 0.5)\n        end\n        # Set the axis limits better\n        mini, maxi = Attractors.minmax_grid_extent(grid)\n        xlims!(ax, mini[1], maxi[1])\n        ylims!(ax, mini[2], maxi[2])\n        return color_obs\n    end\n\n    all_cartesian_idxs(grid::Attractors.RegularGrid) = CartesianIndices(length.(grid.grid))\n\n    # Given a cartesian index, the output of `basin_cell_index`, create\n    # a `Rect` object that corresponds to that grid cell!\n    function cell_index_to_rect(n::CartesianIndex, grid::Attractors.RegularGrid)\n        x = grid.grid[1][n[1]]\n        y = grid.grid[2][n[2]]\n        dx = grid.grid_steps[1]\n        dy = grid.grid_steps[2]\n        rect = Rect(x - dx/2, y - dy/2, dx, dy)\n        return rect\n    end\n\n    color_obs = initialize_cells2!(ax, grid_nfo)\n\n    # plot the trajectory\n    state2marker = Dict(\n        :att_search => :circle,\n        :att_found => :dtriangle,\n        :att_hit => :rect,\n        :lost => :star5,\n        :bas_hit => :xcross,\n    )\n\n    # This function gives correct color to search, recurrence, and\n    # the individual attractors. Ignores the lost state.\n    function update_current_cell_color!(cellcolor, bsn_nfo)\n        # We only alter the cell color at specific situations\n        state = bsn_nfo.state\n        if state == :att_search\n            if cellcolor[] == COLORS[1] # empty\n                cellcolor[] = COLORS[2] # visited\n            elseif cellcolor[] == COLORS[2] # visited\n                cellcolor[] = COLORS[3] # recurrence\n            end\n        elseif state == :att_found\n            attidx = (bsn_nfo.current_att_label ÷ 2)\n            attlabel = (attidx - 1)*2 + 1\n            cellcolor[] = COLORS[3+attlabel]\n        end\n        return\n    end\n\n    # Iteration and labelling\n    ds = mapper.ds\n    bsn_nfo = mapper.bsn_nfo\n    u0 = current_state(ds)\n\n    traj = Observable(SVector{2, Float64}[u0])\n    point = Observable([u0])\n\n    marker = Observable(:circle)\n    lines!(ax, traj; color = :black, linewidth = 1)\n    scatter!(ax, point; color = (:black, 0.5), markersize = 20, marker, strokewidth = 1.0, strokecolor = :black)\n\n    stateobs = Observable(:att_search)\n    consecutiveobs = Observable(0)\n    labeltext = @lift(\"state: $($(stateobs))\\nconsecutive: $($(consecutiveobs))\")\n\n    Label(fig[0, 1][1,1], labeltext; justification = :left, halign = :left, tellwidth = false)\n    # add text  with options\n    kwargstext = prod(\"$(p[1])=$(p[2])\\n\" for p in mapper.kwargs)\n    Label(fig[0, 1][1, 2], kwargstext; justification = :right, halign = :right, tellwidth = false)\n\n\n    # make legend\n    entries = [PolyElement(color = c) for c in COLORS[2:end]]\n    labels = [\"visited\", \"recurrence\", \"attr. 1\", \"basin 1\", \"attr. 2\", \"basin 2\"]\n\n    Legend(fig[:, 2][1, 1], entries, labels)\n\n\n    # %% loop\n    # The following code is similar to the source code of `recurrences_map_to_label!`\n\n    cell_label = 0\n    record(fig, filename) do io\n        for u0 in u0s\n            reinit!(ds, copy(u0))\n            traj[] = [copy(u0)]\n\n            while cell_label == 0\n                step!(ds, bsn_nfo.Δt)\n                u = current_state(ds)\n\n                # update FSM\n                n = Attractors.basin_cell_index(u, bsn_nfo.grid_nfo)\n                cell_label = Attractors.finite_state_machine!(bsn_nfo, n, u; mapper.kwargs...)\n\n                state = bsn_nfo.state\n\n                if cell_label ≠ 0 # FSM terminated; we assume no lost/divergence in the system\n                    stateobs[] = :terminated\n\n                    # color-code initial condition if we converged to attractor\n                    # or to basin (even or odd cell label)\n                    u0n = Attractors.basin_cell_index(u0, bsn_nfo.grid_nfo)\n\n                    basidx = (cell_label - 1)\n                    color_obs[u0n][] = COLORS[3+basidx]\n\n                    # Clean up: all \"visited\" cells become white again\n                    visited_idxs = findall(v -> (v[] == COLORS[2] || v[] == COLORS[3]), color_obs)\n                    for n in visited_idxs\n                        color_obs[n][] = COLORS[1] # empty\n                    end\n                    # clean up trajectory line\n                    traj[] = []\n\n                    for i in 1:15; recordframe!(io); end\n                    cell_label = 0\n                    break\n                end\n\n                # update visuals:\n                point[] = [u]\n                push!(traj[], u)\n                notify(traj)\n                marker[] = state2marker[state]\n                stateobs[] = state\n                consecutiveobs[] = bsn_nfo.consecutive_match\n\n                update_current_cell_color!(color_obs[n], bsn_nfo)\n\n                recordframe!(io)\n            end\n        end\n    end\nend\n\nanimate_attractors_via_recurrences(mapper, u0s)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"<video width=\"75%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/attractors/recurrence_algorithm.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/#Edge-tracking","page":"Examples for Attractors.jl","title":"Edge tracking","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"To showcase how to run the edgetracking algorithm, let us use it to find the saddle point of the bistable FitzHugh-Nagumo (FHN) model, a two-dimensional ODE system originally conceived to represent a spiking neuron. We define the system in the following form:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using OrdinaryDiffEq: Vern9\n\nfunction fitzhugh_nagumo(u,p,t)\n    x, y = u\n    eps, beta = p\n    dx = (x - x^3 - y)/eps\n    dy = -beta*y + x\n    return SVector{2}([dx, dy])\nend\n\nparams = [0.1, 3.0]\nds = CoupledODEs(fitzhugh_nagumo, ones(2), params, diffeq=(;alg = Vern9(), reltol=1e-11))","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Now, we can use Attractors.jl to compute the fixed points and basins of attraction of the FHN model.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"xg = yg = range(-1.5, 1.5; length = 201)\ngrid = (xg, yg)\nmapper = AttractorsViaRecurrences(ds, grid; sparse=false)\nbasins, attractors = basins_of_attraction(mapper)\nattractors","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"The basins_of_attraction function found three fixed points: the two stable nodes of the system (labelled A and B) and the saddle point at the origin. The saddle is an unstable equilibrium and typically will not be found by basins_of_attraction. Coincidentally here we initialized an initial condition exactly on the saddle, and hence it was found. We can always find saddles with the edgetracking function. For illustration, let us initialize the algorithm from two initial conditions init1 and init2 (which must belong to different basins of attraction, see figure below).","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"attractors_AB = Dict(1 => attractors[1], 2 => attractors[2])\ninit1, init2 = [-1.0, -1.0], [-1.0, 0.2]","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Now, we run the edge tracking algorithm:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"et = edgetracking(ds, attractors_AB; u1=init1, u2=init2,\n    bisect_thresh = 1e-3, diverge_thresh = 2e-3, Δt = 1e-5, abstol = 1e-3\n)\n\net.edge[end]","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"The algorithm has converged to the origin (up to the specified accuracy) where the saddle is located. The figure below shows how the algorithm has iteratively tracked along the basin boundary from the two initial conditions (red points) to the saddle (green square). Points of the edge track (orange) at which a re-bisection occured are marked with a white border. The figure also depicts two trajectories (blue) intialized on either side of the basin boundary at the first bisection point. We see that these trajectories follow the basin boundary for a while but then relax to either attractor before reaching the saddle. By counteracting the instability of the saddle, the edge tracking algorithm instead allows to track the basin boundary all the way to the saddle, or edge state.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"traj1 = trajectory(ds, 2, et.track1[et.bisect_idx[1]], Δt=1e-5)\ntraj2 = trajectory(ds, 2, et.track2[et.bisect_idx[1]], Δt=1e-5)\n\nfig = Figure()\nax = Axis(fig[1,1], xlabel=\"x\", ylabel=\"y\")\nheatmap_basins_attractors!(ax, grid, basins, attractors, add_legend=false, labels=Dict(1=>\"Attractor A\", 2=>\"Attractor B\", 3=>\"Saddle\"))\nlines!(ax, traj1[1][:,1], traj1[1][:,2], color=:dodgerblue, linewidth=2, label=\"Trajectories\")\nlines!(ax, traj2[1][:,1], traj2[1][:,2], color=:dodgerblue, linewidth=2)\nlines!(ax, et.edge[:,1], et.edge[:,2], color=:orange, linestyle=:dash)\nscatter!(ax, et.edge[et.bisect_idx,1], et.edge[et.bisect_idx,2], color=:white, markersize=15, marker=:circle, zorder=10)\nscatter!(ax, et.edge[:,1], et.edge[:,2], color=:orange, markersize=11, marker=:circle, zorder=10, label=\"Edge track\")\nscatter!(ax, [-1.0,-1.0], [-1.0, 0.2], color=:red, markersize=15, label=\"Initial conditions\")\nxlims!(ax, -1.2, 1.1); ylims!(ax, -1.3, 0.8)\naxislegend(ax, position=:rb)\nfig","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"In this simple two-dimensional model, we could of course have found the saddle directly by computing the zeroes of the ODE system. However, the edge tracking algorithm allows finding edge states also in high-dimensional and chaotic systems where a simple computation of unstable equilibria becomes infeasible.","category":"page"},{"location":"attractors/#Finding-Attractors","page":"Finding Attractors","title":"Finding Attractors","text":"","category":"section"},{"location":"attractors/","page":"Finding Attractors","title":"Finding Attractors","text":"Attractors.jl defines a generic interface for finding attractors of dynamical systems. One first decides the instance of DynamicalSystem they need. Then, an instance of AttractorMapper is created from this dynamical system. This mapper instance can be used to compute e.g., basins_of_attraction, and the output can be further analyzed to get e.g., the basin_entropy.","category":"page"},{"location":"attractors/","page":"Finding Attractors","title":"Finding Attractors","text":"AttractorMapper","category":"page"},{"location":"attractors/#Attractors.AttractorMapper","page":"Finding Attractors","title":"Attractors.AttractorMapper","text":"AttractorMapper(ds::DynamicalSystem, args...; kwargs...) → mapper\n\nSubtypes of AttractorMapper are structures that map initial conditions of ds to attractors. Currently available mapping methods:\n\nAttractorsViaProximity\nAttractorsViaRecurrences\nAttractorsViaFeaturizing\n\nAll AttractorMapper subtypes can be used with basins_fractions or basins_of_attraction.\n\nIn addition, some mappers can be called as a function of an initial condition:\n\nlabel = mapper(u0)\n\nand this will on the fly compute and return the label of the attractor u0 converges at. The mappers that can do this are:\n\nAttractorsViaProximity\nAttractorsViaRecurrences\nAttractorsViaFeaturizing with the GroupViaHistogram configuration.\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Recurrences","page":"Finding Attractors","title":"Recurrences","text":"","category":"section"},{"location":"attractors/","page":"Finding Attractors","title":"Finding Attractors","text":"AttractorsViaRecurrences\nautomatic_Δt_basins\nSubdivisionBasedGrid\nsubdivision_based_grid","category":"page"},{"location":"attractors/#Attractors.AttractorsViaRecurrences","page":"Finding Attractors","title":"Attractors.AttractorsViaRecurrences","text":"AttractorsViaRecurrences(ds::DynamicalSystem, grid; kwargs...)\n\nMap initial conditions of ds to attractors by identifying attractors on the fly based on recurrences in the state space, as outlined in (Datseris and Wagemakers, 2022). However, the Description section below for has a more accurate (and simpler) exposition to the algorithm than the paper.\n\ngrid is instructions for partitioning the state space into finite-sized cells so that a finite state machine can operate on top of it. Possibilities are:\n\nA tuple of sorted AbstractRanges for a regular grid.\n\nExample is grid = (xg, yg) where xg = yg = range(-5, 5; length = 100)   for a two-dimensional system.\n\nA tuple of sorted AbstractVectors for an irregular grid, for example\n\ngrid = (xg, yg) with xg = range(0, 10.0^(1/2); length = 200).^2,   yg = range(-5, 5; length = 100).\n\nAn instance of the special grid type\n\nSubdivisionBasedGrid, which can be created either manually or by using   subdivision_based_grid.   This automatically analyzes and adapts grid discretization   levels in accordance with state space flow speed in different regions.\n\nThe grid has to be the same dimensionality as the state space, use a ProjectedDynamicalSystem if you want to search for attractors in a lower dimensional subspace.\n\nKeyword arguments\n\nsparse = true: control the storage type of the state space grid. If true,  uses a sparse array, whose memory usage is in general more efficient than a regular  array obtained with sparse=false. In practice, the sparse representation should  always be preferred when searching for basins_fractions. Only for very low  dimensional systems and for computing the full basins_of_attraction the  non-sparse version should be used.\n\nTime evolution configuration\n\nTtr = 0: Skip a transient before the recurrence routine begins.\nΔt: Approximate integration time step (second argument of the step! function). The keyword Dt can also be used instead if Δ (\\Delta) is not accessible. It is 1 for discrete time systems. For continuous systems, an automatic value is calculated using automatic_Δt_basins. For very fine grids, this can become very small, much smaller than the typical integrator internal step size in case of adaptive integrators. In such cases, use force_non_adaptive = true.\nforce_non_adaptive = false: Only used if the input dynamical system is CoupledODEs. If true the additional keywords adaptive = false, dt = Δt are given as diffeq to the CoupledODEs. This means that adaptive integration is turned off and Δt is used as the ODE integrator timestep. This is useful in (1) very fine grids, and (2) if some of the attractors are limit cycles. We have noticed that in this case the integrator timestep becomes commensurate with the limit cycle period, leading to incorrectly counting the limit cycle as more than one attractor.\n\nFinite state machine configuration\n\nconsecutive_recurrences = 100: Number of consecutive visits to previously visited unlabeled cells (i.e., recurrences) required before declaring we have converged to a new attractor. This number tunes the accuracy of converging to attractors and should generally be high (and even higher for chaotic systems).\nattractor_locate_steps = 1000: Number of subsequent steps taken to locate accurately the new attractor after the convergence phase is over. Once attractor_locate_steps steps have been taken, the new attractor has been identified with sufficient accuracy and iteration stops. This number can be very high without much impact to overall performance.\nstore_once_per_cell = true: Control if multiple points in state space that belong to the same cell are stored or not in the attractor, when a new attractor is found. If true, each visited cell will only store a point once, which is desirable for fixed points and limit cycles. If false then attractor_locate_steps points are stored per attractor, leading to more densely stored attractors, which may be desirable for instance in chaotic attractors.\nconsecutive_attractor_steps = 2: Μaximum checks of consecutives hits of an existing attractor cell before declaring convergence to that existing attractor.\nconsecutive_basin_steps = 10: Number of consecutive visits of the same basin of attraction required before declaring convergence to an existing attractor. This is ignored if sparse = true, as basins are not stored internally in that case.\nconsecutive_lost_steps = 20: Maximum check of iterations outside the defined grid before we declare the orbit lost outside and hence assign it label -1.\nhorizon_limit = 1e6: If the norm of the integrator state reaches this limit we declare that the orbit diverged to infinity.\nmaximum_iterations = Int(1e6): A safety counter that is always increasing for each initial condition. Once exceeded, the algorithm assigns -1 and throws a warning. This clause exists to stop the algorithm never halting for inappropriate grids. It may happen when a newly found attractor orbit intersects in the same cell of a previously found attractor (which leads to infinite resetting of all counters).\n\nDescription\n\nAn initial condition given to an instance of AttractorsViaRecurrences is iterated based on the integrator corresponding to ds. Enough recurrences in the state space (i.e., a trajectory visited a region it has visited before) means that the trajectory has converged to an attractor. This is the basis for finding attractors.\n\nA finite state machine (FSM) follows the trajectory in the state space, and constantly maps it to a cell in the given grid. The grid cells store information: they are empty, visited, basins, or attractor cells. The state of the FSM is decided based on the cell type and the previous state of the FSM. Whenever the FSM recurs its state, its internal counter is increased, otherwise it is reset to 0. Once the internal counter reaches a threshold, the FSM terminates or changes its state. The possibilities for termination are the following:\n\nThe trajectory hits consecutive_recurrences times in a row previously visited cells:  it is considered that an attractor is found and is labelled with a new ID. Then,  iteration continues for attractor_locate_steps steps. Each cell visited in this period stores  the \"attractor\" information. Then iteration terminates and the initial condition is  numbered with the attractor's ID.\nThe trajectory hits an already identified attractor consecutive_attractor_steps consecutive times:  the initial condition is numbered with the attractor's basin ID.\nThe trajectory hits a known basin consecutive_basin_steps times in a row: the initial condition  belongs to that basin and is numbered accordingly. Notice that basins are stored and  used only when sparse = false otherwise this clause is ignored.\nThe trajectory spends consecutive_lost_steps steps outside the defined grid or the norm  of the dynamical system state becomes > than horizon_limit: the initial  condition is labelled -1.\nIf none of the above happens, the initial condition is labelled -1 after  maximum_iterations steps.\n\nThere are some special internal optimizations and details that we do not describe here but can be found in comments in the source code. (E.g., a special timer exists for the \"lost\" state which does not interrupt the main timer of the FSM.)\n\nA video illustrating how the algorithm works can be found in the online Examples page.\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Attractors.automatic_Δt_basins","page":"Finding Attractors","title":"Attractors.automatic_Δt_basins","text":"automatic_Δt_basins(ds::DynamicalSystem, grid; N = 5000) → Δt\n\nCalculate an optimal Δt value for basins_of_attraction. This is done by evaluating the dynamic rule f (vector field) at N randomly chosen points within the bounding box of the grid. The average f is then compared with the average diagonal length of a grid cell and their ratio provides Δt.\n\nNotice that Δt should not be too small which happens typically if the grid resolution is high. It is okay if the trajectory skips a few cells. Also, Δt that is smaller than the internal step size of the integrator will cause a performance drop.\n\n\n\n\n\n","category":"function"},{"location":"attractors/#Attractors.SubdivisionBasedGrid","page":"Finding Attractors","title":"Attractors.SubdivisionBasedGrid","text":"SubdivisionBasedGrid(grid::NTuple{D, <:AbstractRange}, lvl_array::Array{Int, D})\n\nGiven a coarse grid tesselating the state space, construct a SubdivisionBasedGrid based on the given level array lvl_array that should have the same dimension as grid. The level array has non-negative integer values, with 0 meaning that the corresponding cell of the coarse grid should not be subdivided any further. Value n > 0 means that the corresponding cell will be subdivided in total 2^n times (along each dimension), resulting in finer cells within the original coarse cell.\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Attractors.subdivision_based_grid","page":"Finding Attractors","title":"Attractors.subdivision_based_grid","text":"subdivision_based_grid(ds::DynamicalSystem, grid; maxlevel = 4, q = 0.99)\n\nConstruct a grid structure SubdivisionBasedGrid that can be directly passed as a grid to AttractorsViaRecurrences. The input grid is an originally coarse grid (a tuple of AbstractRanges). The state space speed is evaluate in all cells of the grid. Cells with small speed (when compared to the \"max\" speed) resultin in this cell being subdivided more. To avoid problems with spikes in the speed, the q-th quantile of the velocities is used as the \"max\" speed (use q = 1 for true maximum). The subdivisions in the resulting grid are clamped to at most value maxlevel.\n\nThis approach is designed for continuous time systems in which different areas of the state space flow may have significantly different velocity. In case of originally coarse grids, this may lead AttractorsViaRecurrences being stuck in some state space regions with a small motion speed and false identification of attractors.\n\n\n\n\n\n","category":"function"},{"location":"attractors/#Proximity","page":"Finding Attractors","title":"Proximity","text":"","category":"section"},{"location":"attractors/","page":"Finding Attractors","title":"Finding Attractors","text":"AttractorsViaProximity","category":"page"},{"location":"attractors/#Attractors.AttractorsViaProximity","page":"Finding Attractors","title":"Attractors.AttractorsViaProximity","text":"AttractorsViaProximity(ds::DynamicalSystem, attractors::Dict [, ε]; kwargs...)\n\nMap initial conditions to attractors based on whether the trajectory reaches ε-distance close to any of the user-provided attractors. They have to be in a form of a dictionary mapping attractor labels to StateSpaceSets containing the attractors.\n\nThe system gets stepped, and at each step the minimum distance to all attractors is computed. If any of these distances is < ε, then the label of the nearest attractor is returned.\n\nIf an ε::Real is not provided by the user, a value is computed automatically as half of the minimum distance between all attractors. This operation can be expensive for large StateSpaceSets. If length(attractors) == 1, then ε becomes 1/10 of the diagonal of the box containing the attractor. If length(attractors) == 1 and the attractor is a single point, an error is thrown.\n\nKeywords\n\nTtr = 100: Transient time to first evolve the system for before checking for proximity.\nΔt = 1: Step time given to step!.\nhorizon_limit = 1e3: If the maximum distance of the trajectory from any of the given attractors exceeds this limit, it is assumed that the trajectory diverged (gets labelled as -1).\nconsecutive_lost_steps = 1000: If the integrator has been stepped this many times without coming ε-near to any attractor,  it is assumed that the trajectory diverged (gets labelled as -1).\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Featurizing","page":"Finding Attractors","title":"Featurizing","text":"","category":"section"},{"location":"attractors/","page":"Finding Attractors","title":"Finding Attractors","text":"AttractorsViaFeaturizing","category":"page"},{"location":"attractors/#Attractors.AttractorsViaFeaturizing","page":"Finding Attractors","title":"Attractors.AttractorsViaFeaturizing","text":"AttractorsViaFeaturizing(\n    ds::DynamicalSystem, featurizer::Function,\n    grouping_config = GroupViaClustering(); kwargs...\n)\n\nInitialize a mapper that maps initial conditions to attractors using a featurizing and grouping approach. This is a supercase of the featurizing and clustering approach that is utilized by bSTAB (Stender and Hoffmann, 2021) and MCBB (Gelbrecht et al., 2020). See AttractorMapper for how to use the mapper. This mapper also allows the syntax mapper(u0) but only if the grouping_config is not GroupViaClustering.\n\nfeaturizer is a function f(A, t) that takes as an input an integrated trajectory A::StateSpaceSet and the corresponding time vector t and returns a vector v of features describing the trajectory. For better performance, it is strongly recommended that v isa SVector{<:Real}.\n\ngrouping_config is an instance of any subtype of GroupingConfig and decides how features will be grouped into attractors, see below.\n\nSee also the intermediate functions extract_features and group_features, which can be utilized when wanting to work directly with features.\n\nKeyword arguments\n\nT=100, Ttr=100, Δt=1: Propagated to trajectory.\nthreaded = true: Whether to run the generation of features over threads by integrating trajectories in parallel.\n\nDescription\n\nThe trajectory X of an initial condition is transformed into features. Each feature is a number useful in characterizing the attractor the initial condition ends up at, and distinguishing it from other attractors. Example features are the mean or standard deviation of some the dimensions of the trajectory, the entropy of some of the dimensions, the fractal dimension of X, or anything else you may fancy.\n\nAll feature vectors (each initial condition = 1 vector) are then grouped using one of the sevaral available grouping configurations. Each group is assumed to be a unique attractor, and hence each initial condition is labelled according to the group it is part of. The method thus relies on the user having at least some basic idea about what attractors to expect in order to pick the right features, and the right way to group them, in contrast to AttractorsViaRecurrences.\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Grouping-configurations","page":"Finding Attractors","title":"Grouping configurations","text":"","category":"section"},{"location":"attractors/#Grouping-types","page":"Finding Attractors","title":"Grouping types","text":"","category":"section"},{"location":"attractors/","page":"Finding Attractors","title":"Finding Attractors","text":"GroupingConfig\nGroupViaClustering\nGroupViaHistogram\nGroupViaNearestFeature\nGroupViaPairwiseComparison","category":"page"},{"location":"attractors/#Attractors.GroupingConfig","page":"Finding Attractors","title":"Attractors.GroupingConfig","text":"GroupingConfig\n\nSupertype for configuration structs on how to group features together. Used in several occasions such as AttractorsViaFeaturizing or aggregate_attractor_fractions.\n\nCurrently available grouping configurations are:\n\nGroupViaClustering\nGroupViaNearestFeature\nGroupViaHistogram\nGroupViaPairwiseComparison\n\nGroupingConfig defines an extendable interface. The only thing necessary for a new grouping configuration is to:\n\nMake a new type and subtype GroupingConfig.\nIf the grouping allows for mapping individual initial conditions to IDs, then instead extend the internal function feature_to_group(feature, config). This will allow doing id = mapper(u0) with AttractorsViaFeaturizing.\nElse, extend the function group_features(features, config). You could still extend group_features even if (2.) is satisfied, if there are any performance benefits.\nInclude the new grouping file in the grouping/all_grouping_configs.jl and list it in this documentation string.\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Attractors.GroupViaClustering","page":"Finding Attractors","title":"Attractors.GroupViaClustering","text":"GroupViaClustering(; kwargs...)\n\nInitialize a struct that contains instructions on how to group features in AttractorsViaFeaturizing. GroupViaClustering clusters features into groups using DBSCAN, similar to the original work by bSTAB (Stender and Hoffmann, 2021) and MCBB (Gelbrecht et al., 2020). Several options on clustering are available, see keywords below.\n\nThe defaults are a significant improvement over existing literature, see Description.\n\nKeyword arguments\n\nclust_distance_metric = Euclidean(): A metric to be used in the clustering. It can be any function f(a, b) that returns the distance between real-valued vectors a, b. All metrics from Distances.jl can be used here.\nrescale_features = true: if true, rescale each dimension of the extracted features separately into the range [0,1]. This typically leads to more accurate clustering.\nmin_neighbors = 10: minimum number of neighbors (i.e. of similar features) each feature needs to have, including counting its own self, in order to be considered in a cluster (fewer than this, it is labeled as an outlier, -1).\nuse_mmap = false: whether to use an on-disk map for creating the distance matrix of the features. Useful when the features are so many where a matrix with side their length would not fit to memory.\n\nKeywords for optimal radius estimation\n\noptimal_radius_method::Union{Real, String} = \"silhouettes_optim\": if a real number, it is the radius used to cluster features. Otherwise, it determines the method used to automatically determine that radius. Possible values are:\n\"silhouettes\": Performs a linear (sequential) search for the radius that maximizes a   statistic of the silhouette values of clusters (typically the mean). This can be chosen   with silhouette_statistic. The linear search may take some time to finish. To   increase speed, the number of radii iterated through can be reduced by decreasing   num_attempts_radius (see its entry below).\n\"silhouettes_optim\": Same as \"silhouettes\" but performs an optimized search via   Optim.jl. It's faster than \"silhouettes\", with typically the same accuracy (the   search here is not guaranteed to always find the global maximum, though it typically   gets close).\n\"knee\": chooses the the radius according to the knee (a.k.a. elbow,   highest-derivative method) and is quicker, though generally leading to much worse   clustering. It requires that min_neighbors > 1.\nnum_attempts_radius = 100: number of radii that the optimal_radius_method will try out in its iterative procedure. Higher values increase the accuracy of clustering, though not necessarily much, while always reducing speed.\nsilhouette_statistic::Function = mean: statistic (e.g. mean or minimum) of the silhouettes that is maximized in the \"optimal\" clustering. The original implementation in (Stender and Hoffmann, 2021) used the minimum of the silhouettes, and typically performs less accurately than the mean.\nmax_used_features = 0: if not 0, it should be an Int denoting the max amount of features to be used when finding the optimal radius. Useful when clustering a very large number of features (e.g., high accuracy estimation of fractions of basins of attraction).\n\nDescription\n\nThe DBSCAN clustering algorithm is used to automatically identify clusters of similar features. Each feature vector is a point in a feature space. Each cluster then basically groups points that are closely packed together. Closely packed means that the points have at least min_neighbors inside a ball of radius optimal_radius centered on them. This method typically works well if the radius is chosen well, which is not necessarily an easy task. Currently, three methods are implemented to automatically estimate an \"optimal\" radius.\n\nEstimating the optimal radius\n\nThe default method is the silhouettes method, which includes keywords silhouette and silhouette_optim. Both of them search for the radius that optimizes the clustering, meaning the one that maximizes a statistic silhouette_statistic (e.g. mean value) of a quantifier for the quality of each cluster. This quantifier is the silhouette value of each identified cluster. A silhouette value measures how similar a point is to the cluster it currently belongs to, compared to the other clusters, and ranges from -1 (worst matching) to +1 (ideal matching). If only one cluster is found, the assigned silhouette is zero. So for each attempted radius in the search the clusters are computed, their silhouettes calculated, and the statistic of these silhouettes computed. The algorithm then finds the radius that leads to the maximum such statistic. For optimal_radius_method = \"silhouettes\", the search is done linearly, from a minimum to a maximum candidate radius for optimal_radius_method = \"silhouettes\"; optimal_radius_method = silhouettes_optim, it is done via an optimized search performed by Optim.jl which is typically faster and with similar accuracy. A third alternative is the\"elbow\" method, which works by calculating the distance of each point to its k-nearest-neighbors (with k=min_neighbors) and finding the distance corresponding to the highest derivative in the curve of the distances, sorted in ascending order. This distance is chosen as the optimal radius. It is described in (Ester et al., 1996) and (Schubert et al., 2017). It typically performs considerably worse than the \"silhouette\" methods.\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Attractors.GroupViaHistogram","page":"Finding Attractors","title":"Attractors.GroupViaHistogram","text":"GroupViaHistogram(binning::FixedRectangularBinning)\n\nInitialize a struct that contains instructions on how to group features in AttractorsViaFeaturizing. GroupViaHistogram performs a histogram in feature space. Then, all features that are in the same histogram bin get the same label. The binning is an instance of FixedRectangularBinning from ComplexityMeasures.jl. (the reason to not allow RectangularBinning is because during continuation we need to ensure that bins remain identical).\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Attractors.GroupViaNearestFeature","page":"Finding Attractors","title":"Attractors.GroupViaNearestFeature","text":"GroupViaNearestFeature(templates; kwargs...)\n\nInitialize a struct that contains instructions on how to group features in AttractorsViaFeaturizing. GroupViaNearestFeature accepts a template, which is a vector of features. Then, generated features from initial conditions in AttractorsViaFeaturizing are labelled according to the feature in templates that is closest (the label is the index of the closest template).\n\ntemplates can be a vector or dictionary mapping keys to templates. Internally all templates are converted to SVector for performance. Hence, it is strongly recommended that both templates and the output of the featurizer function in AttractorsViaFeaturizing return SVector types.\n\nKeyword arguments\n\nmetric = Euclidean(): metric to be used to quantify distances in the feature space.\nmax_distance = Inf: Maximum allowed distance between a feature and its nearest template for it to be assigned to that template. By default, Inf guarantees that a feature is assigned to its nearest template regardless of the distance. Features that exceed max_distance to their nearest template get labelled -1.\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Attractors.GroupViaPairwiseComparison","page":"Finding Attractors","title":"Attractors.GroupViaPairwiseComparison","text":"GroupViaPairwiseComparison(; threshold::Real, kwargs...)\n\nInitialize a struct that contains instructions on how to group features in AttractorsViaFeaturizing. GroupViaPairwiseComparison groups features and identifies clusters by considering the pairwise distance between features. It can be used as an alternative to the clustering method in GroupViaClustering, having the advantage that it is simpler, typically faster and uses less memory.\n\nKeyword arguments\n\nthreshold (mandatory): A real number defining the maximum distance two features can be to be considered in the same cluster - above the threshold, features are different. This value simply needs to be large enough to differentiate clusters.\nmetric = Euclidean(): A function metric(a, b) that returns the distance between two features a and b, outputs of featurizer. Any Metric from Distances.jl can be used here.\nrescale_features = true: if true, rescale each dimension of the extracted features separately into the range [0,1]. This typically leads to more accurate grouping.\n\nDescription\n\nThis algorithm assumes that the features are well-separated into distinct clouds, with the maximum radius of the cloud controlled by threshold. Since the systems are deterministic, this is achievable with a good-enough featurizer function, by removing transients, and running the trajectories for sufficiently long. It then considers that features belong to the same attractor when their pairwise distance, computed using metric, is smaller than or equal to threshold, and that they belong to different attractors when the distance is bigger. Attractors correspond to each grouping of similar features. In this way, the key parameter threshold is basically the amount of variation permissible in the features belonging to the same attractor. If they are well-chosen, the value can be relatively small and does not need to be fine tuned.\n\nThe threshold should achieve a balance: one one hand, it should be large enough to account for variations in the features from the same attractor - if it's not large enough, the algorithm will find duplicate attractors. On the other hand, it should be small enough to not group together features from distinct attractors. This requires some knowledge of how spread the features are. If it's too big, the algorithm will miss some attractors, as it groups 2+ distinct attractors together. Therefore, as a rule of thumb, one can repeat the procedure a few times, starting with a relatively large value and reducing it until no more attractors are found and no duplicates appear.\n\nThe method uses relatively little memory, as it only stores vectors whose size is on order of the number of attractors of the system.\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Grouping-utility-functions","page":"Finding Attractors","title":"Grouping utility functions","text":"","category":"section"},{"location":"attractors/","page":"Finding Attractors","title":"Finding Attractors","text":"group_features\nextract_features","category":"page"},{"location":"attractors/#Attractors.group_features","page":"Finding Attractors","title":"Attractors.group_features","text":"group_features(features, group_config::GroupingConfig) → labels\n\nGroup the given vector of feature vectors according to the configuration and return the labels (vector of equal length as features). See AttractorsViaFeaturizing for possible configurations.\n\n\n\n\n\n","category":"function"},{"location":"attractors/#Attractors.extract_features","page":"Finding Attractors","title":"Attractors.extract_features","text":"extract_features(mapper, ics; N = 1000, show_progress = true)\n\nReturn a vector of the features of each initial condition in ics (as in basins_fractions), using the configuration of mapper::AttractorsViaFeaturizing. Keyword N is ignored if ics isa StateSpaceSet.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Visualization-utilities","page":"Visualization utilities","title":"Visualization utilities","text":"","category":"section"},{"location":"visualization/","page":"Visualization utilities","title":"Visualization utilities","text":"In this page we document several plotting utility functions that have been created to make the visualization of the output of Attractors.jl seamless. See the examples page for usage of all these plotting functions.","category":"page"},{"location":"visualization/","page":"Visualization utilities","title":"Visualization utilities","text":"Note that most functions have an out-of-place and an in-place form, the in-place form always taking as a first input a pre-initialized Axis to plot in while the out-of-place creates and returns a new figure object.","category":"page"},{"location":"visualization/","page":"Visualization utilities","title":"Visualization utilities","text":"E.g.,","category":"page"},{"location":"visualization/","page":"Visualization utilities","title":"Visualization utilities","text":"heatmap_basins_attractors(grid, basins, attractors; kwargs...)\nheatmap_basins_attractors!(ax, grid, basins, attractors; kwargs...)","category":"page"},{"location":"visualization/#common_plot_kwargs","page":"Visualization utilities","title":"Common plotting keywords","text":"","category":"section"},{"location":"visualization/","page":"Visualization utilities","title":"Visualization utilities","text":"Common keywords for plotting functions in Attractors.jl are:","category":"page"},{"location":"visualization/","page":"Visualization utilities","title":"Visualization utilities","text":"ukeys: the basin ids (unique keys, vector of integers) to use. By default all existing keys are used.\naccess = [1, 2]: indices of which dimensions of an attractor to select and visualize in a two-dimensional plot. Only these ids will be visualized. By default all are used.\ncolors: a dictionary mapping basin ids (i.e., including the -1 key) to a color. By default the JuliaDynamics colorscheme is used if less than 7 ids are present, otherwise random colors from the :darktest colormap.\nmarkers: dictionary mapping attractor ids to markers they should be plotted as\nlabels = Dict(ukeys .=> ukeys): how to label each attractor.\nadd_legend = length(ukeys) < 7: whether to add a legend mapping colors to labels.","category":"page"},{"location":"visualization/#Basins-related","page":"Visualization utilities","title":"Basins related","text":"","category":"section"},{"location":"visualization/","page":"Visualization utilities","title":"Visualization utilities","text":"heatmap_basins_attractors\nshaded_basins_heatmap","category":"page"},{"location":"visualization/#Attractors.heatmap_basins_attractors","page":"Visualization utilities","title":"Attractors.heatmap_basins_attractors","text":"heatmap_basins_attractors(grid, basins, attractors; kwargs...)\n\nPlot a heatmap of found (2-dimensional) basins of attraction and corresponding attractors, i.e., the output of basins_of_attraction.\n\nKeyword arguments\n\nAll the common plotting keywords.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Attractors.shaded_basins_heatmap","page":"Visualization utilities","title":"Attractors.shaded_basins_heatmap","text":"shaded_basins_heatmap(grid, basins, attractors, iterations; kwargs...)\n\nPlot a heatmap of found (2-dimensional) basins of attraction and corresponding attractors. A matrix iterations with the same size of basins must be provided to shade the color according to the value of this matrix. A small value corresponds to a light color and a large value to a darker tone. This is useful to represent the number of iterations taken for each initial condition to converge. See also convergence_time to store this iteration number.\n\nKeyword arguments\n\nshow_attractors = true: shows the attractor on plot\nmaxit = maximum(iterations): clip the values of iterations to\n\nthe value maxit. Useful when there are some very long iterations and keep the range constrained to a given interval.\n\nAll the common plotting keywords.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Continuation-related","page":"Visualization utilities","title":"Continuation related","text":"","category":"section"},{"location":"visualization/","page":"Visualization utilities","title":"Visualization utilities","text":"plot_basins_curves\nplot_attractors_curves\nplot_basins_attractors_curves","category":"page"},{"location":"visualization/#Attractors.plot_basins_curves","page":"Visualization utilities","title":"Attractors.plot_basins_curves","text":"plot_basins_curves(fractions_curves, prange = 1:length(); kwargs...)\n\nPlot the fractions of basins of attraction versus a parameter range, i.e., visualize the output of continuation. See also plot_basins_attractors_curves.\n\nKeyword arguments\n\nstyle = :band: how to visualize the basin fractions. Choices are :band for a band plot with cumulative sum = 1 or :lines for a lines plot of each basin fraction\nseparatorwidth = 1, separatorcolor = \"white\": adds a line separating the fractions if the style is :band\naxislegend_kwargs = (position = :lt,): propagated to axislegend if a legend is added\nseries_kwargs = NamedTuple(): propagated to the band or scatterline plot\nAlso all common plotting keywords.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Attractors.plot_attractors_curves","page":"Visualization utilities","title":"Attractors.plot_attractors_curves","text":"plot_attractors_curves(attractors_info, attractor_to_real, prange = 1:length(); kwargs...)\n\nSame as in plot_basins_curves but visualizes the attractor dependence on the parameter instead of their fraction. The function attractor_to_real takes as input a StateSpaceSet (attractor) and returns a real number so that it can be plotted versus the parameter axis. See also plot_basins_attractors_curves.\n\nSame keywords as plot_basins_curves.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Attractors.plot_basins_attractors_curves","page":"Visualization utilities","title":"Attractors.plot_basins_attractors_curves","text":"plot_basins_attractors_curves(\n    fractions_curves, attractors_info, a2rs [, prange]\n    kwargs...\n)\n\nConvenience combination of plot_basins_curves and plot_attractors_curves in a multi-panel plot that shares legend, colors, markers, etc. This function allows a2rs to be a Vector of functions, each mapping attractors into real numbers. Below the basins fractions plot, one additional panel is created for each entry in a2rs. a2rs can also be a single function, in which case only one panel is made.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Video-output","page":"Visualization utilities","title":"Video output","text":"","category":"section"},{"location":"visualization/","page":"Visualization utilities","title":"Visualization utilities","text":"animate_attractors_continuation","category":"page"},{"location":"visualization/#Attractors.animate_attractors_continuation","page":"Visualization utilities","title":"Attractors.animate_attractors_continuation","text":"animate_attractors_continuation(\n    ds::DynamicalSystem, attractors_info, fractions_curves, prange, pidx;\n    kwargs...\n)\n\nAnimate how the found system attractors and their corresponding basin fractions change as the system parameter is increased. This function combines the input and output of the continuation function into a video output.\n\nThe input dynamical system ds is used to evolve initial conditions sampled from the found attractors, so that the attractors are better visualized. attractors_info, fractions_curves are the output of continuation while ds, prange, pidx are the input to continuation.\n\nKeyword arguments\n\nsavename = \"attracont.mp4\": name of video output file.\nframerate = 4: framerate of video output.\nΔt, T: propagated to trajectory for evolving an initial condition sampled from an attractor.\nAlso all common plotting keywords.\n\n\n\n\n\n","category":"function"},{"location":"#Attractors.jl","page":"Attractors.jl","title":"Attractors.jl","text":"","category":"section"},{"location":"","page":"Attractors.jl","title":"Attractors.jl","text":"Attractors","category":"page"},{"location":"#Attractors","page":"Attractors.jl","title":"Attractors","text":"Attractors.jl\n\n(Image: docsdev) (Image: docsstable) (Image: Paper) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia module for\n\nfinding attractors of arbitrary dynamical systems\nfinding their basins of attraction or the state space fractions of the basins\nanalyzing global stability of attractors (also called non-local stability or  resilience)\n\"continuing\" the attractors and their basins over a parameter range\nfinding the basin boundaries and analyzing their fractal properties\ntipping points related functionality for systems with known dynamic rule\nand more!\n\nIt can be used as a standalone package, or as part of DynamicalSystems.jl.\n\nTo install it, run import Pkg; Pkg.add(\"Attractors\").\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\nPreviously, Attractors.jl was part of ChaosTools.jl\n\n\n\n\n\n","category":"module"},{"location":"","page":"Attractors.jl","title":"Attractors.jl","text":"using CairoMakie, Attractors","category":"page"},{"location":"#Latest-news","page":"Attractors.jl","title":"Latest news","text":"","category":"section"},{"location":"","page":"Attractors.jl","title":"Attractors.jl","text":"New functions test_wada_merge and convergence_and_basins_fractions!","category":"page"},{"location":"#Outline-of-Attractors.jl","page":"Attractors.jl","title":"Outline of Attractors.jl","text":"","category":"section"},{"location":"","page":"Attractors.jl","title":"Attractors.jl","text":"(Image: Attractors.jl flowchart)","category":"page"},{"location":"","page":"Attractors.jl","title":"Attractors.jl","text":"First be sure that you are aware of what is a DynamicalSystem in the context of the DynamicalSystems.jl library. The best way to learn this is by following the main tutorial of the library. This is the input to the whole infrastructure of Attractors.jl.\nThe bulk of the work in Attractors.jl is done by the AttractorMapper type, that instructs how to find attractors and maps initial conditions to them. It can be used in functions like basins_fractions.\nFor grouping features, there is a sub-infrastructure for instructing how to group features, which is governed by GroupingConfig.\nThe infrastructure of finding attractors and their basins fractions is then integrated into a brand new way of doing bifurcation analysis in the continuation function.\nSee Examples for Attractors.jl for several applications in real world cases.","category":"page"}]
}
