<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Attractor &amp; Basins Continuation · Attractors.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Attractors.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Attractors.jl</a></li><li><a class="tocitem" href="../attractors/">Finding Attractors</a></li><li><a class="tocitem" href="../basins/">Basins of Attraction</a></li><li class="is-active"><a class="tocitem" href>Attractor &amp; Basins Continuation</a><ul class="internal"><li><a class="tocitem" href="#A-new-kind-of-continuation"><span>A new kind of continuation</span></a></li><li><a class="tocitem" href="#Continuation-API"><span>Continuation API</span></a></li><li><a class="tocitem" href="#Recurrences-continuation-(best)"><span>Recurrences continuation (best)</span></a></li><li><a class="tocitem" href="#Matching-attractors"><span>Matching attractors</span></a></li><li><a class="tocitem" href="#Aggregating-attractors-and-fractions"><span>Aggregating attractors and fractions</span></a></li><li><a class="tocitem" href="#Grouping-continuation"><span>Grouping continuation</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Examples for Attractors.jl</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Attractor &amp; Basins Continuation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Attractor &amp; Basins Continuation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/Attractors.jl/blob/main/docs/src/continuation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Attractor-and-Basins-Continuation"><a class="docs-heading-anchor" href="#Attractor-and-Basins-Continuation">Attractor &amp; Basins Continuation</a><a id="Attractor-and-Basins-Continuation-1"></a><a class="docs-heading-anchor-permalink" href="#Attractor-and-Basins-Continuation" title="Permalink"></a></h1><h2 id="A-new-kind-of-continuation"><a class="docs-heading-anchor" href="#A-new-kind-of-continuation">A new kind of continuation</a><a id="A-new-kind-of-continuation-1"></a><a class="docs-heading-anchor-permalink" href="#A-new-kind-of-continuation" title="Permalink"></a></h2><p>If you have heard before the word &quot;continuation&quot;, then you are likely aware of the <strong>standard (linearized) continuation</strong> offered by many software, in Julia particularly the <a href="https://github.com/bifurcationkit/BifurcationKit.jl">BifurcationKit.jl</a>.</p><p>Here we offer a completely different kind of continuation called <strong>attractors &amp; basins continuation</strong>.</p><p>A direct comparison of the two approaches is not truly possible, because they do different things. The traditional linearized continuation analysis continues the curves of individual fixed points across the joint state-parameter space. The attractor and basins continuation first finds all attractors at all parameter values and then <em>matches</em> appropriately similar attractors across different parameters, giving the illusion of continuing them individually. Additionally, the curves of stable fixed points in the joint parameter space is only a small by-product of the attractor basins continuation, and the main information is the basin fractions and how these change in the parameter space.</p><p>A more detailed comparison of the methods will be provided soon in a paper we are writing (will put link here, stay tuned!).</p><h2 id="Continuation-API"><a class="docs-heading-anchor" href="#Continuation-API">Continuation API</a><a id="Continuation-API-1"></a><a class="docs-heading-anchor-permalink" href="#Continuation-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Attractors.continuation" href="#Attractors.continuation"><code>Attractors.continuation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">continuation(abc::AttractorsBasinsContinuation, prange, pidx, ics; kwargs...)</code></pre><p>Find and continue attractors (or feature-based representations of attractors) and the fractions of their basins of attraction across a parameter range.</p><p>The continuation type <code>abc</code> is a subtype of <code>AttractorsBasinsContinuation</code> and contains an <a href="../attractors/#Attractors.AttractorMapper"><code>AttractorMapper</code></a>. The mapper contains information on how to find the attractors and basins of a dynamical system. Additional arguments and keyword arguments given when creating <code>abc</code> further tune the continuation and how attractors are matched across different parameter values.</p><p>The basin fractions and the attractors (or some representation of them) are continued across the parameter range <code>prange</code>, for the parameter of the system with index <code>pidx</code> (any index valid in <a href="@ref"><code>set_parameter!</code></a> can be used).</p><p><code>ics</code> is a 0-argument function generating initial conditions for the dynamical system (as in <a href="../basins/#Attractors.basins_fractions"><code>basins_fractions</code></a>).</p><p>Possible subtypes of <code>AttractorsBasinsContinuation</code> are:</p><ul><li><a href="#Attractors.RecurrencesSeededContinuation"><code>RecurrencesSeededContinuation</code></a></li><li><a href="#Attractors.GroupAcrossParameterContinuation"><code>GroupAcrossParameterContinuation</code></a></li></ul><p><strong>Return</strong></p><ol><li><code>fractions_curves :: Vector{Dict{Int, Float64}}</code>. The fractions of basins of attraction. <code>fractions_curves[i]</code> is a dictionary mapping attractor IDs to their basin fraction at the <code>i</code>-th parameter.</li><li><code>attractors_info &lt;: Vector{Dict{Int, &lt;:Any}}</code>. Information about the attractors. <code>attractors_info[i]</code> is a dictionary mapping attractor ID to information about the attractor at the <code>i</code>-th parameter. The type of information stored depends on the chosen continuation type.</li></ol><p><strong>Keyword arguments</strong></p><ul><li><code>show_progress = true</code>: display a progress bar of the computation.</li><li><code>samples_per_parameter = 100</code>: amount of initial conditions sampled at each parameter from <code>ics</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/26adaf043766034045b306369f328342fff6104c/src/continuation/basins_fractions_continuation_api.jl#L9-L48">source</a></section></article><h2 id="Recurrences-continuation-(best)"><a class="docs-heading-anchor" href="#Recurrences-continuation-(best)">Recurrences continuation (best)</a><a id="Recurrences-continuation-(best)-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrences-continuation-(best)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Attractors.RecurrencesSeededContinuation" href="#Attractors.RecurrencesSeededContinuation"><code>Attractors.RecurrencesSeededContinuation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RecurrencesSeededContinuation &lt;: AttractorsBasinsContinuation
RecurrencesSeededContinuation(mapper::AttractorsViaRecurrences; kwargs...)</code></pre><p>A method for <a href="@ref"><code>rsc</code></a>. TODO: Cite our preprint here.</p><p><strong>Description</strong></p><p>At the first parameter slice attractors and their fractions are found as described in the <a href="../attractors/#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a> mapper using recurrences in state space. At each subsequent parameter slice, new attractors are found by seeding initial conditions from the previously found attractors and then piping these initial conditions through the recurrences algorithm of the <code>mapper</code>. Seeding initial conditions close to previous attractors accelerates the main bottleneck of <a href="../attractors/#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a>, which is finding the attractors. After the attractors are found, their fractions are computed by running new initial conditions through the <a href="../attractors/#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a> mapper. This process continues until all parameter values are exhausted and for each parameter value the attractors and their fractions are found.</p><p>Then, the different attractors across parameters are matched so that they have the same ID. The matching process is based on distances between attractors. The function that computes these distances is <a href="#StateSpaceSets.setsofsets_distances"><code>setsofsets_distances</code></a> and the matching function is <a href="#Attractors.match_attractor_ids!"><code>match_attractor_ids!</code></a> (please read those docstrings as well).</p><p>At each parameter slice beyond the first, the new attractors are matched to the previous attractors found in the previous parameter value by a direct call to the <a href="#Attractors.match_attractor_ids!"><code>match_attractor_ids!</code></a> function. Hence, the matching of attractors here works &quot;slice by slice&quot; on the parameter axis and the attractors that are closest to each other (in state space, but for two different parameter values) get assigned the same label.</p><p><strong>Keyword arguments</strong></p><ul><li><code>distance, threshold</code>: propagated to <a href="#Attractors.match_attractor_ids!"><code>match_attractor_ids!</code></a>.</li><li><code>info_extraction = identity</code>: A function that takes as an input an attractor (<code>StateSpaceSet</code>) and outputs whatever information should be stored. It is used to return the <code>attractors_info</code> in <a href="@ref"><code>rsc</code></a>.</li><li><code>seeds_from_attractor</code>: A function that takes as an input an attractor and returns an iterator of initial conditions to be seeded from the attractor for the next parameter slice. By default, we sample some points from existing attractors according to how many points the attractors themselves contain. A maximum of <code>10</code> seeds is done per attractor.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/26adaf043766034045b306369f328342fff6104c/src/continuation/continuation_recurrences.jl#L15-L58">source</a></section></article><h2 id="Matching-attractors"><a class="docs-heading-anchor" href="#Matching-attractors">Matching attractors</a><a id="Matching-attractors-1"></a><a class="docs-heading-anchor-permalink" href="#Matching-attractors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Attractors.match_attractor_ids!" href="#Attractors.match_attractor_ids!"><code>Attractors.match_attractor_ids!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">match_attractor_ids!(a₊::AbstractDict, a₋; distance = Centroid(), threshold = Inf)</code></pre><p>Given dictionaries <code>a₊, a₋</code> mapping IDs to attractors (<code>StateSpaceSet</code> instances), match attractor IDs in dictionary <code>a₊</code> so that its attractors that are the closest to those in dictionary <code>a₋</code> get assigned the same key as in <code>a₋</code>. Typically the +,- mean after and before some change of parameter of a system.</p><p>Return the replacement map, a dictionary mapping old keys of <code>a₊</code> to the new ones that they were mapped to. You can obtain this map, without modifying the dictionaries, by calling the <a href="#Attractors.replacement_map"><code>replacement_map</code></a> function directly.</p><p><strong>Description</strong></p><p>When finding attractors and their fractions in DynamicalSystems.jl, different attractors get assigned different IDs. However which attractor gets which ID is somewhat arbitrary. Finding the attractors of the same system for slightly different parameters could label &quot;similar&quot; attractors (at the different parameters) with different IDs. <code>match_attractors_ids!</code> tries to &quot;match&quot; them by modifying the attractor IDs, i.e., the keys of the given dictionaries.</p><p>The matching happens according to the output of the <a href="#StateSpaceSets.setsofsets_distances"><code>setsofsets_distances</code></a> function with the keyword <code>distance</code>. distance` can be whatever that function accepts. Attractors are then match according to distance, with unique mapping. The closest attractors (before and after) are mapped to each other, and are removed from the matching pool, and then the next pair with least remaining distance is matched, and so on.</p><p>Additionally, you can provide a <code>threshold</code> value. If the distance between two attractors is larger than this <code>threshold</code>, then it is guaranteed that the attractors will get assigned different key in the dictionary <code>a₊</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/26adaf043766034045b306369f328342fff6104c/src/continuation/match_attractor_ids.jl#L7-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Attractors.replacement_map" href="#Attractors.replacement_map"><code>Attractors.replacement_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">replacement_map(a₊, a₋; distance = Centroid(), threshold = Inf) → rmap</code></pre><p>Return a dictionary mapping keys in <code>a₊</code> to new keys in <code>a₋</code>, as explained in <a href="#Attractors.match_attractor_ids!"><code>match_attractor_ids!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/26adaf043766034045b306369f328342fff6104c/src/continuation/match_attractor_ids.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.set_distance" href="#StateSpaceSets.set_distance"><code>StateSpaceSets.set_distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_distance(ssset1, ssset2 [, distance])</code></pre><p>Calculate a distance between two <code>StateSpaceSet</code>s, i.e., a distance defined between sets of points, as dictated by <code>distance</code>.</p><p>Possible <code>distance</code> types are:</p><ul><li><a href="@ref"><code>Centroid</code></a>, which is the default, and 100s of times faster than the rest</li><li><a href="@ref"><code>Hausdorff</code></a></li><li><a href="@ref"><code>StrictlyMinimumDistance</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.setsofsets_distances" href="#StateSpaceSets.setsofsets_distances"><code>StateSpaceSets.setsofsets_distances</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setsofsets_distances(a₊, a₋ [, distance]) → distances</code></pre><p>Calculate distances between sets of <code>StateSpaceSet</code>s. Here  <code>a₊, a₋</code> are containers of <code>StateSpaceSet</code>s, and the returned distances are dictionaries of of distances. Specifically, <code>distances[i][j]</code> is the distance of the set in the <code>i</code> key of <code>a₊</code> to the <code>j</code> key of <code>a₋</code>. Notice that distances from <code>a₋</code> to <code>a₊</code> are not computed at all (assumming symmetry in the distance function).</p><p>The <code>distance</code> can be as in <a href="#StateSpaceSets.set_distance"><code>set_distance</code></a>. However, <code>distance</code> can also be any arbitrary user function that takes as input two state space sets and returns any positive-definite number as their &quot;distance&quot;.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Attractors.match_basins_ids!" href="#Attractors.match_basins_ids!"><code>Attractors.match_basins_ids!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">match_basins_ids!(b₊::AbstractArray, b₋; threshold = Inf)</code></pre><p>Similar to <a href="#Attractors.match_attractor_ids!"><code>match_attractor_ids!</code></a> but operate on basin arrays instead (the arrays typically returned by <a href="../basins/#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>).</p><p>This method matches IDs of attractors whose basins of attraction before and after <code>b₋,b₊</code> have the most overlap (in pixels). This overlap is normalized in 0-1 (with 1 meaning 100% overlap of pixels). The <code>threshold</code> in this case is compared to the inverse of the overlap (so, for <code>threshold = 2</code> attractors that have less than 50% overlap get different IDs guaranteed).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/26adaf043766034045b306369f328342fff6104c/src/continuation/match_attractor_ids.jl#L116-L126">source</a></section></article><h2 id="Aggregating-attractors-and-fractions"><a class="docs-heading-anchor" href="#Aggregating-attractors-and-fractions">Aggregating attractors and fractions</a><a id="Aggregating-attractors-and-fractions-1"></a><a class="docs-heading-anchor-permalink" href="#Aggregating-attractors-and-fractions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Attractors.aggregate_attractor_fractions" href="#Attractors.aggregate_attractor_fractions"><code>Attractors.aggregate_attractor_fractions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">aggregate_attractor_fractions(
    fractions_curves, attractors_info, featurizer, group_config [, info_extraction]
)</code></pre><p>Aggregate the already-estimated curves of fractions of basins of attraction of similar attractors using the same pipeline used by <a href="../attractors/#Attractors.GroupingConfig"><code>GroupingConfig</code></a>. The most typical application of this function is to transform the output of <a href="#Attractors.RecurrencesSeededContinuation"><code>RecurrencesSeededContinuation</code></a> so that similar attractors, even across parameter space, are grouped into one &quot;attractor&quot;. Thus, the fractions of their basins are aggregated.</p><p>You could also use this function to aggregate attractors and their fractions even in a single parameter configuration, i.e., using the output of <a href="../basins/#Attractors.basins_fractions"><code>basins_fractions</code></a>.</p><p>This function is useful in cases where you want the accuracy and performance of <a href="../attractors/#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a>, but you also want the convenience of &quot;grouping&quot; similar attractrors like in <a href="../attractors/#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a> for presentation or analysis purposes. For example, a high dimesional model of competition dynamics across multispecies may have extreme multistability. After finding this multistability however, one may care about aggregating all attractors into two groups: where a given species is extinct or not. This is the example highlighted in our documentation, in <a href="../examples/#Extinction-of-a-species-in-a-multistable-competition-model">Extinction of a species in a multistable competition model</a>.</p><p><strong>Input</strong></p><ol><li><code>fractions_curves</code>: a vector of dictionaries mapping labels to basin fractions.</li><li><code>attractors_info</code>: a vector of dictionaries mapping labels to attractors. 1st and 2nd argument are exactly like the return values of <a href="#Attractors.continuation"><code>continuation</code></a> with <a href="#Attractors.RecurrencesSeededContinuation"><code>RecurrencesSeededContinuation</code></a> (or, they can be the return of <a href="../basins/#Attractors.basins_fractions"><code>basins_fractions</code></a>).</li><li><code>featurizer</code>: a 1-argument function to map an attractor into an appropriate feature to be grouped later. Features expected by <a href="../attractors/#Attractors.GroupingConfig"><code>GroupingConfig</code></a> are <code>SVector</code>.</li><li><code>group_config</code>: a subtype of <a href="../attractors/#Attractors.GroupingConfig"><code>GroupingConfig</code></a>.</li><li><code>info_extraction</code>: a function accepting a vector of features and returning a description of the features. I.e., exactly as in <a href="#Attractors.GroupAcrossParameterContinuation"><code>GroupAcrossParameterContinuation</code></a>. The 5th argument is optional and defaults to the centroid of the features.</li></ol><p><strong>Return</strong></p><ol><li><code>aggregated_fractions</code>: same as <code>fractions_curves</code> but now contains the fractions of the aggregated attractors.</li><li><code>aggregated_info</code>: dictionary mapping the new labels of <code>aggregated_fractions</code> to the extracted information using <code>info_extraction</code>.</li></ol><p><strong>Clustering attractors directly</strong></p><p><em>(this is rather advanced)</em></p><p>You may also use the DBSCAN clustering approach here to group attractors based on their state space distance (the <a href="#StateSpaceSets.set_distance"><code>set_distance</code></a>) by making a distance matrix as expected by the DBSCAN implementation. For this, use <code>identity</code> as <code>featurizer</code>, and choose <a href="../attractors/#Attractors.GroupViaClustering"><code>GroupViaClustering</code></a> as the <code>group_config</code> with <code>clust_distance_metric = set_distance</code> and provide a numerical value for <code>optimal_radius_method</code> when initializing the <a href="../attractors/#Attractors.GroupViaClustering"><code>GroupViaClustering</code></a>, and also, for the <code>info_extraction</code> argument, you now need to provide a function that expects a <em>vector of <code>StateSpaceSet</code>s</em> and outputs a descriptor. E.g., <code>info_extraction = vector -&gt; mean(mean(x) for x in vector)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/26adaf043766034045b306369f328342fff6104c/src/continuation/aggregate_attractor_fractions.jl#L3-L60">source</a></section></article><h2 id="Grouping-continuation"><a class="docs-heading-anchor" href="#Grouping-continuation">Grouping continuation</a><a id="Grouping-continuation-1"></a><a class="docs-heading-anchor-permalink" href="#Grouping-continuation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Attractors.GroupAcrossParameterContinuation" href="#Attractors.GroupAcrossParameterContinuation"><code>Attractors.GroupAcrossParameterContinuation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GroupAcrossParameterContinuation(mapper::AttractorsViaFeaturizing; kwargs...)</code></pre><p>A method for <a href="#Attractors.continuation"><code>continuation</code></a>. It uses the featurizing approach discussed in <a href="../attractors/#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a> and hence requires an instance of that mapper as an input. When used in <a href="#Attractors.continuation"><code>continuation</code></a>, features are extracted and then grouped across a parameter range. Said differently, all features of all initial conditions across all parameter values are put into the same &quot;pool&quot; and then grouped as dictated by the <code>group_config</code> of the mapper. After the grouping is finished the feature label fractions are distributed to each parameter value they came from.</p><p><strong>Keyword arguments</strong></p><ul><li><code>info_extraction::Function</code> a function that takes as an input a vector of feature-vectors (corresponding to a cluster) and returns a description of the cluster. By default, the centroid of the cluster is used.</li><li><code>par_weight = 0</code>: See below the section on MCBB.</li></ul><p><strong>MCBB special version</strong></p><p>If the chosen grouping method is <a href="../attractors/#Attractors.GroupViaClustering"><code>GroupViaClustering</code></a>, the additional keyword <code>par_weight::Real</code> can be used. If it is ≠ 0, the distance matrix between features obtains an extra weight that is proportional to the distance <code>par_weight*|p[i] - p[j]|</code> between the parameters used when extracting features. The range of parameters is normalized to 0-1 such that the largest distance in the parameter space is 1. The normalization is done because the feature space is also (by default) normalized to 0-1.</p><p>This version of the algorithm is the original &quot;MCBB&quot; continuation method described in <sup class="footnote-reference"><a id="citeref-Gelbrecht2020" href="#footnote-Gelbrecht2020">[Gelbrecht2020]</a></sup>, besides the improvements of clustering accuracy and performance done by the developer team of Attractors.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/26adaf043766034045b306369f328342fff6104c/src/continuation/continuation_grouping.jl#L11-L46">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Gelbrecht2021"><a class="tag is-link" href="#citeref-Gelbrecht2021">Gelbrecht2021</a>Maximilian Gelbrecht et al 2021, Monte Carlo basin bifurcation analysis, <a href="http://dx.doi.org/10.1088/1367-2630/ab7a05">New J. Phys.22 03303</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../basins/">« Basins of Attraction</a><a class="docs-footer-nextpage" href="../examples/">Examples for Attractors.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 21 April 2023 15:56">Friday 21 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
