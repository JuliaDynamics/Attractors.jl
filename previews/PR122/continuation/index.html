<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Attractor &amp; Basins Continuation · Attractors.jl</title><meta name="title" content="Attractor &amp; Basins Continuation · Attractors.jl"/><meta property="og:title" content="Attractor &amp; Basins Continuation · Attractors.jl"/><meta property="twitter:title" content="Attractor &amp; Basins Continuation · Attractors.jl"/><meta name="description" content="Documentation for Attractors.jl."/><meta property="og:description" content="Documentation for Attractors.jl."/><meta property="twitter:description" content="Documentation for Attractors.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Attractors.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Attractors.jl</a></li><li><a class="tocitem" href="../dynsysref/"><code>DynamicalSystem</code> reference</a></li><li><a class="tocitem" href="../attractors/">Finding Attractors</a></li><li><a class="tocitem" href="../basins/">Basins of Attraction</a></li><li class="is-active"><a class="tocitem" href>Attractor &amp; Basins Continuation</a><ul class="internal"><li><a class="tocitem" href="#A-new-kind-of-continuation"><span>A new kind of continuation</span></a></li><li><a class="tocitem" href="#Continuation-API"><span>Continuation API</span></a></li><li><a class="tocitem" href="#Recurrences-continuation-(best)"><span>Recurrences continuation (best)</span></a></li><li><a class="tocitem" href="#Matching-attractors"><span>Matching attractors</span></a></li><li><a class="tocitem" href="#Aggregating-attractors-and-fractions"><span>Aggregating attractors and fractions</span></a></li><li><a class="tocitem" href="#Grouping-continuation"><span>Grouping continuation</span></a></li></ul></li><li><a class="tocitem" href="../visualization/">Visualization utilities</a></li><li><a class="tocitem" href="../examples/">Examples for Attractors.jl</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Attractor &amp; Basins Continuation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Attractor &amp; Basins Continuation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Attractors.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Attractors.jl/blob/main/docs/src/continuation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Attractor-and-Basins-Continuation"><a class="docs-heading-anchor" href="#Attractor-and-Basins-Continuation">Attractor &amp; Basins Continuation</a><a id="Attractor-and-Basins-Continuation-1"></a><a class="docs-heading-anchor-permalink" href="#Attractor-and-Basins-Continuation" title="Permalink"></a></h1><h2 id="A-new-kind-of-continuation"><a class="docs-heading-anchor" href="#A-new-kind-of-continuation">A new kind of continuation</a><a id="A-new-kind-of-continuation-1"></a><a class="docs-heading-anchor-permalink" href="#A-new-kind-of-continuation" title="Permalink"></a></h2><p>If you have heard before the word &quot;continuation&quot;, then you are likely aware of the <strong>traditional continuation-based bifurcation analysis (CBA)</strong> offered by many software, such as AUTO, MatCont, and in Julia <a href="https://github.com/bifurcationkit/BifurcationKit.jl">BifurcationKit.jl</a>. Here we offer a completely different kind of continuation called <strong>attractors &amp; basins continuation</strong>.</p><p>A direct comparison of the two approaches is not truly possible, because they do different things. The traditional linearized continuation analysis continues the curves of individual fixed points across the joint state-parameter space. The attractor and basins continuation first finds all attractors at all parameter values and then <em>matches</em> appropriately similar attractors across different parameters, giving the illusion of continuing them individually. Additionally, the curves of stable fixed points in the joint parameter space is only a small by-product of the attractor basins continuation, and the main information is the basin fractions and how these change in the parameter space.</p><p>A more detailed comparison between these two fundamentally different approaches in is given in high detail in our <a href="https://github.com/JuliaDynamics/Attractors.jl/blob/main/CITATION.bib">paper</a>.</p><h2 id="Continuation-API"><a class="docs-heading-anchor" href="#Continuation-API">Continuation API</a><a id="Continuation-API-1"></a><a class="docs-heading-anchor-permalink" href="#Continuation-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.continuation" href="#Attractors.continuation"><code>Attractors.continuation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">continuation(abc::AttractorsBasinsContinuation, prange, pidx, ics; kwargs...)</code></pre><p>Find and continue attractors (or feature-based representations of attractors) and the fractions of their basins of attraction across a parameter range. <code>continuation</code> is the central function of the framework for global stability analysis illustrated in (<a href="../references/#Datseris2023">Datseris <em>et al.</em>, 2023</a>).</p><p>The continuation type <code>abc</code> is a subtype of <code>AttractorsBasinsContinuation</code> and contains an <a href="../attractors/#Attractors.AttractorMapper"><code>AttractorMapper</code></a>. The mapper contains information on how to find the attractors and basins of a dynamical system. Additional arguments and keyword arguments given when creating <code>abc</code> further tune the continuation and how attractors are matched across different parameter values.</p><p>The basin fractions and the attractors (or some representation of them) are continued across the parameter range <code>prange</code>, for the parameter of the system with index <code>pidx</code> (any index valid in <a href="../dynsysref/#DynamicalSystemsBase.set_parameter!"><code>set_parameter!</code></a> can be used).</p><p><code>ics</code> is a 0-argument function generating initial conditions for the dynamical system (as in <a href="../basins/#Attractors.basins_fractions"><code>basins_fractions</code></a>).</p><p>Possible subtypes of <code>AttractorsBasinsContinuation</code> are:</p><ul><li><a href="#Attractors.RecurrencesFindAndMatch"><code>RecurrencesFindAndMatch</code></a></li><li><a href="#Attractors.FeaturizeGroupAcrossParameter"><code>FeaturizeGroupAcrossParameter</code></a></li></ul><p><strong>Return</strong></p><ol><li><code>fractions_curves::Vector{Dict{Int, Float64}}</code>. The fractions of basins of attraction. <code>fractions_curves[i]</code> is a dictionary mapping attractor IDs to their basin fraction at the <code>i</code>-th parameter.</li><li><code>attractors_info::Vector{Dict{Int, &lt;:Any}}</code>. Information about the attractors. <code>attractors_info[i]</code> is a dictionary mapping attractor ID to information about the attractor at the <code>i</code>-th parameter. The type of information stored depends on the chosen continuation type.</li></ol><p><strong>Keyword arguments</strong></p><ul><li><code>show_progress = true</code>: display a progress bar of the computation.</li><li><code>samples_per_parameter = 100</code>: amount of initial conditions sampled at each parameter from <code>ics</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/a63e525977354fd38ba950fc3f2291e0bd206f30/src/continuation/basins_fractions_continuation_api.jl#L9-L50">source</a></section></article><h2 id="Recurrences-continuation-(best)"><a class="docs-heading-anchor" href="#Recurrences-continuation-(best)">Recurrences continuation (best)</a><a id="Recurrences-continuation-(best)-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrences-continuation-(best)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.RecurrencesFindAndMatch" href="#Attractors.RecurrencesFindAndMatch"><code>Attractors.RecurrencesFindAndMatch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RecurrencesFindAndMatch &lt;: AttractorsBasinsContinuation
RecurrencesFindAndMatch(mapper::AttractorsViaRecurrences; kwargs...)</code></pre><p>A method for <a href="#Attractors.continuation"><code>continuation</code></a> as in (<a href="../references/#Datseris2023">Datseris <em>et al.</em>, 2023</a>) that is based on the recurrences algorithm for finding attractors (<a href="../attractors/#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a>) and the &quot;matching attractors&quot; functionality offered by <a href="#Attractors.match_continuation!"><code>match_continuation!</code></a>.</p><p>You can use <code>RAFM</code> as an alias.</p><p><strong>Keyword arguments</strong></p><ul><li><code>distance = Centroid(), threshold = Inf, use_vanished = !isinf(threshold)</code>: propagated to <a href="#Attractors.match_continuation!"><code>match_continuation!</code></a>.</li><li><code>info_extraction = identity</code>: A function that takes as an input an attractor (<code>StateSpaceSet</code>) and outputs whatever information should be stored. It is used to return the <code>attractors_info</code> in <a href="#Attractors.continuation"><code>continuation</code></a>. Note that the same attractors that are stored in <code>attractors_info</code> are also used to perform the matching in <a href="#Attractors.match_continuation!"><code>match_continuation!</code></a>, hence this keyword should be altered with care.</li><li><code>seeds_from_attractor</code>: A function that takes as an input an attractor and returns an iterator of initial conditions to be seeded from the attractor for the next parameter slice. By default, we sample only the first stored point on the attractor.</li></ul><p><strong>Description</strong></p><p>At the first parameter slice of the continuation process, attractors and their fractions are found as described in the <a href="../attractors/#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a> mapper using recurrences in state space. At each subsequent parameter slice, new attractors are found by seeding initial conditions from the previously found attractors and then running these initial conditions through the recurrences algorithm of the <code>mapper</code>. Seeding initial conditions close to previous attractors accelerates the main bottleneck of <a href="../attractors/#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a>, which is finding the attractors.</p><p>After the special initial conditions are mapped to attractors, attractor basin fractions are computed by sampling random initial conditions using the provided <code>sampler</code> in <a href="#Attractors.continuation"><code>continuation</code></a>) and mapping them to attractors using the <a href="../attractors/#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a> mapper. I.e., exactly as in <a href="../basins/#Attractors.basins_fractions"><code>basins_fractions</code></a>. Naturally, during this step new attractors may be found, besides those found using the &quot;seeding from previous attractors&quot;. Once the basins fractions are computed, the parameter is incremented again and we perform the steps as before.</p><p>This process continues for all parameter values. After all parameters are exhausted, the found attractors (and their fractions) are &quot;matched&quot; to the previous ones. I.e., their <em>IDs are changed</em>, so that attractors that are &quot;similar&quot; to those at a previous parameter get assigned the same ID. Matching is done by the <a href="#Attractors.match_continuation!"><code>match_continuation!</code></a> function and is an <em>orthogonal</em> step. This means, that if you don&#39;t like the initial outcome of the matching process, you may call <a href="#Attractors.match_continuation!"><code>match_continuation!</code></a> again on the outcome with different matching-related keywords. You do not need to compute attractors and basins again!</p><p>Matching is a very sophisticated process that can be understood in detail by reading the docstrings of <a href="#Attractors.match_statespacesets!"><code>match_statespacesets!</code></a> first and then <a href="#Attractors.match_continuation!"><code>match_continuation!</code></a>. Here is a short summary: attractors from previous and current parameter are matched based on their &quot;distance&quot;. By default this is distance in state space, but any measure of &quot;distance&quot; may be used, such as the distance between Lyapunov spectra. Matching prioritizes new-&gt;old pairs with smallest distance: once these are matched the next available new-&gt;old pair with smallest distance is matched, until all new/old attractors have been matched. The <code>threshold</code> keyword establishes that attractors with distance &gt; <code>threshold</code> do not get matched. Additionally, use <code>use_vanished = true</code> if you want to include as matching candidates attractors that have vanished during the continuation process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/a63e525977354fd38ba950fc3f2291e0bd206f30/src/continuation/continuation_recurrences.jl#L5-L69">source</a></section></article><h2 id="Matching-attractors"><a class="docs-heading-anchor" href="#Matching-attractors">Matching attractors</a><a id="Matching-attractors-1"></a><a class="docs-heading-anchor-permalink" href="#Matching-attractors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.match_statespacesets!" href="#Attractors.match_statespacesets!"><code>Attractors.match_statespacesets!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">match_statespacesets!(a₊::AbstractDict, a₋; distance = Centroid(), threshold = Inf)</code></pre><p>Given dictionaries <code>a₊, a₋</code> mapping IDs to <code>StateSpaceSet</code> instances, match the IDs in dictionary <code>a₊</code> so that its sets that are the closest to those in dictionary <code>a₋</code> get assigned the same key as in <code>a₋</code>. Typically the +,- mean after and before some change of parameter of a system.</p><p>Return the replacement map, a dictionary mapping old keys of <code>a₊</code> to the new ones that they were mapped to. You can obtain this map, without modifying the dictionaries, by calling the <a href="#Attractors.replacement_map"><code>replacement_map</code></a> function directly.</p><p><strong>Keyword arguments</strong></p><ul><li><code>distance = Centroid()</code>: given to <a href="#StateSpaceSets.setsofsets_distances"><code>setsofsets_distances</code></a>.</li><li><code>threshold = Inf</code>: attractors with distance larger than the <code>threshold</code> are guaranteed to not be mapped to each other.</li></ul><p><strong>Description</strong></p><p>The distance between all possible pairs of sets between the &quot;old&quot; and &quot;new&quot; containers is computed using <a href="#StateSpaceSets.setsofsets_distances"><code>setsofsets_distances</code></a> with the keyword <code>distance</code>. <code>distance</code> can be whatever that function accepts, i.e., one of <code>Centroid, Hausdorff, StrictlyMinimumDistance</code> or any arbitrary user- provided function that given two sets it returns a positive number (their distance). State space sets are then matched according to this distance. First, all possible pairs (old, new, distance) are sorted according to their distance. The pair with smallest distance is matched. Sets in matched pairs are removed from the matching pool to ensure a unique mapping. Then, the next pair with least remaining distance is matched, and the process repeats until all pairs are exhausted.</p><p>Additionally, you can provide a <code>threshold</code> value. If the distance between two attractors is larger than this <code>threshold</code>, then it is guaranteed that the attractors will get assigned different key in the dictionary <code>a₊</code> (which is the next available integer).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/a63e525977354fd38ba950fc3f2291e0bd206f30/src/continuation/match_attractor_ids.jl#L7-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceSets.Centroid" href="#StateSpaceSets.Centroid"><code>StateSpaceSets.Centroid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Centroid(metric = Euclidean())</code></pre><p>A distance that can be used in <a href="#StateSpaceSets.set_distance"><code>set_distance</code></a>. The <code>Centroid</code> method returns the distance (according to <code>metric</code>) between the <a href="https://en.wikipedia.org/wiki/Centroid">centroids</a> (a.k.a. centers of mass) of the sets.</p><p><code>metric</code> can be any function that takes in two static vectors are returns a positive definite number to use as a distance (and typically is a <code>Metric</code> from Distances.jl).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/v1.4.5/src/set_distance.jl#L21-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceSets.Hausdorff" href="#StateSpaceSets.Hausdorff"><code>StateSpaceSets.Hausdorff</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Hausdorff(metric = Euclidean())</code></pre><p>A distance that can be used in <a href="#StateSpaceSets.set_distance"><code>set_distance</code></a>. The <a href="https://en.wikipedia.org/wiki/Hausdorff_distance">Hausdorff distance</a> is the greatest of all the distances from a point in one set to the closest point in the other set. The distance is calculated with the metric given to <code>Hausdorff</code> which defaults to Euclidean.</p><p><code>Hausdorff</code> is 2x slower than <a href="#StateSpaceSets.StrictlyMinimumDistance"><code>StrictlyMinimumDistance</code></a>, however it is a proper metric in the space of sets of state space sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/v1.4.5/src/set_distance.jl#L42-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceSets.StrictlyMinimumDistance" href="#StateSpaceSets.StrictlyMinimumDistance"><code>StateSpaceSets.StrictlyMinimumDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StrictlyMinimumDistance([brute = false,] [metric = Euclidean(),])</code></pre><p>A distance that can be used in <a href="#StateSpaceSets.set_distance"><code>set_distance</code></a>. The <code>StrictlyMinimumDistance</code> returns the minimum distance of all the distances from a point in one set to the closest point in the other set. The distance is calculated with the given metric.</p><p>The <code>brute::Bool</code> argument switches the computation between a KDTree-based version, or brute force (i.e., calculation of all distances and picking the smallest one). Brute force performs better for datasets that are either large dimensional or have a small amount of points. Deciding a cutting point is not trivial, and is recommended to simply benchmark the <a href="#StateSpaceSets.set_distance"><code>set_distance</code></a> function to make a decision.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/v1.4.5/src/set_distance.jl#L68-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.replacement_map" href="#Attractors.replacement_map"><code>Attractors.replacement_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">replacement_map(a₊, a₋; distance = Centroid(), threshold = Inf) → rmap</code></pre><p>Return a dictionary mapping keys in <code>a₊</code> to new keys in <code>a₋</code>, as explained in <a href="#Attractors.match_statespacesets!"><code>match_statespacesets!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/a63e525977354fd38ba950fc3f2291e0bd206f30/src/continuation/match_attractor_ids.jl#L51-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceSets.set_distance" href="#StateSpaceSets.set_distance"><code>StateSpaceSets.set_distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_distance(ssset1, ssset2 [, distance])</code></pre><p>Calculate a distance between two <code>StateSpaceSet</code>s, i.e., a distance defined between sets of points, as dictated by <code>distance</code>.</p><p>Possible <code>distance</code> types are:</p><ul><li><a href="#StateSpaceSets.Centroid"><code>Centroid</code></a>, which is the default, and 100s of times faster than the rest</li><li><a href="#StateSpaceSets.Hausdorff"><code>Hausdorff</code></a></li><li><a href="#StateSpaceSets.StrictlyMinimumDistance"><code>StrictlyMinimumDistance</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/v1.4.5/src/set_distance.jl#L7-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceSets.setsofsets_distances" href="#StateSpaceSets.setsofsets_distances"><code>StateSpaceSets.setsofsets_distances</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setsofsets_distances(a₊, a₋ [, distance]) → distances</code></pre><p>Calculate distances between sets of <code>StateSpaceSet</code>s. Here  <code>a₊, a₋</code> are containers of <code>StateSpaceSet</code>s, and the returned distances are dictionaries of distances. Specifically, <code>distances[i][j]</code> is the distance of the set in the <code>i</code> key of <code>a₊</code> to the <code>j</code> key of <code>a₋</code>. Notice that distances from <code>a₋</code> to <code>a₊</code> are not computed at all (assumming symmetry in the distance function).</p><p>The <code>distance</code> can be as in <a href="#StateSpaceSets.set_distance"><code>set_distance</code></a>, or it can be an arbitrary function that takes as input two state space sets and returns any positive-definite number as their &quot;distance&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/v1.4.5/src/set_distance.jl#L132-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.match_continuation!" href="#Attractors.match_continuation!"><code>Attractors.match_continuation!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">match_continuation!(fractions_curves::Vector{&lt;:Dict}, attractors_info::Vector{&lt;:Dict}; kwargs...)</code></pre><p>Loop over all entries in the given arguments (which are typically the direct outputs of <a href="#Attractors.continuation"><code>continuation</code></a> with <a href="#Attractors.RecurrencesFindAndMatch"><code>RecurrencesFindAndMatch</code></a>), and match the attractor IDs in both the attractors container and the basins fractions container. This means that we loop over each entry of the vectors (skipping the first), and in each entry we attempt to match the current dictionary keys to the keys of the previous dictionary using <a href="#Attractors.match_statespacesets!"><code>match_statespacesets!</code></a>.</p><p>The keywords <code>distance, threshold</code> are propagated to <a href="#Attractors.match_statespacesets!"><code>match_statespacesets!</code></a>. However, there is a unique keyword for <code>match_continuation!</code>: <code>use_vanished::Bool</code>. If <code>true</code>, then attractors that existed before but have vanished are kept in &quot;memory&quot; when it comes to matching: the new attractors are compared to the latest instance of all attractors that have ever existed, and get matched to their closest ones as per <a href="#Attractors.match_statespacesets!"><code>match_statespacesets!</code></a>. If <code>false</code>, vanished attractors are ignored. Note that in this case new attractors that cannot be matched to any previous attractors will get an appropriately incremented ID. E.g., if we started with three attractors, and attractor 3 vanished, and at some later parameter value we again have three attractors, the new third attractor will <em>not</em> have ID 3, but 4 (i.e., the next available ID).</p><p>By default <code>use_vanished = !isinf(threshold)</code> and since the default value for <code>threshold</code> is <code>Inf</code>, <code>use_vanished</code> is <code>false</code>.</p><p>The last keyword is <code>retract_keys = true</code> which will &quot;retract&quot; keys (i.e., make the integers smaller integers) so that all unique IDs are the 1-incremented positive integers. E.g., if the IDs where 1, 6, 8, they will become 1, 2, 3. The special id -1 is unaffected by this.</p><pre><code class="nohighlight hljs">match_continuation!(attractors_info::Vector{&lt;:Dict}; kwargs...)</code></pre><p>This is a convenience method that only uses and modifies the state space set dictionary container without the need for a basins fractions container.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/a63e525977354fd38ba950fc3f2291e0bd206f30/src/continuation/match_attractor_ids.jl#L158-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.match_basins_ids!" href="#Attractors.match_basins_ids!"><code>Attractors.match_basins_ids!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">match_basins_ids!(b₊::AbstractArray, b₋; threshold = Inf)</code></pre><p>Similar to <a href="#Attractors.match_statespacesets!"><code>match_statespacesets!</code></a> but operate on basin arrays instead (the arrays typically returned by <a href="../basins/#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>).</p><p>This method matches IDs of attractors whose basins of attraction before and after <code>b₋,b₊</code> have the most overlap (in pixels). This overlap is normalized in 0-1 (with 1 meaning 100% overlap of pixels). The <code>threshold</code> in this case is compared to the inverse of the overlap (so, for <code>threshold = 2</code> attractors that have less than 50% overlap get different IDs guaranteed).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/a63e525977354fd38ba950fc3f2291e0bd206f30/src/continuation/match_attractor_ids.jl#L117-L128">source</a></section></article><h2 id="Aggregating-attractors-and-fractions"><a class="docs-heading-anchor" href="#Aggregating-attractors-and-fractions">Aggregating attractors and fractions</a><a id="Aggregating-attractors-and-fractions-1"></a><a class="docs-heading-anchor-permalink" href="#Aggregating-attractors-and-fractions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.aggregate_attractor_fractions" href="#Attractors.aggregate_attractor_fractions"><code>Attractors.aggregate_attractor_fractions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">aggregate_attractor_fractions(
    fractions_curves, attractors_info, featurizer, group_config [, info_extraction]
)</code></pre><p>Aggregate the already-estimated curves of fractions of basins of attraction of similar attractors using the same pipeline used by <a href="../attractors/#Attractors.GroupingConfig"><code>GroupingConfig</code></a>. The most typical application of this function is to transform the output of <a href="#Attractors.RecurrencesFindAndMatch"><code>RecurrencesFindAndMatch</code></a> so that similar attractors, even across parameter space, are grouped into one &quot;attractor&quot;. Thus, the fractions of their basins are aggregated.</p><p>You could also use this function to aggregate attractors and their fractions even in a single parameter configuration, i.e., using the output of <a href="../basins/#Attractors.basins_fractions"><code>basins_fractions</code></a>.</p><p>This function is useful in cases where you want the accuracy and performance of <a href="../attractors/#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a>, but you also want the convenience of &quot;grouping&quot; similar attractrors like in <a href="../attractors/#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a> for presentation or analysis purposes. For example, a high dimensional model of competition dynamics across multispecies may have extreme multistability. After finding this multistability however, one may care about aggregating all attractors into two groups: where a given species is extinct or not. This is the example highlighted in our documentation, in <a href="../examples/#Extinction-of-a-species-in-a-multistable-competition-model">Extinction of a species in a multistable competition model</a>.</p><p><strong>Input</strong></p><ol><li><code>fractions_curves</code>: a vector of dictionaries mapping labels to basin fractions.</li><li><code>attractors_info</code>: a vector of dictionaries mapping labels to attractors. 1st and 2nd argument are exactly like the return values of <a href="#Attractors.continuation"><code>continuation</code></a> with <a href="#Attractors.RecurrencesFindAndMatch"><code>RecurrencesFindAndMatch</code></a> (or, they can be the return of <a href="../basins/#Attractors.basins_fractions"><code>basins_fractions</code></a>).</li><li><code>featurizer</code>: a 1-argument function to map an attractor into an appropriate feature to be grouped later. Features expected by <a href="../attractors/#Attractors.GroupingConfig"><code>GroupingConfig</code></a> are <code>SVector</code>.</li><li><code>group_config</code>: a subtype of <a href="../attractors/#Attractors.GroupingConfig"><code>GroupingConfig</code></a>.</li><li><code>info_extraction</code>: a function accepting a vector of features and returning a description of the features. I.e., exactly as in <a href="#Attractors.FeaturizeGroupAcrossParameter"><code>FeaturizeGroupAcrossParameter</code></a>. The 5th argument is optional and defaults to the centroid of the features.</li></ol><p><strong>Return</strong></p><ol><li><code>aggregated_fractions</code>: same as <code>fractions_curves</code> but now contains the fractions of the aggregated attractors.</li><li><code>aggregated_info</code>: dictionary mapping the new labels of <code>aggregated_fractions</code> to the extracted information using <code>info_extraction</code>.</li></ol><p><strong>Clustering attractors directly</strong></p><p><em>(this is rather advanced)</em></p><p>You may also use the DBSCAN clustering approach here to group attractors based on their state space distance (the <a href="#StateSpaceSets.set_distance"><code>set_distance</code></a>) by making a distance matrix as expected by the DBSCAN implementation. For this, use <code>identity</code> as <code>featurizer</code>, and choose <a href="../attractors/#Attractors.GroupViaClustering"><code>GroupViaClustering</code></a> as the <code>group_config</code> with <code>clust_distance_metric = set_distance</code> and provide a numerical value for <code>optimal_radius_method</code> when initializing the <a href="../attractors/#Attractors.GroupViaClustering"><code>GroupViaClustering</code></a>, and also, for the <code>info_extraction</code> argument, you now need to provide a function that expects a <em>vector of <code>StateSpaceSet</code>s</em> and outputs a descriptor. E.g., <code>info_extraction = vector -&gt; mean(mean(x) for x in vector)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/a63e525977354fd38ba950fc3f2291e0bd206f30/src/continuation/aggregate_attractor_fractions.jl#L3-L60">source</a></section></article><h2 id="Grouping-continuation"><a class="docs-heading-anchor" href="#Grouping-continuation">Grouping continuation</a><a id="Grouping-continuation-1"></a><a class="docs-heading-anchor-permalink" href="#Grouping-continuation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Attractors.FeaturizeGroupAcrossParameter" href="#Attractors.FeaturizeGroupAcrossParameter"><code>Attractors.FeaturizeGroupAcrossParameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FeaturizeGroupAcrossParameter &lt;: AttractorsBasinsContinuation
FeaturizeGroupAcrossParameter(mapper::AttractorsViaFeaturizing; kwargs...)</code></pre><p>A method for <a href="#Attractors.continuation"><code>continuation</code></a>. It uses the featurizing approach discussed in <a href="../attractors/#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a> and hence requires an instance of that mapper as an input. When used in <a href="#Attractors.continuation"><code>continuation</code></a>, features are extracted and then grouped across a parameter range. Said differently, all features of all initial conditions across all parameter values are put into the same &quot;pool&quot; and then grouped as dictated by the <code>group_config</code> of the mapper. After the grouping is finished the feature label fractions are distributed to each parameter value they came from.</p><p><strong>Keyword arguments</strong></p><ul><li><code>info_extraction::Function</code> a function that takes as an input a vector of feature-vectors (corresponding to a cluster) and returns a description of the cluster. By default, the centroid of the cluster is used.</li><li><code>par_weight = 0</code>: See below the section on MCBB.</li></ul><p><strong>MCBB special version</strong></p><p>If the chosen grouping method is <a href="../attractors/#Attractors.GroupViaClustering"><code>GroupViaClustering</code></a>, the additional keyword <code>par_weight::Real</code> can be used. If it is ≠ 0, the distance matrix between features obtains an extra weight that is proportional to the distance <code>par_weight*|p[i] - p[j]|</code> between the parameters used when extracting features. The range of parameters is normalized to 0-1 such that the largest distance in the parameter space is 1. The normalization is done because the feature space is also (by default) normalized to 0-1.</p><p>This version of the algorithm is the original &quot;MCBB&quot; continuation method described in (<a href="../references/#Gelbrecht2020">Gelbrecht <em>et al.</em>, 2020</a>), besides the improvements of clustering accuracy and performance done by the developer team of Attractors.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/a63e525977354fd38ba950fc3f2291e0bd206f30/src/continuation/continuation_grouping.jl#L11-L44">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../basins/">« Basins of Attraction</a><a class="docs-footer-nextpage" href="../visualization/">Visualization utilities »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Wednesday 13 March 2024 17:29">Wednesday 13 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
