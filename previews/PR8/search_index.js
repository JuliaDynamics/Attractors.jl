var documenterSearchIndex = {"docs":
[{"location":"basins/#Basins-of-Attraction","page":"Basins of Attraction","title":"Basins of Attraction","text":"","category":"section"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"This page provides several functions related to the basins of attraction and their boundaries. It requires you to have first understood the Finding Attractors page.","category":"page"},{"location":"basins/#Basins-of-attraction","page":"Basins of Attraction","title":"Basins of attraction","text":"","category":"section"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"Calculating basins of attraction, or their state space fractions, can be done with the functions:","category":"page"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"basins_fractions\nbasins_of_attraction.","category":"page"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"See also the related functions statespace_sampler and match_attractors_ids!.","category":"page"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"basins_fractions\nbasins_of_attraction\nstatespace_sampler","category":"page"},{"location":"basins/#Attractors.basins_fractions","page":"Basins of Attraction","title":"Attractors.basins_fractions","text":"basins_fractions(mapper::AttractorMapper, ics::Union{Dataset, Function}; kwargs...)\n\nApproximate the state space fractions fs of the basins of attraction of a dynamical stystem by mapping initial conditions to attractors using mapper (which contains a reference to a GeneralizedDynamicalSystem). The fractions are simply the ratios of how many initial conditions ended up at each attractor.\n\nInitial conditions to use are defined by ics. It can be:\n\na Dataset of initial conditions, in which case all are used.\na 0-argument function ics() that spits out random initial conditions. Then N random initial conditions are chosen. See statespace_sampler to generate such functions.\n\nThe returned arguments are fs. If ics is a Dataset then the labels of each initial condition and roughly approximated attractors are also returned: fs, labels, attractors.\n\nThe output fs is a dictionary whose keys are the labels given to each attractor (always integers enumerating the different attractors), and the values are their respective fractions. The label -1 is given to any initial condition where mapper could not match to an attractor (this depends on the mapper type). attractors has the same structure, mapping labels to Datasets.\n\nSee AttractorMapper for all possible mapper types.\n\nKeyword arguments\n\nN = 1000: Number of random initial conditions to generate in case ics is a function.\nshow_progress = true: Display a progress bar of the process.\n\n\n\n\n\nbasins_fractions(basins::AbstractArray) → fs::Dict\n\nCalculate the state space fraction of the basins of attraction encoded in basins. The elements of basins are integers, enumerating the attractor that the entry of basins converges to (i.e., like the output of basins_of_attraction). Return a dictionary that maps attractor IDs to their relative fractions.\n\nIn[Menck2013] the authors use these fractions to quantify the stability of a basin of attraction, and specifically how it changes when a parameter is changed. For this, see basins_fractions_continuation.\n\n[Menck2013]: Menck, Heitzig, Marwan & Kurths. How basin stability complements the linear stability paradigm. Nature Physics, 9(2), 89–92\n\n\n\n\n\n","category":"function"},{"location":"basins/#Attractors.basins_of_attraction","page":"Basins of Attraction","title":"Attractors.basins_of_attraction","text":"basins_of_attraction(mapper::AttractorMapper, grid::Tuple) → basins, attractors\n\nCompute the full basins of attraction as identified by the given mapper, which includes a reference to a GeneralizedDynamicalSystem and return them along with (perhaps approximated) found attractors.\n\ngrid is a tuple of ranges defining the grid of initial conditions that partition the state space into boxes with size the step size of each range. For example, grid = (xg, yg) where xg = yg = range(-5, 5; length = 100). The grid has to be the same dimensionality as the state space expected by the integrator/system used in mapper. E.g., a projected_integrator could be used for lower dimensional projections, etc. A special case here is a poincaremap with plane being Tuple{Int, <: Real}. In this special scenario the grid can be one dimension smaller than the state space, in which case the partitioning happens directly on the hyperplane the Poincaré map operates on.\n\nbasins_of_attraction function is a convenience 5-lines-of-code wrapper which uses the labels returned by basins_fractions and simply assings them to a full array corresponding to the state space partitioning indicated by grid.\n\n\n\n\n\nbasins_of_attraction(mapper::AttractorsViaRecurrences; show_progress = true)\n\nThis is a special method of basins_of_attraction that using recurrences does exactly what is described in the paper by Datseris & Wagemakers[Datseris2022]. By enforcing that the internal grid of mapper is the same as the grid of initial conditions to map to attractors, the method can further utilize found exit and attraction basins, making the computation faster as the grid is processed more and more.\n\n[Datseris2022]: G. Datseris and A. Wagemakers, Effortless estimation of basins of attraction, Chaos 32, 023104 (2022)\n\n\n\n\n\n","category":"function"},{"location":"basins/#DelayEmbeddings.statespace_sampler","page":"Basins of Attraction","title":"DelayEmbeddings.statespace_sampler","text":"statespace_sampler(rng = Random.GLOBAL_RNG; kwargs...) → sampler, isinside\n\nConvenience function that creates two functions. sampler is a 0-argument function that generates random points inside a state space region defined by the keywords. isinside is a 1-argument function that decides returns true if the given state space point is inside that region.\n\nThe regions can be:\n\nRectangular box, with edges min_bounds and max_bounds. The sampling of the points inside the box is decided by the keyword method which can be either \"uniform\" or \"multgauss\".\nSphere, of spheredims dimensions, radius radius and centered on center.\n\n\n\n\n\n","category":"function"},{"location":"basins/#Final-state-sensitivity-/-fractal-boundaries","page":"Basins of Attraction","title":"Final state sensitivity / fractal boundaries","text":"","category":"section"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"Several functions are provided related with analyzing the fractality of the boundaries of the basins of attraction:","category":"page"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"basins_fractal_dimension\nbasin_entropy\nbasins_fractal_test\nuncertainty_exponent","category":"page"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"basins_fractal_dimension\nbasin_entropy\nbasins_fractal_test\nuncertainty_exponent","category":"page"},{"location":"basins/#Attractors.basins_fractal_dimension","page":"Basins of Attraction","title":"Attractors.basins_fractal_dimension","text":"basins_fractal_dimension(basins; kwargs...) -> V_ε, N_ε ,d\n\nEstimate the Fractal Dimension d of the boundary between basins of attraction using the box-counting algorithm.\n\nThe output N_ε is a vector with the number of the balls of radius ε (in pixels) that contain at least two initial conditions that lead to different attractors. V_ε is a vector with the corresponding size of the balls. The ouput d is the estimation of the box-counting dimension of the boundary by fitting a line in the log.(N_ε) vs log.(1/V_ε) curve. However it is recommended to analyze the curve directly for more accuracy.\n\nKeyword arguments\n\nrange_ε = 2:maximum(size(basins))÷20 is the range of sizes of the ball to test (in pixels).\n\nDescription\n\nIt is the implementation of the popular algorithm of the estimation of the box-counting dimension. The algorithm search for a covering the boundary with N_ε boxes of size ε in pixels.\n\n\n\n\n\n","category":"function"},{"location":"basins/#Attractors.basin_entropy","page":"Basins of Attraction","title":"Attractors.basin_entropy","text":"basin_entropy(basins, ε = 20) -> Sb, Sbb\n\nThis algorithm computes the basin entropy Sb of the basins of attraction. First, the input basins is divided regularly into n-dimensional boxes of side ε (along all dimensions). Then Sb is simply the average of the Gibbs entropy computed over these boxes. The function returns the basin entropy Sb as well as the boundary basin entropy Sbb. The later is the average of the entropy only for boxes that contains at least two different basins, that is, for the boxes on the boundary.\n\nThe basin entropy is a measure of the uncertainty on the initial conditions of the basins. It is maximum at the value log(n_att) being n_att the number of attractors. In this case the boundary is intermingled: for a given initial condition we can find another initial condition that lead to another basin arbitriraly close. It provides also a simple criterion for fractality: if the boundary basin entropy Sbb is above log(2) then we have a fractal boundary. It doesn't mean that basins with values below cannot have a fractal boundary, for a more precise test see basins_fractal_test. An important feature of the basin entropy is that it allows comparisons between different basins using the same box size ε.\n\n[Daza2016]: A. Daza, A. Wagemakers, B. Georgeot, D. Guéry-Odelin and M. A. F. Sanjuán, Basin entropy: a new tool to analyze uncertainty in dynamical systems, Sci. Rep., 6, 31416, 2016.\n\n\n\n\n\n","category":"function"},{"location":"basins/#Attractors.basins_fractal_test","page":"Basins of Attraction","title":"Attractors.basins_fractal_test","text":"basins_fractal_test(basins; ε = 20, Ntotal = 1000) -> test_res, Sbb\n\nThis is an automated test to decide if the boundary of the basins has fractal structures. The bottom line is to look at the basins with a magnifier of size ε at random in basins. If what we see in the magnifier looks like a smooth boundary (in average) we decide that the boundary is smooth. If it is not smooth we can say that at the scale ε we have structures, i.e., it is fractal.\n\nIn practice the algorithm computes the boundary basin entropy Sbb basin_entropy for Ntotal random balls of radius ε. If the computed value is equal to theoretical value of a smooth boundary (taking into account statistical errors and biases) then we decide that we have a smooth boundary. Notice that the response test_res may depend on the chosen ball radius ε. For larger size, we may observe structures for smooth boundary and we obtain a different answer.\n\nThe output test_res is a symbol describing the nature of the basin and the output Sbb is the estimated value of the boundary basin entropy with the sampling method.\n\n[Puy2021] Andreu Puy, Alvar Daza, Alexandre Wagemakers, Miguel A. F. Sanjuán. A test for fractal boundaries based on the basin entropy. Commun Nonlinear Sci Numer Simulat, 95, 105588, 2021.\n\nKeyword arguments\n\nε = 20: size of the ball for the test of basin. The result of the test may change with the size.\nNtotal = 1000: number of balls to test in the boundary for the computation of Sbb\n\n\n\n\n\n","category":"function"},{"location":"basins/#Attractors.uncertainty_exponent","page":"Basins of Attraction","title":"Attractors.uncertainty_exponent","text":"uncertainty_exponent(basins; kwargs...) -> ε, N_ε ,α\n\nEstimate the uncertainty exponent[Grebogi1983] of the basins of attraction. This exponent is related to the final state sensitivity of the trajectories in the phase space. An exponent close to 1 means basins with smooth boundaries whereas an exponent close to 0 represent completely fractalized basins, also called riddled basins.\n\nThe output N_ε is a vector with the number of the balls of radius ε (in pixels) that contain at least two initial conditions that lead to different attractors. The ouput α is the estimation of the uncertainty exponent using the box-counting dimension of the boundary by fitting a line in the log.(N_ε) vs log.(1/ε) curve. However it is recommended to analyze the curve directly for more accuracy.\n\nKeyword arguments\n\nrange_ε = 2:maximum(size(basins))÷20 is the range of sizes of the ball to test (in pixels).\n\nDescription\n\nA phase space with a fractal boundary may cause a uncertainty on the final state of the dynamical system for a given initial condition. A measure of this final state sensitivity is the uncertainty exponent. The algorithm probes the basin of attraction with balls of size ε at random. If there are a least two initial conditions that lead to different attractors, a ball is tagged \"uncertain\". f_ε is the fraction of \"uncertain balls\" to the total number of tries in the basin. In analogy to the fractal dimension, there is a scaling law between, f_ε ~ ε^α. The number that characterizes this scaling is called the uncertainty exponent α.\n\nNotice that the uncertainty exponent and the box counting dimension of the boundary are related. We have Δ₀ = D - α where Δ₀ is the box counting dimension computed with basins_fractal_dimension and D is the dimension of the phase space. The algorithm first estimates the box counting dimension of the boundary and returns the uncertainty exponent.\n\n[Grebogi1983]: C. Grebogi, S. W. McDonald, E. Ott and J. A. Yorke, Final state sensitivity:\n\nAn obstruction to predictability, Physics Letters A, 99, 9, 1983\n\n\n\n\n\n","category":"function"},{"location":"basins/#Tipping-points","page":"Basins of Attraction","title":"Tipping points","text":"","category":"section"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"tipping_probabilities","category":"page"},{"location":"basins/#Attractors.tipping_probabilities","page":"Basins of Attraction","title":"Attractors.tipping_probabilities","text":"tipping_probabilities(basins_before, basins_after) → P\n\nReturn the tipping probabilities of the computed basins before and after a change in the system parameters (or time forcing), according to the definition of[Kaszás2019].\n\nThe input basins are integer-valued arrays, where the integers enumerate the attractor, e.g. the output of basins_of_attraction.\n\nDescription\n\nLet mathcalB_i(p) denote the basin of attraction of attractor A_i at parameter(s) p. Kaszás et al[Kaszás2019] define the tipping probability from A_i to A_j, given a parameter change in the system of p_- to p_+, as\n\nP(A_i to A_j  p_- to p_+) =\nfracmathcalB_j(p_+) cap mathcalB_i(p_-)mathcalB_i(p_-)\n\nwhere cdot is simply the volume of the enclosed set. The value of P(A_i to A_j  p_- to p_+) is P[i, j]. The equation describes something quite simple: what is the overlap of the basin of attraction of A_i at p_- with that of the attractor A_j at p_+. If basins_before, basins_after contain values of -1, corresponding to trajectories that diverge, this is considered as the last attractor of the system in P.\n\n[Kaszás2019]: Kaszás, Feudel & Tél. Tipping phenomena in typical dynamical systems subjected to parameter drift. Scientific Reports, 9(1)\n\n\n\n\n\n","category":"function"},{"location":"continuation/#Attractor-and-Basins-Continuation","page":"Attractor & Basins Continuation","title":"Attractor & Basins Continuation","text":"","category":"section"},{"location":"continuation/#Matching","page":"Attractor & Basins Continuation","title":"Matching","text":"","category":"section"},{"location":"continuation/","page":"Attractor & Basins Continuation","title":"Attractor & Basins Continuation","text":"match_attractor_ids!\nreplacement_map\ndataset_distance\ndatasets_sets_distances\nmatch_basins_ids!","category":"page"},{"location":"continuation/#Attractors.match_attractor_ids!","page":"Attractor & Basins Continuation","title":"Attractors.match_attractor_ids!","text":"match_attractor_ids!(a₊::AbstractDict, a₋; metric = Euclidean(), threshold = Inf)\n\nGiven dictionaries a₊, a₋ mapping IDs to attractors (Dataset instances), match attractor IDs in dictionary a₊ so that its attractors that are the closest to those in dictionary a₋ get assigned the same key as in a₋. Typically the +,- mean after and before some change of parameter of a system.\n\nReturn the replacement_map, a dictionary mapping old keys of a₊ to the new ones that they were mapped to. You can obtain this map, without modifying the dictionaries, by directly calling the replacement_map function with the output of datasets_sets_distances for given metric.\n\nDescription\n\nWhen finding attractors and their fractions in DynamicalSystems.jl, different attractors get assigned different IDs. However which attractor gets which ID is somewhat arbitrary. Finding the attractors of the same system for slightly different parameters could label \"similar\" attractors (at the different parameters) with different IDs. match_attractors_ids! tries to \"match\" them by modifying the attractor IDs, i.e., the keys of the given dictionaries.\n\nThe matching happens according to the output of the datasets_sets_distances function with the keyword metric. metric can be whatever that function accepts, such as an actual Metric instance, or an arbitrary user-defined function that computes an arbitrary \"distance\" between two datasets. Attractors are then match according to distance, with unique mapping. The closest attractors (before and after) are mapped to each other, and are removed from the matching pool, and then the next pair with least remaining distance is matched, and so on.\n\nAdditionally, you can provide a threshold value. If the distance between two attractors is larger than this threshold, then it is guaranteed that the attractors will get assigned different key in the dictionary a₊.\n\n\n\n\n\n","category":"function"},{"location":"continuation/#Attractors.replacement_map","page":"Attractor & Basins Continuation","title":"Attractors.replacement_map","text":"replacement_map(a₊, a₋, distances, threshold) → rmap\n\nReturn a dictionary mapping keys in a₊ to new keys in a₋, as explained in match_attractor_ids!. Instead of passing dictionaries for a₊, a₋, you may pass their keys directly.\n\n\n\n\n\n","category":"function"},{"location":"continuation/#DelayEmbeddings.dataset_distance","page":"Attractor & Basins Continuation","title":"DelayEmbeddings.dataset_distance","text":"dataset_distance(dataset1, dataset2 [, method])\n\nCalculate a distance between two AbstractDatasets, i.e., a distance defined between sets of points, as dictated by method. method defaults to Euclidean().\n\nDescription\n\nIf method isa Metric from Distances.jl, then the distance is the minimum distance of all the distances from a point in one set to the closest point in the other set. The distance is calculated with the given metric. In this case there is an internal heuristic: if length(dataset1)*length(dataset2) ≥ 1000 the algorithm switches to a KDTree-based version, otherwise it uses brute force. You can overwrite this by explicitly setting the brute boolean keyword or calling dataset_distance_brute directly.\n\nmethod can also be Hausdorff (a name provided by this module).\n\n\n\n\n\n","category":"function"},{"location":"continuation/#DelayEmbeddings.datasets_sets_distances","page":"Attractor & Basins Continuation","title":"DelayEmbeddings.datasets_sets_distances","text":"datasets_sets_distances(a₊, a₋ [, metric/method]) → distances\n\nCalculate distances between sets of Datasets. Here  a₊, a₋ are containers of Datasets, and the returned distances are dictionaries of of distances. Specifically, distances[i][j] is the distance of the dataset in the i key of a₊ to the j key of a₋. Notice that distances from a₋ to a₊ are not computed at all (assumming symmetry in the distance function).\n\nThe metric/method can be as in dataset_distance, in which case both sets must have equal-dimension datasets. However, method can also be any arbitrary user function that takes as input two datasets and returns any positive-definite number as their \"distance\".\n\n\n\n\n\n","category":"function"},{"location":"continuation/#Attractors.match_basins_ids!","page":"Attractor & Basins Continuation","title":"Attractors.match_basins_ids!","text":"match_basins_ids!(b₊::AbstractArray, b₋; threshold = Inf)\n\nSimilar to match_attractor_ids! but operate on basin arrays instead (the arrays typically returned by basins_of_attraction).\n\nThis method matches IDs of attractors whose basins of attraction before and after b₋,b₊ have the most overlap (in pixels). This overlap is normalized in 0-1 (with 1 meaning 100% overlap of pixels). The threshold in this case is compared to the inverse of the overlap (so, for threshold = 2 attractors that have less than 50% overlap get different IDs guaranteed).\n\n\n\n\n\n","category":"function"},{"location":"continuation/#Continuation","page":"Attractor & Basins Continuation","title":"Continuation","text":"","category":"section"},{"location":"continuation/","page":"Attractor & Basins Continuation","title":"Attractor & Basins Continuation","text":"basins_fractions_continuation\nRecurrencesSeedingContinuation","category":"page"},{"location":"continuation/#Attractors.basins_fractions_continuation","page":"Attractor & Basins Continuation","title":"Attractors.basins_fractions_continuation","text":"basins_fractions_continuation(continuation, prange, pidx, ics; kwargs...)\n\nThe given continuation contains a reference to a dynamical system, as well as how to find its attractors. I.e., it contains an AttractorMapper. Given this continuation, the basin fractions of the dynamical system, and continuate them across the parameter range prange, for the parameter of the system with index pidx. ics is as in basins_fractions, i.e., it must be a function generating random initial conditions.\n\nCurrent continuation methods are:\n\nRecurrencesSeedingContinuation.\n\nReturn:\n\nfractions_curves <: Vector{Dict{Int, Float64}}. The fractions of basins of attraction. fractions_curves[i] is a dictionary mapping attractor IDs to their basin fraction at the i-th parameter.\nattractors_info <: Vector{Dict{Int, <:Any}}. Information about the attractors. attractors_info[i] is a dictionary mapping attractor ID to information about the attractor at the i-th parameter. The type of information stored depends on the chosen continuation method.\n\nThe keyword arguments accepted are:\n\nsamples_per_parameter = 100: Amount of random samples drawn for each parameter value.\nshow_progress = true: Whether to show a progress bar for the process.\n\n\n\n\n\n","category":"function"},{"location":"continuation/#Attractors.RecurrencesSeedingContinuation","page":"Attractor & Basins Continuation","title":"Attractors.RecurrencesSeedingContinuation","text":"RecurrencesSeedingContinuation(mapper::AttractorsViaRecurrences; kwargs...)\n\nA method for basins_fractions_continuation. It uses seeding of previous attractors to find new ones, which is the main performance bottleneck. Will write more once we have the paper going.\n\nKeyword Arguments\n\nmetric, threshold: Given to match_attractor_ids! which is the function used to match attractors between each parameter slice.\ninfo_extraction = identity: A function that takes as an input an attractor (Dataset) and outputs whatever information should be stored. It is used to return the attractors_info in basins_fractions_continuation.\nseeds_from_attractor: A function that takes as an input an attractor and returns an iterator of initial conditions to be seeded from the attractor for the next parameter slice. By default, we sample some points from existing attractors according to how many points the attractors themselves contain. A maximum of 10 seeds is done per attractor.\n\n\n\n\n\n","category":"type"},{"location":"examples/#Examples-for-Attractors.jl","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"","category":"section"},{"location":"examples/#Discrete-system-example","page":"Examples for Attractors.jl","title":"Discrete system example","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using Attractors\nfunction newton_map(z, p, n)\n    z1 = z[1] + im*z[2]\n    dz1 = newton_f(z1, p[1])/newton_df(z1, p[1])\n    z1 = z1 - dz1\n    return SVector(real(z1), imag(z1))\nend\nnewton_f(x, p) = x^p - 1\nnewton_df(x, p)= p*x^(p-1)\n\nds = DiscreteDynamicalSystem(newton_map, [0.1, 0.2], [3.0])\nxg = yg = range(-1.5, 1.5; length = 400)\nmapper = AttractorsViaRecurrences(ds, (xg, yg))\nbasins, attractors = basins_of_attraction(mapper; show_progress = false)\nbasins","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"attractors","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Now let's plot this as a heatmap","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using CairoMakie\n# Set up some code for plotting attractors\nfunction scatter_attractors!(ax, attractors)\n    for k ∈ keys(attractors)\n        x, y = columns(attractors[k])\n        scatter!(ax, attractors[k].data;\n            color = Cycled(k),\n            strokewidth = 3, strokecolor = :white\n        )\n    end\nend\n\ngenerate_cmap(n) = cgrad(Main.COLORS[1:n], n; categorical = true)\nids = sort!(unique(basins))\ncmap = generate_cmap(length(ids))\n\nfig, ax = heatmap(xg, yg, basins;\n    colormap = cmap, colorrange = (ids[1] - 0.5, ids[end]+0.5),\n)\nscatter_attractors!(ax, attractors)\nfig","category":"page"},{"location":"examples/#Stroboscopic-map-example","page":"Examples for Attractors.jl","title":"Stroboscopic map example","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"This example targets periodically driven 2D continuous dynamical systems, like the Duffing oscillator:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using Attractors\nω=1.0; f = 0.2\nds = Systems.duffing([0.1, 0.25]; ω, f, d = 0.15, β = -1)\nusing OrdinaryDiffEq\ndiffeq = (alg = Vern9(), reltol = 1e-9)\nsmap = stroboscopicmap(ds, 2π/ω; diffeq)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"For stroboscopic maps, we strongly recommend using a higher precision integrator from OrdinaryDiffEq.jl. Now we can compute the basins of smap just like before.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"xg = yg = range(-2.2, 2.2; length = 200)\nmapper = AttractorsViaRecurrences(smap, (xg, yg); diffeq)\nbasins, attractors = basins_of_attraction(mapper; show_progress = false)\nbasins","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"And visualize the result as a heatmap, scattering the found attractors via scatter.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using CairoMakie\nids = sort!(unique(basins))\ncmap = generate_cmap(length(ids))\nfig, ax = heatmap(xg, yg, basins;\n    colormap = cmap, colorrange = (ids[1] - 0.5, ids[end]+0.5),\n)\nscatter_attractors!(ax, attractors)\nfig","category":"page"},{"location":"examples/#D-basins-of-4D-system","page":"Examples for Attractors.jl","title":"2D basins of 4D system","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"In this section we will calculate the basins of attraction of the four-dimensional magnetic pendulum. We know that the attractors of this system are all individual fixed points on the (x, y) plane so we will only compute the basins there. We can also use this opportunity to highlight a different method, the AttractorsViaProximity which works when we already know where the attractors are.","category":"page"},{"location":"examples/#Computing-the-basins","page":"Examples for Attractors.jl","title":"Computing the basins","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"ds = Systems.magnetic_pendulum(d=0.2, α=0.2, ω=0.8, N=3)\npsys = projected_integrator(ds, [1, 2], [0.0, 0.0])","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"For this systems we know the attractors are close to the magnet positions, so we can just do","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"attractors = Dict(i => Dataset([ds.f.magnets[i]]) for i in 1:3)\nmapper = AttractorsViaProximity(psys, attractors)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"and as before, get the basins of attraction","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"xg = yg = range(-4, 4; length=150)\nbasins, = basins_of_attraction(mapper, (xg, yg); show_progress = false)\nids = sort!(unique(basins))\ncmap = generate_cmap(length(ids))\nfig, ax = heatmap(xg, yg, basins;\n    colormap = cmap, colorrange = (ids[1] - 0.5, ids[end]+0.5),\n)\nscatter_attractors!(ax, attractors)\nfig","category":"page"},{"location":"examples/#Computing-the-uncertainty-exponent","page":"Examples for Attractors.jl","title":"Computing the uncertainty exponent","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Let's now calculate the uncertainty_exponent for this system as well. The calculation is straightforward:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"ε, f_ε, α = uncertainty_exponent(basins)\nfig, ax = lines(log.(ε), log.(f_ε))\nax.title = \"α = $(round(α; digits=3))\"\nfig","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"The actual uncertainty exponent is the slope of the curve (α) and indeed we get an exponent near 0 as we know a-priory the basins have fractal boundaries for the magnetic pendulum.","category":"page"},{"location":"examples/#Computing-the-tipping-probabilities","page":"Examples for Attractors.jl","title":"Computing the tipping probabilities","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"We will compute the tipping probabilities using the magnetic pendulum's example as the \"before\" state. For the \"after\" state we will change the γ parameter of the third magnet to be so small, its basin of attraction will virtually disappear. As we don't know when the basin of the third magnet will disappear, we switch the attractor finding algorithm back to AttractorsViaRecurrences.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"ds = Systems.magnetic_pendulum(d=0.2, α=0.2, ω=0.8, N=3, γs = [1.0, 1.0, 0.1])\npsys = projected_integrator(ds, [1, 2], [0.0, 0.0]; diffeq = (reltol = 1e-9,))\nmapper = AttractorsViaRecurrences(psys, (xg, yg); Δt = 1)\nbasins_after, attractors_after = basins_of_attraction(\n    mapper; show_progress = false\n)\n# matching attractors is important!\nmatch_attractors!(basins, attractors, basins_after, attractors_after)\n\n# now plot\nids = sort!(unique(basins_after))\ncmap = generate_cmap(length(ids))\nfig, ax = heatmap(xg, yg, basins_after;\n    colormap = cmap, colorrange = (ids[1] - 0.5, ids[end]+0.5),\n)\nscatter_attractors!(ax, attractors_after)\nfig","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"P = tipping_probabilities(basins, basins_after)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"As you can see P has size 3×2, as after the change only 2 attractors have been identified in the system (3 still exist but our state space discretization isn't accurate enough to find the 3rd because it has such a small basin). Also, the first row of P is 50% probability to each other magnet, as it should be due to the system's symmetry.","category":"page"},{"location":"examples/#Computing-the-basin-fractions-via-featurizing","page":"Examples for Attractors.jl","title":"Computing the basin fractions via featurizing","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"We can also compute the fraction of initial conditions that go to each of the three attractors for the magnetic pendulum via featurizing using AttractorsViaFeaturizing because here it is trivial to find the appropriate features that distinguish the attractors: simply the final value of the x and y coordinates of the trajectory.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Let's also just use basins_fractions with random sampling instead of computing a full array of basins of attractions, just for some variety.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"So let's define a random sampler and the featurizing function","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using Random\nrng = Random.MersenneTwister(1234)\nsampler, _ = statespace_sampler(rng; min_bounds=[-4, -4], max_bounds=[4, 4])\nfeaturizer(A, t) = A[end]","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"which gives","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"ds = Systems.magnetic_pendulum(d=0.2, α=0.2, ω=0.8, N=3)\npsys = projected_integrator(ds, [1, 2], [0.0, 0.0]; diffeq = (reltol = 1e-9,))\nmapper = AttractorsViaFeaturizing(psys, featurizer)\nfs = basins_fractions(mapper, sampler; N = 1000, show_progress = false)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"As it should, we get about 33% fraction for each attractor.","category":"page"},{"location":"examples/#D-basins","page":"Examples for Attractors.jl","title":"3D basins","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"To showcase the true power of AttractorsViaRecurrences we need to use a system whose attractors span higher-dimensional space. An example is","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"ds = Systems.thomas_cyclical(b = 0.1665)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"which, for this parameter, contains 5 coexisting attractors. 3 of them are entangled periodic orbits that span across all three dimensions, and the remaining 2 are fixed points.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"To compute the basins we define a three-dimensional grid and call on it basins_of_attraction.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"# This computation takes about an hour\nxg = yg = zg = range(-6.0, 6.0; length = 251)\nmapper = AttractorsViaRecurrences(ds, (xg, yg, zg))\nbasins, attractors = basins_of_attraction(mapper)\nattractors","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Dict{Int16, Dataset{3, Float64}} with 5 entries:\n  5 => 3-dimensional Dataset{Float64} with 1 points\n  4 => 3-dimensional Dataset{Float64} with 379 points\n  6 => 3-dimensional Dataset{Float64} with 1 points\n  2 => 3-dimensional Dataset{Float64} with 538 points\n  3 => 3-dimensional Dataset{Float64} with 537 points\n  1 => 3-dimensional Dataset{Float64} with 1 points","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"The basins of attraction are very complicated. We can try to visualize them by animating the 2D slices at each z value, to obtain:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"<video width=\"75%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/chaos/cyclical_basins.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Then, we visualize the attractors to obtain:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"<video width=\"75%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/chaos/cyclical_attractors.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"In the animation above, the scattered points are the attractor values the function AttractorsViaRecurrences found by itself. Of course, for the periodic orbits these points are incomplete. Once the function's logic understood we are on an attractor, it stops computing. However, we also simulated lines, by evolving initial conditions colored appropriately with the basins output.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"The animation was produced with the code:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using GLMakie\nfig = Figure()\ndisplay(fig)\nax = fig[1,1] = Axis3(fig; title = \"found attractors\")\ncmap = cgrad(:dense, 6; categorical = true)\n\nfor i in keys(attractors)\n    tr = attractors[i]\n    markersize = length(attractors[i]) > 10 ? 2000 : 6000\n    marker = length(attractors[i]) > 10 ? :circle : :rect\n    scatter!(ax, columns(tr)...; markersize, marker, transparency = true, color = cmap[i])\n    j = findfirst(isequal(i), bsn)\n    x = xg[j[1]]\n    y = yg[j[2]]\n    z = zg[j[3]]\n    tr = trajectory(ds, 100, SVector(x,y,z); Ttr = 100)\n    lines!(ax, columns(tr)...; linewidth = 1.0, color = cmap[i])\nend\n\na = range(0, 2π; length = 200) .+ π/4\n\nrecord(fig, \"cyclical_attractors.mp4\", 1:length(a)) do i\n    ax.azimuth = a[i]\nend","category":"page"},{"location":"examples/#Poincaré-map-example","page":"Examples for Attractors.jl","title":"Poincaré map example","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"In the previous example we saw that this system has periodic attractors. In the Poincaré map these periodic attractors become points. We can use any instance of AttractorMapper and poincaremap to find basins of attraction on the Poincaré surface of section.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"ds = Systems.thomas_cyclical(b = 0.1665)\nxg = yg = range(-6.0, 6.0; length = 100)\npmap = poincaremap(ds, (3, 0.0);\n    rootkw = (xrtol = 1e-8, atol = 1e-8), diffeq = (reltol=1e-9,)\n)\nmapper = AttractorsViaRecurrences(pmap, (xg, yg))\nbasins, attractors = basins_of_attraction(mapper; show_progress = false)\nattractors","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"attractors[1]","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Looks good so far, but let's plot it as well:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"ids = sort!(unique(basins))\ncmap = generate_cmap(length(ids))\nfig, ax = heatmap(xg, yg, basins;\n    colormap = cmap, colorrange = (ids[1] - 0.5, ids[end]+0.5),\n)\nscatter_attractors!(ax, attractors)\nfig","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"This aligns perfectly with the video we produced above.","category":"page"},{"location":"attractors/#Finding-Attractors","page":"Finding Attractors","title":"Finding Attractors","text":"","category":"section"},{"location":"attractors/","page":"Finding Attractors","title":"Finding Attractors","text":"Attractors.jl defines a generic interface for finding attractors of dynamical systems. One first decides the instance of GeneralizedDynamicalSystem they need. Then, an instance of AttractorMapper is created from this dynamical system. This mapper instance can be used to compute e.g., basins_of_attraction, and the output can be further analyzed to get e.g., the basin_entropy.","category":"page"},{"location":"attractors/","page":"Finding Attractors","title":"Finding Attractors","text":"The example 2D basins of 4D system contains most of the functionality documented in this page.","category":"page"},{"location":"attractors/","page":"Finding Attractors","title":"Finding Attractors","text":"AttractorMapper","category":"page"},{"location":"attractors/#Attractors.AttractorMapper","page":"Finding Attractors","title":"Attractors.AttractorMapper","text":"AttractorMapper(ds::GeneralizedDynamicalSystem, args...; kwargs...) → mapper\n\nSubtypes of AttractorMapper are structures that map initial conditions of ds to attractors. Currently available mapping methods:\n\nAttractorsViaProximity\nAttractorsViaRecurrences\nAttractorsViaFeaturizing\n\nAll AttractorMapper subtypes can be used with basins_fractions or basins_of_attraction.\n\nIn addition, some mappers can be called as a function of an initial condition:\n\nlabel = mapper(u0)\n\nand this will on the fly compute and return the label of the attractor u0 converges at. The mappers that can do this are:\n\nAttractorsViaProximity\nAttractorsViaRecurrences\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Proximity","page":"Finding Attractors","title":"Proximity","text":"","category":"section"},{"location":"attractors/","page":"Finding Attractors","title":"Finding Attractors","text":"AttractorsViaProximity","category":"page"},{"location":"attractors/#Attractors.AttractorsViaProximity","page":"Finding Attractors","title":"Attractors.AttractorsViaProximity","text":"AttractorsViaProximity(ds::DynamicalSystem, attractors::Dict [, ε]; kwargs...)\n\nMap initial conditions to attractors based on whether the trajectory reaches ε-distance close to any of the user-provided attractors. They have to be in a form of a dictionary mapping attractor labels to Datasets containing the attractors.\n\nThe system gets stepped, and at each step the minimum distance to all attractors is computed. If any of these distances is < ε, then the label of the nearest attractor is returned.\n\nIf an ε::Real is not provided by the user, a value is computed automatically as half of the minimum distance between all attractors. This operation can be expensive for large attractor datasets. If length(attractors) == 1, then ε becomes 1/10 of the diagonal of the box containing the attractor. If length(attractors) == 1 and the attractor is a single point, an error is thrown.\n\nBecause in this method the attractors are already known to the user, the method can also be called supervised.\n\nKeywords\n\nTtr = 100: Transient time to first evolve the system for before checking for proximity.\nΔt = 1: Integration step time (only valid for continuous systems).\nhorizon_limit = 1e3: If the maximum distance of the trajectory from any of the given attractors exceeds this limit, it is assumed that the trajectory diverged (gets labelled as -1).\nmx_chk_lost = 1000: If the integrator has been stepped this many times without coming ε-near to any attractor,  it is assumed that the trajectory diverged (gets labelled as -1).\ndiffeq = NamedTuple(): Keywords propagated to DifferentialEquations.jl (only valid for continuous systems).\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Recurrences","page":"Finding Attractors","title":"Recurrences","text":"","category":"section"},{"location":"attractors/","page":"Finding Attractors","title":"Finding Attractors","text":"AttractorsViaRecurrences\nAttractorsViaRecurrencesSparse\nautomatic_Δt_basins","category":"page"},{"location":"attractors/#Attractors.AttractorsViaRecurrences","page":"Finding Attractors","title":"Attractors.AttractorsViaRecurrences","text":"AttractorsViaRecurrences(ds::GeneralizedDynamicalSystem, grid::Tuple; kwargs...)\n\nMap initial conditions to attractors by identifying attractors on the fly based on recurrences in the state space, as outlined by Datseris & Wagemakers[Datseris2022]. Works for any case encapsulated by GeneralizedDynamicalSystem. The version AttractorsViaRecurrencesSparse should practically always be preferred over this one.\n\ngrid is a tuple of ranges partitioning the state space so that a finite state machine can operate on top of it. For example grid = (xg, yg) where xg = yg = range(-5, 5; length = 100) for a two-dimensional system. The grid has to be the same dimensionality as the state space, use a projected_integrator if you want to search for attractors in a lower dimensional subspace.\n\nKeyword Arguments\n\nΔt: Approximate time step of the integrator, which is 1 for discrete systems. For continuous systems, an automatic value is calculated using automatic_Δt_basins.\nTtr = 0: This keyword arguments allows to skip a transient before the recurrence routine begins. It is useful for some high dimensional systems to speed up the convergence to the attractor.\ndiffeq = NamedTuple(): Keyword arguments propagated to integrator. Only valid for ContinuousDynamicalSystem. It is recommended to choose high accuracy solvers for this application, e.g. diffeq = (alg=Vern9(), reltol=1e-9, abstol=1e-9).\nmx_chk_att = 2: A parameter that sets the maximum checks of consecutives hits of an attractor before deciding the basin of the initial condition.\nmx_chk_hit_bas = 10: Maximum check of consecutive visits of the same basin of attraction. This number can be increased for higher accuracy.\nmx_chk_fnd_att = 100: Maximum check of unnumbered cell before considering we have an attractor. This number can be increased for higher accuracy.\nmx_chk_loc_att = 100: Maximum check of consecutive cells marked as an attractor before considering that we have all the available pieces of the attractor.\nmx_chk_lost = 20: Maximum check of iterations outside the defined grid before we consider the orbit lost outside. This number can be increased for higher accuracy.\nhorizon_limit = 1e6: If the norm of the integrator state reaches this limit we consider that the orbit diverges.\nsafety_counter_max = Int(1e6): A safety counter that is always increasing for each initial condition. Once exceeded, the algorithm assigns -1 and throws a warning. This clause exists to stop the algorithm never haulting for innappropriately defined grids, where a found attractor may intersect in the same cell with a new attractor the orbit traces (which leads to infinite resetting of all counters). As this check comes with a performance deficit, the keyword unsafe=true can be set to disable it in case the user is confident the algorithm will hault.\n\nDescription\n\nAn initial condition given to an instance of AttractorsViaRecurrences is iterated based on the integrator corresponding to ds. A recurrence in the state space means that the trajectory has converged to an attractor. This is the basis for finding attractors.\n\nA finite state machine (FSM) follows the trajectory in the state space, and constantly maps it to the given grid. The FSM decides when an initial condition has successfully converged into an attractor. An array, internally called \"basins\", stores the state of the FSM on the grid, according to the indexing system described in [Datseris2022]. As the system is integrated more and more, the information of the \"basins\" becomes richer and richer with more identified attractors or with grid cells that belong to basins of already found attractors. Notice that only in the special method basins_of_attraction(mapper::AttractorsViaRecurrences) the information of the attraction or exit basins is utilized. In other functions like basins_fractions only the attractor locations are utilized.\n\nThe iteration of a given initial condition continues until one of the following happens:\n\nThe trajectory hits mx_chk_fnd_att times in a row grid cells previously visited: it is considered that an attractor is found and is labelled with a new number.\nThe trajectory hits an already identified attractor mx_chk_att consecutive times: the initial condition is numbered with the attractor's number.\nThe trajectory hits a known basin mx_chk_hit_bas times in a row: the initial condition belongs to that basin and is numbered accordingly.\nThe trajectory spends mx_chk_lost steps outside the defined grid or the norm of the integrator state becomes > than horizon_limit: the initial condition is set to -1.\nIf none of the above happens and unsafe=true, the algorithm will error.\n\n[Datseris2022]: G. Datseris and A. Wagemakers, Effortless estimation of basins of attraction, Chaos 32, 023104 (2022)\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Attractors.AttractorsViaRecurrencesSparse","page":"Finding Attractors","title":"Attractors.AttractorsViaRecurrencesSparse","text":"AttractorsViaRecurrencesSparse(ds::GeneralizedDynamicalSystem, grid::Tuple; kwargs...)\n\nThis version is practically identical to AttractorsViaRecurrences, with the difference that the internal representation of the grid uses a sparse array. In practice, it should always be preferred when searching for basins_fractions. Only for very low dimensional systems and for computing the full basins_of_attraction the non-sparse version should be used.\n\nSee the docstring of AttractorsViaRecurrences for possible keywords and details on the algorithm.\n\n\n\n\n\n","category":"function"},{"location":"attractors/#Attractors.automatic_Δt_basins","page":"Finding Attractors","title":"Attractors.automatic_Δt_basins","text":"automatic_Δt_basins(integ, grid; N = 5000) → Δt\n\nCalculate an optimal Δt value for basins_of_attraction. This is done by evaluating the dynamic rule f (vector field) at N randomly chosen points of the grid. The average f is then compared with the diagonal length of a grid cell and their ratio provides Δt.\n\nNotice that Δt should not be too small which happens typically if the grid resolution is high. It is okay for basins_of_attraction if the trajectory skips a few cells. But if Δt is too small the default values for all other keywords such as mx_chk_hit_bas need to be increased drastically.\n\nAlso, Δt that is smaller than the internal step size of the integrator will cause a performance drop.\n\n\n\n\n\n","category":"function"},{"location":"attractors/#Featurizing","page":"Finding Attractors","title":"Featurizing","text":"","category":"section"},{"location":"attractors/","page":"Finding Attractors","title":"Finding Attractors","text":"AttractorsViaFeaturizing\nClusteringConfig\ncluster_features","category":"page"},{"location":"attractors/#Attractors.AttractorsViaFeaturizing","page":"Finding Attractors","title":"Attractors.AttractorsViaFeaturizing","text":"AttractorsViaFeaturizing(\n    ds::DynamicalSystem, featurizer::Function,\n    clusterconfig = ClusteringConfig(); kwargs...\n)\n\nInitialize a mapper that maps initial conditions to attractors using the featurizing and clustering method of [Stender2021]. See AttractorMapper for how to use the mapper.\n\nfeaturizer is a function that takes as an input an integrated trajectory A::Dataset and the corresponding time vector t and returns a Vector{<:Real} of features describing the trajectory. See ClusteringConfig for configuring the clustering process.\n\nKeyword arguments\n\nT=100, Ttr=100, Δt=1, diffeq=NamedTuple(): Propagated to trajectory.\n\nDescription\n\nThe trajectory X of each initial condition is transformed into a vector of features. Each feature is a number useful in characterizing the attractor the initial condition ends up at, and distinguishing it from other attrators. Example features are the mean or standard deviation of one of the of the timeseries of the trajectory, the entropy of some of the dimensions, the fractal dimension of X, or anything else you may fancy. The vectors of features are then used to identify to which attractor each trajectory belongs (i.e. in which basin of attractor each initial condition is in). The method thus relies on the user having at least some basic idea about what attractors to expect in order to pick the right features, in contrast to AttractorsViaRecurrences.\n\nOnce the features are extracted, they are clustered using ClusteringConfig, so see that docstring for more details on the clustering. Each cluster is considered one attractor.\n\nIf templates are provided to ClusteringConfig, then a supervised version is used, and the functionality is similar to AttractorsViaProximity. Generally speaking, the AttractorsViaProximity is superior. However, if the dynamical system has extremely high-dimensionality, there may be reasons to use the supervised method of this featurizing algorithm instead, as it projects the trajectories into a much lower dimensional representation of features.\n\n[Stender2021]: Stender & Hoffmann, bSTAB: an open-source software for computing the basin stability of multi-stable dynamical systems\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Attractors.ClusteringConfig","page":"Finding Attractors","title":"Attractors.ClusteringConfig","text":"ClusteringConfig(; kwargs...)\n\nInitialize a struct that contains information used to cluster \"features\". These features are typically extracted from trajectories/datasets in AttractorsViaFeaturizing, or manualy by the user.\n\nThe clustering is done in the function cluster_features.\n\nThe default clustering method is an improvement over existing literature, see Description.\n\nKeyword arguments\n\ntemplates = nothing: Enables supervised version, see below. If given, must be a Dict of cluster labels to cluster features. The labels must be of Int type, and the features are Vectors representing a cluster (which can be an attractor, for instance). The label -1 is reserved for invalid trajectories, which either diverge or whose clustering failed.\n\nSupervised method\n\nclustering_threshold = 0.0: Maximum allowed distance between a feature and the cluster center for it to be considered inside the cluster. Only used when clust_method = \"kNN_thresholded\".\nclust_method = clustering_threshold > 0 ? \"kNN_thresholded\" : \"kNN\": (supervised method only) which clusterization method to apply. If \"kNN\", the first-neighbor clustering is used. If \"kNN_thresholded\", a subsequent step is taken, which considers as unclassified (label -1) the features whose distance to the nearest template is above the clustering_threshold.\n\nUnsupervised method\n\nrescale_features = true: if true, rescale each dimension of the extracted features separately into the range [0,1]. This typically leads to more accurate clustering.\nmin_neighbors = 10: (unsupervised method only) minimum number of neighbors (i.e. of similar features) each feature needs to have in order to be considered in a cluster (fewer than this, it is labeled as an outlier, -1).\nclust_method_norm = Euclidean(): metric to be used in the clustering.\noptimal_radius_method::String = \"silhouettes_optim\": the method used to determine the optimal radius for clustering features in the unsupervised method. Possible values are:\n\"silhouettes\": Performs a linear (sequential) search for the radius that maximizes a statistic of the silhouette values of clusters (typically the mean). This can be chosen with silhouette_statistic. The linear search may take some time to finish. To increase speed, the number of radii iterated through can be reduced by decreasing num_attempts_radius (see its entry below).\n\"silhouettes_optim\": Same as \"silhouettes\" but performs an optimized search via Optim.jl. It's faster than \"silhouettes\", with typically the same accuracy (the search here is not guaranteed to always find the global maximum, though it typically gets close).\n\"knee\": chooses the the radius according to the knee (a.k.a. elbow, highest-derivative method) and is quicker, though generally leading to much worse clustering. It requires that min_neighbors > 1.\n\nKeywords for optimal radius estimation\n\nnum_attempts_radius = 100: number of radii that the optimal_radius_method will try out in its iterative procedure. Higher values increase the accuracy of clustering, though not necessarily much, while always reducing speed.\nsilhouette_statistic::Function = mean: statistic (e.g. mean or minimum) of the silhouettes that is maximized in the \"optimal\" clustering. The original implementation in [Stender2021] used the minimum of the silhouettes, and typically performs less accurately than the mean.\nmax_used_features = 0: if not 0, it should be an Int denoting the max amount of features to be used when finding the optimal radius. Useful when clustering a very large number of features (e.g., high accuracy estimation of fractions of basins of attraction).\n\nDescription\n\nThe trajectory X, which may for instance be an attractor, is transformed into a vector of features. Each feature is a number useful in characterizing the attractor, and distinguishing it from other attrators. Example features are the mean or standard deviation of one of the of the timeseries of the trajectory, the entropy of the first two dimensions, the fractal dimension of X, or anything else you may fancy. The vectors of features are then used to identify clusters of attractors.\n\nThere are two versions to do this. The unsupervised version does not rely on templates, and instead uses the DBSCAN clustering algorithm to identify clusters of similar features. To achieve this, each feature is considered a point in feature space. In this space, the algorithm basically groups points that are closely packed. To achieve this, a crucial parameter is a radius for  distance ϵ that determines the \"closeness\" of points in clusters.\n\nTwo methods are currently implemented to determine an optimal_radius, as described in optimal_radius_method above. The default method is based on the silhouette values of clusters. A silhouette value measures how similar a point is to the cluster it currently belongs, compared to the other clusters, and ranges from -1 (worst matching) to +1 (ideal matching). If only one cluster is found, the assigned silhouette is 0. The default method ,silhouettes, chooses the radius ε that maximizes the average silhouette across all clusters.  The alternative elbow method works by calculating the distance of each point to its k-nearest-neighbors (with k=min_neighbors) and finding the distance corresponding to the highest derivative in the curve of the distances, sorted in ascending order. This distance is chosen as the optimal radius. It is described in [Kriegel1996] and [Schubert2017].\n\nIn the supervised version, the user provides features to be used as templates guiding the clustering via the templates keyword. Each feature is considered to belong to the \"cluster\" of the nearest template (based on the distance in feature space), and is labelled following the template's label, given in templates.\n\nIn both versions, features whose cluster is not identified are labeled as -1.\n\n[Stender2021]: Stender & Hoffmann, bSTAB: an open-source software for computing the basin stability of multi-stable dynamical systems\n\n[Kriegel1996]: Ester, Kriegel, Sander and Xu: A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise\n\n[Schubert2017]: Schubert, Sander, Ester, Kriegel and Xu: DBSCAN Revisited, Revisited: Why and How You Should (Still) Use DBSCAN\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Attractors.cluster_features","page":"Finding Attractors","title":"Attractors.cluster_features","text":"cluster_features(features, cc::ClusteringConfig)\n\nCluster the given features::Vector{<:AbstractVector}, according to given ClusteringConfig. Return cluster_labels, cluster_errors, which respectively contain, for each feature, the labels (indices) of the corresponding cluster and the error associated with that clustering. The error is the distance from the feature to (i) the cluster, in the supervised method or (ii) to the center of the cluster, in the unsupervised method.\n\n\n\n\n\n","category":"function"},{"location":"#Attractors.jl","page":"Attractors.jl","title":"Attractors.jl","text":"","category":"section"},{"location":"","page":"Attractors.jl","title":"Attractors.jl","text":"Attractors","category":"page"},{"location":"#Attractors","page":"Attractors.jl","title":"Attractors","text":"A module for finding attractors of dynamical systems, their basins and their boundaris, and continuing attractors and basins across parameters.\n\nPart of DynamicalSystems.jl.\n\n\n\n\n\n","category":"module"},{"location":"#map-of-the-package","page":"Attractors.jl","title":"map of the package","text":"","category":"section"},{"location":"","page":"Attractors.jl","title":"Attractors.jl","text":"say about mapping, then about finding fractions/basins, then continuation.","category":"page"}]
}
