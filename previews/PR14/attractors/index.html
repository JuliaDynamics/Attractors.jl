<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Finding Attractors · Attractors.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Attractors.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Attractors.jl</a></li><li class="is-active"><a class="tocitem" href>Finding Attractors</a><ul class="internal"><li><a class="tocitem" href="#Proximity"><span>Proximity</span></a></li><li><a class="tocitem" href="#Recurrences"><span>Recurrences</span></a></li><li><a class="tocitem" href="#Featurizing"><span>Featurizing</span></a></li></ul></li><li><a class="tocitem" href="../basins/">Basins of Attraction</a></li><li><a class="tocitem" href="../continuation/">Attractor &amp; Basins Continuation</a></li><li><a class="tocitem" href="../examples/">Examples for Attractors.jl</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Finding Attractors</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Finding Attractors</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/Attractors.jl/blob/main/docs/src/attractors.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Finding-Attractors"><a class="docs-heading-anchor" href="#Finding-Attractors">Finding Attractors</a><a id="Finding-Attractors-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-Attractors" title="Permalink"></a></h1><p>Attractors.jl defines a generic interface for finding attractors of dynamical systems. One first decides the instance of <a href="@ref"><code>GeneralizedDynamicalSystem</code></a> they need. Then, an instance of <a href="#Attractors.AttractorMapper"><code>AttractorMapper</code></a> is created from this dynamical system. This <code>mapper</code> instance can be used to compute e.g., <a href="../basins/#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>, and the output can be further analyzed to get e.g., the <a href="../basins/#Attractors.basin_entropy"><code>basin_entropy</code></a>.</p><p>The example <a href="../examples/#D-basins-of-4D-system">2D basins of 4D system</a> contains most of the functionality documented in this page.</p><article class="docstring"><header><a class="docstring-binding" id="Attractors.AttractorMapper" href="#Attractors.AttractorMapper"><code>Attractors.AttractorMapper</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AttractorMapper(ds::GeneralizedDynamicalSystem, args...; kwargs...) → mapper</code></pre><p>Subtypes of <code>AttractorMapper</code> are structures that map initial conditions of <code>ds</code> to attractors. Currently available mapping methods:</p><ul><li><a href="#Attractors.AttractorsViaProximity"><code>AttractorsViaProximity</code></a></li><li><a href="#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a></li><li><a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a></li></ul><p>All <code>AttractorMapper</code> subtypes can be used with <a href="../basins/#Attractors.basins_fractions"><code>basins_fractions</code></a> or <a href="../basins/#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>.</p><p>In addition, some mappers can be called as a function of an initial condition:</p><pre><code class="language-julia hljs">label = mapper(u0)</code></pre><p>and this will on the fly compute and return the label of the attractor <code>u0</code> converges at. The mappers that can do this are:</p><ul><li><a href="#Attractors.AttractorsViaProximity"><code>AttractorsViaProximity</code></a></li><li><a href="#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/063a56bc4363961cc5bd83c7538d62cebf63582d/src/mapping/attractor_mapping.jl#L16-L35">source</a></section></article><h2 id="Proximity"><a class="docs-heading-anchor" href="#Proximity">Proximity</a><a id="Proximity-1"></a><a class="docs-heading-anchor-permalink" href="#Proximity" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Attractors.AttractorsViaProximity" href="#Attractors.AttractorsViaProximity"><code>Attractors.AttractorsViaProximity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AttractorsViaProximity(ds::DynamicalSystem, attractors::Dict [, ε]; kwargs...)</code></pre><p>Map initial conditions to attractors based on whether the trajectory reaches <code>ε</code>-distance close to any of the user-provided <code>attractors</code>. They have to be in a form of a dictionary mapping attractor labels to <code>Dataset</code>s containing the attractors.</p><p>The system gets stepped, and at each step the minimum distance to all attractors is computed. If any of these distances is <code>&lt; ε</code>, then the label of the nearest attractor is returned.</p><p>If an <code>ε::Real</code> is <em>not</em> provided by the user, a value is computed automatically as half of the minimum distance between all attractors. This operation can be expensive for large attractor datasets. If <code>length(attractors) == 1</code>, then <code>ε</code> becomes 1/10 of the diagonal of the box containing the attractor. If <code>length(attractors) == 1</code> and the attractor is a single point, an error is thrown.</p><p>Because in this method the attractors are already known to the user, the method can also be called <em>supervised</em>.</p><p><strong>Keywords</strong></p><ul><li><code>Ttr = 100</code>: Transient time to first evolve the system for before checking for proximity.</li><li><code>Δt = 1</code>: Integration step time (only valid for continuous systems).</li><li><code>horizon_limit = 1e3</code>: If the maximum distance of the trajectory from any of the given attractors exceeds this limit, it is assumed that the trajectory diverged (gets labelled as <code>-1</code>).</li><li><code>mx_chk_lost = 1000</code>: If the integrator has been stepped this many times without coming <code>ε</code>-near to any attractor,  it is assumed that the trajectory diverged (gets labelled as <code>-1</code>).</li><li><code>diffeq = NamedTuple()</code>: Keywords propagated to DifferentialEquations.jl (only valid for continuous systems).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/063a56bc4363961cc5bd83c7538d62cebf63582d/src/mapping/attractor_mapping_proximity.jl#L1-L32">source</a></section></article><h2 id="Recurrences"><a class="docs-heading-anchor" href="#Recurrences">Recurrences</a><a id="Recurrences-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrences" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Attractors.AttractorsViaRecurrences" href="#Attractors.AttractorsViaRecurrences"><code>Attractors.AttractorsViaRecurrences</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AttractorsViaRecurrences(ds::GeneralizedDynamicalSystem, grid::Tuple; kwargs...)</code></pre><p>Map initial conditions to attractors by identifying attractors on the fly based on recurrences in the state space, as outlined by Datseris &amp; Wagemakers<sup class="footnote-reference"><a id="citeref-Datseris2022" href="#footnote-Datseris2022">[Datseris2022]</a></sup>. Works for any case encapsulated by <a href="@ref"><code>GeneralizedDynamicalSystem</code></a>.</p><p><code>grid</code> is a tuple of ranges partitioning the state space so that a finite state machine can operate on top of it. For example <code>grid = (xg, yg)</code> where <code>xg = yg = range(-5, 5; length = 100)</code> for a two-dimensional system. The grid has to be the same dimensionality as the state space, use a <a href="@ref"><code>projected_integrator</code></a> if you want to search for attractors in a lower dimensional subspace.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>sparse = true</code>: control the interval representation of the state space grid. If true,  uses a sparse array, whose memory usage is in general more efficient than a regular  array obtained with <code>sparse=false</code>. In practice, the sparse representation should  always be preferred when searching for <a href="../basins/#Attractors.basins_fractions"><code>basins_fractions</code></a>. Only for very low  dimensional systems and for computing the full <a href="../basins/#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a> the  non-sparse version should be used.</li></ul><p><strong>Integrator configuration</strong></p><ul><li><code>Ttr = 0</code>: This keyword arguments allows to skip a transient before the recurrence routine begins. It is useful for some high dimensional systems to speed up the convergence to the attractor.</li><li><code>Δt</code>: Approximate time step of the integrator, which is <code>1</code> for discrete time systems. For continuous systems, an automatic value is calculated using <a href="#Attractors.automatic_Δt_basins"><code>automatic_Δt_basins</code></a>. For very fine grids, this can become very small, much smaller than the typical integrator internal step size in case of adaptive integrators. In that case use <code>stop_at_Δt = true</code>.</li><li><code>diffeq = NamedTuple()</code>: Keyword arguments propagated to <a href="@ref"><code>integrator</code></a>. Only valid for continuous time systems. It is recommended to choose high accuracy solvers for this application, e.g. <code>diffeq = (alg=Vern9(), reltol=1e-9, abstol=1e-9)</code>.</li><li><code>stop_at_Δt = false</code>: control whether the integrator advances exactly <code>Δt</code> time points  with each step or not. Should only be used if <code>Δt</code> is smaller than the typical integrator  step (for continuous time systems). Being true slows down performance significantly but  increases accuracy drastically, especially in the case of limit cycle attractors,  but only if the automatic value of <code>Δt</code> is used.</li></ul><p><strong>Finite state machine configuration</strong></p><ul><li><code>mx_chk_att = 2</code>: Μaximum checks of consecutives hits of an existing attractor cell before declaring convergence to that existing attractor.</li><li><code>mx_chk_hit_bas = 10</code>: Maximum check of consecutive visits of the same basin of attraction before declaring convergence to an existing attractor.</li><li><code>mx_chk_fnd_att = 100</code>: Maximum check of consecutive visits to a previously visited unlabeled cell before declaring we have found a new attractor.</li><li><code>mx_chk_loc_att = 100</code>: Maximum check of consecutive visits to cells marked as a new attractor, during the attractor identification phase, before declaring we that we have identified the new attractor with sufficient cells.</li><li><code>store_once_per_cell = true</code>: Control if multiple points in state space that belong to the same cell are stored or not in the attractor, after an attractor is found. If <code>true</code>, each visited cell will only store a point once, which is desirable for fixed points and limit cycles. If <code>false</code>, at least <code>mx_chk_loc_att</code> points are stored per attractor, leading to more densely stored attractors, which may be desirable for instance in chaotic attractors.</li><li><code>mx_chk_lost = 20</code>: Maximum check of iterations outside the defined grid before we declare the orbit lost outside and hence assign it label <code>-1</code>.</li><li><code>horizon_limit = 1e6</code>: If the norm of the integrator state reaches this limit we declare that the orbit diverged to infinity.</li><li><code>mx_chk_safety = Int(1e6)</code>: A safety counter that is always increasing for each initial condition. Once exceeded, the algorithm assigns <code>-1</code> and throws a warning. This clause exists to stop the algorithm never haulting for innappropriate grids, where a found attractor may intersect in the same cell with a new attractor the orbit traces (which leads to infinite resetting of all counters).</li></ul><p><strong>Description</strong></p><p>An initial condition given to an instance of <code>AttractorsViaRecurrences</code> is iterated based on the integrator corresponding to <code>ds</code>. A recurrence in the state space means that the trajectory has converged to an attractor. This is the basis for finding attractors.</p><p>A finite state machine (FSM) follows the trajectory in the state space, and constantly maps it to the given <code>grid</code>. The FSM decides when an initial condition has successfully converged into an attractor. An array, internally called &quot;basins&quot;, stores the state of the FSM on the grid, according to the indexing system described in <sup class="footnote-reference"><a id="citeref-Datseris2022" href="#footnote-Datseris2022">[Datseris2022]</a></sup>. As the system is integrated more and more, the information of the &quot;basins&quot; becomes richer and richer with more identified attractors or with grid cells that belong to basins of already found attractors. Notice that only in the special method <code>basins_of_attraction(mapper::AttractorsViaRecurrences)</code> the information of the attraction or exit basins is utilized. In other functions like <code>basins_fractions</code> only the attractor locations are utilized, as the basins themselves are not stored.</p><p>The iteration of a given initial condition continues until one of the following happens:</p><ul><li>The trajectory hits <code>mx_chk_fnd_att</code> times in a row grid cells previously visited:  it is considered that an attractor is found and is labelled with a new ID. Then,  iteration continues a bit more until we have identified the attractor with sufficient  accuracy, i.e., until <code>mx_chk_loc_att</code> cells with the new ID have been visited.</li><li>The trajectory hits an already identified attractor <code>mx_chk_att</code> consecutive times:  the initial condition is numbered with the attractor&#39;s ID.</li><li>The trajectory hits a known basin <code>mx_chk_hit_bas</code> times in a row: the initial condition  belongs to that basin and is numbered accordingly. Notice that basins are stored and  used only when <code>sparse = false</code>.</li><li>The trajectory spends <code>mx_chk_lost</code> steps outside the defined grid or the norm  of the integrator state becomes &gt; than <code>horizon_limit</code>: the initial  condition&#39;s label is set to <code>-1</code>.</li><li>If none of the above happens, the initial condition is labelled <code>-1</code> after  and <code>mx_chk_safety</code> integrator steps.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/063a56bc4363961cc5bd83c7538d62cebf63582d/src/mapping/attractor_mapping_recurrences.jl#L5-L107">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AttractorsViaRecurrencesSparse</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Attractors.automatic_Δt_basins" href="#Attractors.automatic_Δt_basins"><code>Attractors.automatic_Δt_basins</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">automatic_Δt_basins(integ, grid; N = 5000) → Δt</code></pre><p>Calculate an optimal <code>Δt</code> value for <a href="../basins/#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>. This is done by evaluating the dynamic rule <code>f</code> (vector field) at <code>N</code> randomly chosen points of the grid. The average <code>f</code> is then compared with the diagonal length of a grid cell and their ratio provides <code>Δt</code>.</p><p>Notice that <code>Δt</code> should not be too small which happens typically if the grid resolution is high. It is okay for <a href="../basins/#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a> if the trajectory skips a few cells. But if <code>Δt</code> is too small the default values for all other keywords such as <code>mx_chk_hit_bas</code> need to be increased drastically.</p><p>Also, <code>Δt</code> that is smaller than the internal step size of the integrator will cause a performance drop.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/063a56bc4363961cc5bd83c7538d62cebf63582d/src/mapping/attractor_mapping_recurrences.jl#L256-L270">source</a></section></article><h2 id="Featurizing"><a class="docs-heading-anchor" href="#Featurizing">Featurizing</a><a id="Featurizing-1"></a><a class="docs-heading-anchor-permalink" href="#Featurizing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Attractors.AttractorsViaFeaturizing" href="#Attractors.AttractorsViaFeaturizing"><code>Attractors.AttractorsViaFeaturizing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AttractorsViaFeaturizing(
    ds::DynamicalSystem, featurizer::Function,
    clusterconfig = ClusteringConfig(); kwargs...
)</code></pre><p>Initialize a <code>mapper</code> that maps initial conditions to attractors using the featurizing and clustering method of <sup class="footnote-reference"><a id="citeref-Stender2021" href="#footnote-Stender2021">[Stender2021]</a></sup>. See <a href="#Attractors.AttractorMapper"><code>AttractorMapper</code></a> for how to use the <code>mapper</code>.</p><p><code>featurizer</code> is a function that takes as an input an integrated trajectory <code>A::Dataset</code> and the corresponding time vector <code>t</code> and returns a <code>Vector{&lt;:Real}</code> of features describing the trajectory. See <a href="#Attractors.ClusteringConfig"><code>ClusteringConfig</code></a> for configuring the clustering process.</p><p><strong>Keyword arguments</strong></p><ul><li><code>T=100, Ttr=100, Δt=1, diffeq=NamedTuple()</code>: Propagated to <a href="@ref"><code>trajectory</code></a>.</li></ul><p><strong>Description</strong></p><p>The trajectory <code>X</code> of each initial condition is transformed into a vector of features. Each feature is a number useful in <em>characterizing the attractor</em> the initial condition ends up at, and distinguishing it from other attrators. Example features are the mean or standard deviation of one of the of the timeseries of the trajectory, the entropy of some of the dimensions, the fractal dimension of <code>X</code>, or anything else you may fancy. The vectors of features are then used to identify to which attractor each trajectory belongs (i.e. in which basin of attractor each initial condition is in). The method thus relies on the user having at least some basic idea about what attractors to expect in order to pick the right features, in contrast to <a href="#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a>.</p><p>Once the features are extracted, they are clustered using <a href="#Attractors.ClusteringConfig"><code>ClusteringConfig</code></a>, so see that docstring for more details on the clustering. Each cluster is considered one attractor.</p><p>If <code>templates</code> are provided to <a href="#Attractors.ClusteringConfig"><code>ClusteringConfig</code></a>, then a supervised version is used, and the functionality is similar to <a href="#Attractors.AttractorsViaProximity"><code>AttractorsViaProximity</code></a>. Generally speaking, the <a href="#Attractors.AttractorsViaProximity"><code>AttractorsViaProximity</code></a> is superior. However, if the dynamical system has extremely high-dimensionality, there may be reasons to use the supervised method of this featurizing algorithm instead, as it projects the trajectories into a much lower dimensional representation of features.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/063a56bc4363961cc5bd83c7538d62cebf63582d/src/mapping/attractor_mapping_featurizing.jl#L20-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Attractors.ClusteringConfig" href="#Attractors.ClusteringConfig"><code>Attractors.ClusteringConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ClusteringConfig(; kwargs...)</code></pre><p>Initialize a struct that contains information used to cluster &quot;features&quot;. These features are typically extracted from trajectories/datasets in <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a>, or manualy by the user.</p><p>The clustering is done in the function <a href="#Attractors.cluster_features"><code>cluster_features</code></a>.</p><p>The default clustering method is an improvement over existing literature, see Description.</p><p><strong>Keyword arguments</strong></p><ul><li><code>clust_distance_metric = Euclidean()</code>: metric to be used in the clustering. Used in both versions.</li></ul><p><strong>Supervised method</strong></p><ul><li><code>templates = nothing</code>: Enables supervised version, see below. If given (i.e. different than <code>nothing</code>), <code>templates</code> must be a <code>Dict</code> of cluster labels to cluster features. The labels must be of <code>Int</code> type, and the features are <code>Vector</code>s representing a cluster (which can be an attractor, for instance). The label <code>-1</code> is reserved for invalid trajectories, which either diverge or whose clustering failed.</li><li><code>max_distance_template = Inf</code>: Maximum allowed distance between a feature and its nearest template for it to be assigned to that template. By default, <code>Inf</code> guarantees that a feature is assigned to its nearest template regardless of the distance.</li></ul><p><strong>Unsupervised method</strong></p><ul><li><code>rescale_features = true</code>: if true, rescale each dimension of the extracted features separately into the range <code>[0,1]</code>. This typically leads to more accurate clustering.</li><li><code>min_neighbors = 10</code>: minimum number of neighbors (i.e. of similar features) each feature needs to have in order to be considered in a cluster (fewer than this, it is labeled as an outlier, <code>-1</code>).</li><li><code>optimal_radius_method::Union{Real, String} = &quot;silhouettes_optim&quot;</code>: if a real number, it is the radius used to cluster features in the unsupervised method. Otherwise, it determines the method used to automatically determine that radius. Possible values are:<ul><li><code>&quot;silhouettes&quot;</code>: Performs a linear (sequential) search for the radius that maximizes a statistic of the silhouette values of clusters (typically the mean). This can be chosen with <code>silhouette_statistic</code>. The linear search may take some time to finish. To increase speed, the number of radii iterated through can be reduced by decreasing <code>num_attempts_radius</code> (see its entry below).</li><li><code>&quot;silhouettes_optim&quot;</code>: Same as <code>&quot;silhouettes&quot;</code> but performs an optimized search via Optim.jl. It&#39;s faster than <code>&quot;silhouettes&quot;</code>, with typically the same accuracy (the search here is not guaranteed to always find the global maximum, though it typically gets close).</li><li><code>&quot;knee&quot;</code>: chooses the the radius according to the knee (a.k.a. elbow, highest-derivative method) and is quicker, though generally leading to much worse clustering. It requires that <code>min_neighbors</code> &gt; 1.</li></ul></li></ul><p><strong>Keywords for optimal radius estimation</strong></p><ul><li><code>num_attempts_radius = 100</code>: number of radii that the <code>optimal_radius_method</code> will try out in its iterative procedure. Higher values increase the accuracy of clustering, though not necessarily much, while always reducing speed.</li><li><code>silhouette_statistic::Function = mean</code>: statistic (e.g. mean or minimum) of the silhouettes that is maximized in the &quot;optimal&quot; clustering. The original implementation in <sup class="footnote-reference"><a id="citeref-Stender2021" href="#footnote-Stender2021">[Stender2021]</a></sup> used the <code>minimum</code> of the silhouettes, and typically performs less accurately than the <code>mean</code>.</li><li><code>max_used_features = 0</code>: if not <code>0</code>, it should be an <code>Int</code> denoting the max amount of features to be used when finding the optimal radius. Useful when clustering a very large number of features (e.g., high accuracy estimation of fractions of basins of attraction).</li></ul><p><strong>Description</strong></p><p>The trajectory <code>X</code>, which may for instance be an attractor, is transformed into a vector of features. Each feature is a number useful in <em>characterizing the attractor</em>, and distinguishing it from other attrators. Example features are the mean or standard deviation of one of the of the timeseries of the trajectory, the entropy of the first two dimensions, the fractal dimension of <code>X</code>, or anything else you may fancy. The vectors of features are then used to identify clusters of the trajectories. An application thus is to cluster attractors. Currently two methods are offered to achieve this.</p><p><strong>Unsupervised method</strong></p><p>The <strong>unsupervised method</strong> does not rely on templates, and instead uses the DBSCAN clustering algorithm to automatically identify clusters of similar features. To achieve this, each feature is considered a point in feature space. Each cluster then basically groups points that are closely packed together. Closely packed means that the points have at least <code>min_neighbors</code> inside a ball of radius <code>optimal_radius</code> centered on them. This method typically works well if the radius is chosen well, which is not necessarily an easy task. Currently, three methods are implemented to automatically estimate an &quot;optimal&quot; radius.</p><p><strong>Estimating the optimal radius</strong></p><p>The default method is the <strong>silhouettes method</strong>, which includes keywords <code>silhouette</code> and <code>silhouette_optim</code>. Both of them search for the radius that optimizes the clustering, meaning the one that maximizes a statistic <code>silhouette_statistic</code> (e.g. mean value) of a quantifier for the quality of each cluster. This quantifier is the silhouette value of each identified cluster. A silhouette value measures how similar a point is to the cluster it currently belongs to, compared to the other clusters, and ranges from -1 (worst matching) to +1 (ideal matching). If only one cluster is found, the assigned silhouette is</p><ol><li>So for each attempted radius in the search the clusters are computed, their silhouettes</li></ol><p>calculated, and the statistic of these silhouettes computed. The algorithm then finds the radius that leads to the maximum such statistic. For <code>optimal_radius_method = &quot;silhouettes&quot;</code>, the search is done linearly, from a minimum to a maximum candidate radius for <code>optimal_radius_method = &quot;silhouettes&quot;</code>; <code>optimal_radius_method = silhouettes_optim</code>, it is done via an optimized search performed by Optim.jl which is typically faster and with similar accuracy. A third alternative is the<code>&quot;elbow&quot;</code> method, which works by calculating the distance of each point to its k-nearest-neighbors (with <code>k=min_neighbors</code>) and finding the distance corresponding to the highest derivative in the curve of the distances, sorted in ascending order. This distance is chosen as the optimal radius. It is described in <sup class="footnote-reference"><a id="citeref-Kriegel1996" href="#footnote-Kriegel1996">[Kriegel1996]</a></sup> and <sup class="footnote-reference"><a id="citeref-Schubert2017" href="#footnote-Schubert2017">[Schubert2017]</a></sup>. It typically performs considerably worse than the <code>&quot;silhouette&quot;</code> methods.</p><p><strong>Supervised method</strong></p><p>In the alternative, <strong>supervised version</strong>, the user provides features to be used as templates guiding the clustering via the <code>templates</code> keyword. Features are clustered to their nearest template if the distance to that template is below or equal to the threshold <code>max_distance_template</code>. The distances are computed via the metric defined by <code>clust_distance_metric</code>. So the algorithm first finds the template nearest to each feature (in that metric) via the <code>k</code>-nearest-neighbors algorithm for <code>k=1</code> and then compares their distance to the threshold. If the distance is below or equal to the threshold, the feature is assigned the template&#39;s label, which is given in <code>templates</code>. If the distance is larger, the feature is assigned label <code>-1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/063a56bc4363961cc5bd83c7538d62cebf63582d/src/mapping/clustering/cluster_config.jl#L4-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Attractors.cluster_features" href="#Attractors.cluster_features"><code>Attractors.cluster_features</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cluster_features(features, cc::ClusteringConfig)</code></pre><p>Cluster the given <code>features::Vector{&lt;:AbstractVector}</code>, according to given <a href="#Attractors.ClusteringConfig"><code>ClusteringConfig</code></a>. Return <code>cluster_labels</code>, which contains, for each feature, the labels (indices) of the corresponding cluster.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/063a56bc4363961cc5bd83c7538d62cebf63582d/src/mapping/clustering/cluster_config.jl#L150-L155">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Datseris2022"><a class="tag is-link" href="#citeref-Datseris2022">Datseris2022</a>G. Datseris and A. Wagemakers, <em>Effortless estimation of basins of attraction</em>, <a href="https://doi.org/10.1063/5.0076568">Chaos 32, 023104 (2022)</a></li><li class="footnote" id="footnote-Stender2021"><a class="tag is-link" href="#citeref-Stender2021">Stender2021</a>Stender &amp; Hoffmann, <a href="https://doi.org/10.1007/s11071-021-06786-5">bSTAB: an open-source software for computing the basin stability of multi-stable dynamical systems</a></li><li class="footnote" id="footnote-Stender2021"><a class="tag is-link" href="#citeref-Stender2021">Stender2021</a>Stender &amp; Hoffmann, <a href="https://doi.org/10.1007/s11071-021-06786-5">bSTAB: an open-source software for computing the basin stability of multi-stable dynamical systems</a></li><li class="footnote" id="footnote-Kriegel1996"><a class="tag is-link" href="#citeref-Kriegel1996">Kriegel1996</a>Ester, Kriegel, Sander and Xu: A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise</li><li class="footnote" id="footnote-Schubert2017"><a class="tag is-link" href="#citeref-Schubert2017">Schubert2017</a>Schubert, Sander, Ester, Kriegel and Xu: DBSCAN Revisited, Revisited: Why and How You Should (Still) Use DBSCAN</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Attractors.jl</a><a class="docs-footer-nextpage" href="../basins/">Basins of Attraction »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Wednesday 2 November 2022 12:30">Wednesday 2 November 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
