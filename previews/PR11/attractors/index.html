<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Finding Attractors · Entropies.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Entropies.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Attractors.jl</a></li><li class="is-active"><a class="tocitem" href>Finding Attractors</a><ul class="internal"><li><a class="tocitem" href="#Proximity"><span>Proximity</span></a></li><li><a class="tocitem" href="#Recurrences"><span>Recurrences</span></a></li><li><a class="tocitem" href="#Featurizing"><span>Featurizing</span></a></li></ul></li><li><a class="tocitem" href="../basins/">Basins of Attraction</a></li><li><a class="tocitem" href="../continuation/">Attractor &amp; Basins Continuation</a></li><li><a class="tocitem" href="../examples/">Examples for Attractors.jl</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Finding Attractors</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Finding Attractors</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/Attractors.jl/blob/main/docs/src/attractors.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Finding-Attractors"><a class="docs-heading-anchor" href="#Finding-Attractors">Finding Attractors</a><a id="Finding-Attractors-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-Attractors" title="Permalink"></a></h1><p>Attractors.jl defines a generic interface for finding attractors of dynamical systems. One first decides the instance of <a href="@ref"><code>GeneralizedDynamicalSystem</code></a> they need. Then, an instance of <a href="#Attractors.AttractorMapper"><code>AttractorMapper</code></a> is created from this dynamical system. This <code>mapper</code> instance can be used to compute e.g., <a href="../basins/#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>, and the output can be further analyzed to get e.g., the <a href="../basins/#Attractors.basin_entropy"><code>basin_entropy</code></a>.</p><p>The example <a href="../examples/#D-basins-of-4D-system">2D basins of 4D system</a> contains most of the functionality documented in this page.</p><article class="docstring"><header><a class="docstring-binding" id="Attractors.AttractorMapper" href="#Attractors.AttractorMapper"><code>Attractors.AttractorMapper</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AttractorMapper(ds::GeneralizedDynamicalSystem, args...; kwargs...) → mapper</code></pre><p>Subtypes of <code>AttractorMapper</code> are structures that map initial conditions of <code>ds</code> to attractors. Currently available mapping methods:</p><ul><li><a href="#Attractors.AttractorsViaProximity"><code>AttractorsViaProximity</code></a></li><li><a href="#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a></li><li><a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a></li></ul><p>All <code>AttractorMapper</code> subtypes can be used with <a href="../basins/#Attractors.basins_fractions"><code>basins_fractions</code></a> or <a href="../basins/#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>.</p><p>In addition, some mappers can be called as a function of an initial condition:</p><pre><code class="language-julia hljs">label = mapper(u0)</code></pre><p>and this will on the fly compute and return the label of the attractor <code>u0</code> converges at. The mappers that can do this are:</p><ul><li><a href="#Attractors.AttractorsViaProximity"><code>AttractorsViaProximity</code></a></li><li><a href="#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/a283dfb5b525ab2292e25edda57f544c555b5ef7/src/mapping/attractor_mapping.jl#L17-L36">source</a></section></article><h2 id="Proximity"><a class="docs-heading-anchor" href="#Proximity">Proximity</a><a id="Proximity-1"></a><a class="docs-heading-anchor-permalink" href="#Proximity" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Attractors.AttractorsViaProximity" href="#Attractors.AttractorsViaProximity"><code>Attractors.AttractorsViaProximity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AttractorsViaProximity(ds::DynamicalSystem, attractors::Dict [, ε]; kwargs...)</code></pre><p>Map initial conditions to attractors based on whether the trajectory reaches <code>ε</code>-distance close to any of the user-provided <code>attractors</code>. They have to be in a form of a dictionary mapping attractor labels to <code>Dataset</code>s containing the attractors.</p><p>The system gets stepped, and at each step the minimum distance to all attractors is computed. If any of these distances is <code>&lt; ε</code>, then the label of the nearest attractor is returned.</p><p>If an <code>ε::Real</code> is <em>not</em> provided by the user, a value is computed automatically as half of the minimum distance between all attractors. This operation can be expensive for large attractor datasets. If <code>length(attractors) == 1</code>, then <code>ε</code> becomes 1/10 of the diagonal of the box containing the attractor. If <code>length(attractors) == 1</code> and the attractor is a single point, an error is thrown.</p><p>Because in this method the attractors are already known to the user, the method can also be called <em>supervised</em>.</p><p><strong>Keywords</strong></p><ul><li><code>Ttr = 100</code>: Transient time to first evolve the system for before checking for proximity.</li><li><code>Δt = 1</code>: Integration step time (only valid for continuous systems).</li><li><code>horizon_limit = 1e3</code>: If the maximum distance of the trajectory from any of the given attractors exceeds this limit, it is assumed that the trajectory diverged (gets labelled as <code>-1</code>).</li><li><code>mx_chk_lost = 1000</code>: If the integrator has been stepped this many times without coming <code>ε</code>-near to any attractor,  it is assumed that the trajectory diverged (gets labelled as <code>-1</code>).</li><li><code>diffeq = NamedTuple()</code>: Keywords propagated to DifferentialEquations.jl (only valid for continuous systems).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/a283dfb5b525ab2292e25edda57f544c555b5ef7/src/mapping/attractor_mapping_proximity.jl#L1-L32">source</a></section></article><h2 id="Recurrences"><a class="docs-heading-anchor" href="#Recurrences">Recurrences</a><a id="Recurrences-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrences" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Attractors.AttractorsViaRecurrences" href="#Attractors.AttractorsViaRecurrences"><code>Attractors.AttractorsViaRecurrences</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AttractorsViaRecurrences(ds::GeneralizedDynamicalSystem, grid::Tuple; kwargs...)</code></pre><p>Map initial conditions to attractors by identifying attractors on the fly based on recurrences in the state space, as outlined by Datseris &amp; Wagemakers<sup class="footnote-reference"><a id="citeref-Datseris2022" href="#footnote-Datseris2022">[Datseris2022]</a></sup>. Works for any case encapsulated by <a href="@ref"><code>GeneralizedDynamicalSystem</code></a>. The version <a href="#Attractors.AttractorsViaRecurrencesSparse"><code>AttractorsViaRecurrencesSparse</code></a> should practically always be preferred over this one.</p><p><code>grid</code> is a tuple of ranges partitioning the state space so that a finite state machine can operate on top of it. For example <code>grid = (xg, yg)</code> where <code>xg = yg = range(-5, 5; length = 100)</code> for a two-dimensional system. The grid has to be the same dimensionality as the state space, use a <a href="@ref"><code>projected_integrator</code></a> if you want to search for attractors in a lower dimensional subspace.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>Δt</code>: Approximate time step of the integrator, which is <code>1</code> for discrete systems. For continuous systems, an automatic value is calculated using <a href="#Attractors.automatic_Δt_basins"><code>automatic_Δt_basins</code></a>.</li><li><code>Ttr = 0</code>: This keyword arguments allows to skip a transient before the recurrence routine begins. It is useful for some high dimensional systems to speed up the convergence to the attractor.</li><li><code>diffeq = NamedTuple()</code>: Keyword arguments propagated to <a href="@ref"><code>integrator</code></a>. Only valid for <code>ContinuousDynamicalSystem</code>. It is recommended to choose high accuracy solvers for this application, e.g. <code>diffeq = (alg=Vern9(), reltol=1e-9, abstol=1e-9)</code>.</li><li><code>mx_chk_att = 2</code>: A parameter that sets the maximum checks of consecutives hits of an attractor before deciding the basin of the initial condition.</li><li><code>mx_chk_hit_bas = 10</code>: Maximum check of consecutive visits of the same basin of attraction. This number can be increased for higher accuracy.</li><li><code>mx_chk_fnd_att = 100</code>: Maximum check of unnumbered cell before considering we have an attractor. This number can be increased for higher accuracy.</li><li><code>mx_chk_loc_att = 100</code>: Maximum check of consecutive cells marked as an attractor before considering that we have all the available pieces of the attractor.</li><li><code>mx_chk_lost = 20</code>: Maximum check of iterations outside the defined grid before we consider the orbit lost outside. This number can be increased for higher accuracy.</li><li><code>horizon_limit = 1e6</code>: If the norm of the integrator state reaches this limit we consider that the orbit diverges.</li><li><code>safety_counter_max = Int(1e6)</code>: A safety counter that is always increasing for each initial condition. Once exceeded, the algorithm assigns <code>-1</code> and throws a warning. This clause exists to stop the algorithm never haulting for innappropriately defined grids, where a found attractor may intersect in the same cell with a new attractor the orbit traces (which leads to infinite resetting of all counters). As this check comes with a performance deficit, the keyword <code>unsafe=true</code> can be set to disable it in case the user is confident the algorithm will hault.</li></ul><p><strong>Description</strong></p><p>An initial condition given to an instance of <code>AttractorsViaRecurrences</code> is iterated based on the integrator corresponding to <code>ds</code>. A recurrence in the state space means that the trajectory has converged to an attractor. This is the basis for finding attractors.</p><p>A finite state machine (FSM) follows the trajectory in the state space, and constantly maps it to the given <code>grid</code>. The FSM decides when an initial condition has successfully converged into an attractor. An array, internally called &quot;basins&quot;, stores the state of the FSM on the grid, according to the indexing system described in <sup class="footnote-reference"><a id="citeref-Datseris2022" href="#footnote-Datseris2022">[Datseris2022]</a></sup>. As the system is integrated more and more, the information of the &quot;basins&quot; becomes richer and richer with more identified attractors or with grid cells that belong to basins of already found attractors. Notice that only in the special method <code>basins_of_attraction(mapper::AttractorsViaRecurrences)</code> the information of the attraction or exit basins is utilized. In other functions like <code>basins_fractions</code> only the attractor locations are utilized.</p><p>The iteration of a given initial condition continues until one of the following happens:</p><ol><li>The trajectory hits <code>mx_chk_fnd_att</code> times in a row grid cells previously visited: it is considered that an attractor is found and is labelled with a new number.</li><li>The trajectory hits an already identified attractor <code>mx_chk_att</code> consecutive times: the initial condition is numbered with the attractor&#39;s number.</li><li>The trajectory hits a known basin <code>mx_chk_hit_bas</code> times in a row: the initial condition belongs to that basin and is numbered accordingly.</li><li>The trajectory spends <code>mx_chk_lost</code> steps outside the defined grid or the norm of the integrator state becomes &gt; than <code>horizon_limit</code>: the initial condition is set to -1.</li><li>If none of the above happens and <code>unsafe=true</code>, the algorithm will error.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/a283dfb5b525ab2292e25edda57f544c555b5ef7/src/mapping/attractor_mapping_recurrences.jl#L5-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Attractors.AttractorsViaRecurrencesSparse" href="#Attractors.AttractorsViaRecurrencesSparse"><code>Attractors.AttractorsViaRecurrencesSparse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">AttractorsViaRecurrencesSparse(ds::GeneralizedDynamicalSystem, grid::Tuple; kwargs...)</code></pre><p>This version is practically identical to <a href="#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a>, with the difference that the internal representation of the grid uses a sparse array. In practice, it should always be preferred when searching for <a href="../basins/#Attractors.basins_fractions"><code>basins_fractions</code></a>. Only for very low dimensional systems and for computing the full <a href="../basins/#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a> the non-sparse version should be used.</p><p>See the docstring of <a href="#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a> for possible keywords and details on the algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/a283dfb5b525ab2292e25edda57f544c555b5ef7/src/mapping/attractor_mapping_recurrences.jl#L98-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Attractors.automatic_Δt_basins" href="#Attractors.automatic_Δt_basins"><code>Attractors.automatic_Δt_basins</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">automatic_Δt_basins(integ, grid; N = 5000) → Δt</code></pre><p>Calculate an optimal <code>Δt</code> value for <a href="../basins/#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>. This is done by evaluating the dynamic rule <code>f</code> (vector field) at <code>N</code> randomly chosen points of the grid. The average <code>f</code> is then compared with the diagonal length of a grid cell and their ratio provides <code>Δt</code>.</p><p>Notice that <code>Δt</code> should not be too small which happens typically if the grid resolution is high. It is okay for <a href="../basins/#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a> if the trajectory skips a few cells. But if <code>Δt</code> is too small the default values for all other keywords such as <code>mx_chk_hit_bas</code> need to be increased drastically.</p><p>Also, <code>Δt</code> that is smaller than the internal step size of the integrator will cause a performance drop.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/a283dfb5b525ab2292e25edda57f544c555b5ef7/src/mapping/attractor_mapping_recurrences.jl#L249-L263">source</a></section></article><h2 id="Featurizing"><a class="docs-heading-anchor" href="#Featurizing">Featurizing</a><a id="Featurizing-1"></a><a class="docs-heading-anchor-permalink" href="#Featurizing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Attractors.AttractorsViaFeaturizing" href="#Attractors.AttractorsViaFeaturizing"><code>Attractors.AttractorsViaFeaturizing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AttractorsViaFeaturizing(
    ds::DynamicalSystem, featurizer::Function,
    clusterconfig = ClusteringConfig(); kwargs...
)</code></pre><p>Initialize a <code>mapper</code> that maps initial conditions to attractors using the featurizing and clustering method of <sup class="footnote-reference"><a id="citeref-Stender2021" href="#footnote-Stender2021">[Stender2021]</a></sup>. See <a href="#Attractors.AttractorMapper"><code>AttractorMapper</code></a> for how to use the <code>mapper</code>.</p><p><code>featurizer</code> is a function that takes as an input an integrated trajectory <code>A::Dataset</code> and the corresponding time vector <code>t</code> and returns a <code>Vector{&lt;:Real}</code> of features describing the trajectory. See <a href="#Attractors.ClusteringConfig"><code>ClusteringConfig</code></a> for configuring the clustering process.</p><p><strong>Keyword arguments</strong></p><ul><li><code>T=100, Ttr=100, Δt=1, diffeq=NamedTuple()</code>: Propagated to <a href="@ref"><code>trajectory</code></a>.</li></ul><p><strong>Description</strong></p><p>The trajectory <code>X</code> of each initial condition is transformed into a vector of features. Each feature is a number useful in <em>characterizing the attractor</em> the initial condition ends up at, and distinguishing it from other attrators. Example features are the mean or standard deviation of one of the of the timeseries of the trajectory, the entropy of some of the dimensions, the fractal dimension of <code>X</code>, or anything else you may fancy. The vectors of features are then used to identify to which attractor each trajectory belongs (i.e. in which basin of attractor each initial condition is in). The method thus relies on the user having at least some basic idea about what attractors to expect in order to pick the right features, in contrast to <a href="#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a>.</p><p>Once the features are extracted, they are clustered using <a href="#Attractors.ClusteringConfig"><code>ClusteringConfig</code></a>, so see that docstring for more details on the clustering. Each cluster is considered one attractor.</p><p>If <code>templates</code> are provided to <a href="#Attractors.ClusteringConfig"><code>ClusteringConfig</code></a>, then a supervised version is used, and the functionality is similar to <a href="#Attractors.AttractorsViaProximity"><code>AttractorsViaProximity</code></a>. Generally speaking, the <a href="#Attractors.AttractorsViaProximity"><code>AttractorsViaProximity</code></a> is superior. However, if the dynamical system has extremely high-dimensionality, there may be reasons to use the supervised method of this featurizing algorithm instead, as it projects the trajectories into a much lower dimensional representation of features.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/a283dfb5b525ab2292e25edda57f544c555b5ef7/src/mapping/attractor_mapping_featurizing.jl#L21-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Attractors.ClusteringConfig" href="#Attractors.ClusteringConfig"><code>Attractors.ClusteringConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ClusteringConfig(; kwargs...)</code></pre><p>Initialize a struct that contains information used to cluster &quot;features&quot;. These features are typically extracted from trajectories/datasets in <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a>, or manualy by the user.</p><p>The clustering is done in the function <a href="#Attractors.cluster_features"><code>cluster_features</code></a>.</p><p>The default clustering method is an improvement over existing literature, see Description.</p><p><strong>Keyword arguments</strong></p><ul><li><code>templates = nothing</code>: Enables supervised version, see below. If given, must be a <code>Dict</code> of cluster labels to cluster features. The labels must be of <code>Int</code> type, and the features are <code>Vector</code>s representing a cluster (which can be an attractor, for instance). The label <code>-1</code> is reserved for invalid trajectories, which either diverge or whose clustering failed.</li></ul><p><strong>Supervised method</strong></p><ul><li><code>clustering_threshold = 0.0</code>: Maximum allowed distance between a feature and the cluster center for it to be considered inside the cluster. Only used when <code>clust_method = &quot;kNN_thresholded&quot;</code>.</li><li><code>clust_method = clustering_threshold &gt; 0 ? &quot;kNN_thresholded&quot; : &quot;kNN&quot;</code>: (supervised method only) which clusterization method to apply. If <code>&quot;kNN&quot;</code>, the first-neighbor clustering is used. If <code>&quot;kNN_thresholded&quot;</code>, a subsequent step is taken, which considers as unclassified (label <code>-1</code>) the features whose distance to the nearest template is above the <code>clustering_threshold</code>.</li></ul><p><strong>Unsupervised method</strong></p><ul><li><code>rescale_features = true</code>: if true, rescale each dimension of the extracted features separately into the range <code>[0,1]</code>. This typically leads to more accurate clustering.</li><li><code>min_neighbors = 10</code>: (unsupervised method only) minimum number of neighbors (i.e. of similar features) each feature needs to have in order to be considered in a cluster (fewer than this, it is labeled as an outlier, <code>-1</code>).</li><li><code>clust_method_norm = Euclidean()</code>: metric to be used in the clustering.</li><li><code>optimal_radius_method::String = &quot;silhouettes_optim&quot;</code>: the method used to determine the optimal radius for clustering features in the unsupervised method. Possible values are:<ul><li><code>&quot;silhouettes&quot;</code>: Performs a linear (sequential) search for the radius that maximizes a statistic of the silhouette values of clusters (typically the mean). This can be chosen with <code>silhouette_statistic</code>. The linear search may take some time to finish. To increase speed, the number of radii iterated through can be reduced by decreasing <code>num_attempts_radius</code> (see its entry below).</li><li><code>&quot;silhouettes_optim&quot;</code>: Same as <code>&quot;silhouettes&quot;</code> but performs an optimized search via Optim.jl. It&#39;s faster than <code>&quot;silhouettes&quot;</code>, with typically the same accuracy (the search here is not guaranteed to always find the global maximum, though it typically gets close).</li><li><code>&quot;knee&quot;</code>: chooses the the radius according to the knee (a.k.a. elbow, highest-derivative method) and is quicker, though generally leading to much worse clustering. It requires that <code>min_neighbors</code> &gt; 1.</li></ul></li></ul><p><strong>Keywords for optimal radius estimation</strong></p><ul><li><code>num_attempts_radius = 100</code>: number of radii that the <code>optimal_radius_method</code> will try out in its iterative procedure. Higher values increase the accuracy of clustering, though not necessarily much, while always reducing speed.</li><li><code>silhouette_statistic::Function = mean</code>: statistic (e.g. mean or minimum) of the silhouettes that is maximized in the &quot;optimal&quot; clustering. The original implementation in <sup class="footnote-reference"><a id="citeref-Stender2021" href="#footnote-Stender2021">[Stender2021]</a></sup> used the <code>minimum</code> of the silhouettes, and typically performs less accurately than the <code>mean</code>.</li><li><code>max_used_features = 0</code>: if not <code>0</code>, it should be an <code>Int</code> denoting the max amount of features to be used when finding the optimal radius. Useful when clustering a very large number of features (e.g., high accuracy estimation of fractions of basins of attraction).</li></ul><p><strong>Description</strong></p><p>The trajectory <code>X</code>, which may for instance be an attractor, is transformed into a vector of features. Each feature is a number useful in <em>characterizing the attractor</em>, and distinguishing it from other attrators. Example features are the mean or standard deviation of one of the of the timeseries of the trajectory, the entropy of the first two dimensions, the fractal dimension of <code>X</code>, or anything else you may fancy. The vectors of features are then used to identify clusters of attractors.</p><p>There are two versions to do this. The <strong>unsupervised version</strong> does not rely on templates, and instead uses the DBSCAN clustering algorithm to identify clusters of similar features. To achieve this, each feature is considered a point in feature space. In this space, the algorithm basically groups points that are closely packed. To achieve this, a crucial parameter is a radius for  distance <code>ϵ</code> that determines the &quot;closeness&quot; of points in clusters.</p><p>Two methods are currently implemented to determine an <code>optimal_radius</code>, as described in <code>optimal_radius_method</code> above. The default method is based on the silhouette values of clusters. A silhouette value measures how similar a point is to the cluster it currently belongs, compared to the other clusters, and ranges from -1 (worst matching) to +1 (ideal matching). If only one cluster is found, the assigned silhouette is 0. The default method ,<code>silhouettes</code>, chooses the radius <code>ε</code> that maximizes the average silhouette across all clusters.  The alternative <code>elbow</code> method works by calculating the distance of each point to its k-nearest-neighbors (with <code>k=min_neighbors</code>) and finding the distance corresponding to the highest derivative in the curve of the distances, sorted in ascending order. This distance is chosen as the optimal radius. It is described in <sup class="footnote-reference"><a id="citeref-Kriegel1996" href="#footnote-Kriegel1996">[Kriegel1996]</a></sup> and <sup class="footnote-reference"><a id="citeref-Schubert2017" href="#footnote-Schubert2017">[Schubert2017]</a></sup>.</p><p>In the <strong>supervised version</strong>, the user provides features to be used as templates guiding the clustering via the <code>templates</code> keyword. Each feature is considered to belong to the &quot;cluster&quot; of the nearest template (based on the distance in feature space), and is labelled following the template&#39;s label, given in <code>templates</code>.</p><p>In both versions, features whose cluster is not identified are labeled as <code>-1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/a283dfb5b525ab2292e25edda57f544c555b5ef7/src/mapping/clustering/cluster_config.jl#L4-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Attractors.cluster_features" href="#Attractors.cluster_features"><code>Attractors.cluster_features</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cluster_features(features, cc::ClusteringConfig)</code></pre><p>Cluster the given <code>features::Vector{&lt;:AbstractVector}</code>, according to given <a href="#Attractors.ClusteringConfig"><code>ClusteringConfig</code></a>. Return <code>cluster_labels, cluster_errors</code>, which respectively contain, for each feature, the labels (indices) of the corresponding cluster and the error associated with that clustering. The error is the distance from the feature to (i) the cluster, in the supervised method or (ii) to the center of the cluster, in the unsupervised method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/a283dfb5b525ab2292e25edda57f544c555b5ef7/src/mapping/clustering/cluster_config.jl#L142-L150">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Datseris2022"><a class="tag is-link" href="#citeref-Datseris2022">Datseris2022</a>G. Datseris and A. Wagemakers, <em>Effortless estimation of basins of attraction</em>, <a href="https://doi.org/10.1063/5.0076568">Chaos 32, 023104 (2022)</a></li><li class="footnote" id="footnote-Stender2021"><a class="tag is-link" href="#citeref-Stender2021">Stender2021</a>Stender &amp; Hoffmann, <a href="https://doi.org/10.1007/s11071-021-06786-5">bSTAB: an open-source software for computing the basin stability of multi-stable dynamical systems</a></li><li class="footnote" id="footnote-Stender2021"><a class="tag is-link" href="#citeref-Stender2021">Stender2021</a>Stender &amp; Hoffmann, <a href="https://doi.org/10.1007/s11071-021-06786-5">bSTAB: an open-source software for computing the basin stability of multi-stable dynamical systems</a></li><li class="footnote" id="footnote-Kriegel1996"><a class="tag is-link" href="#citeref-Kriegel1996">Kriegel1996</a>Ester, Kriegel, Sander and Xu: A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise</li><li class="footnote" id="footnote-Schubert2017"><a class="tag is-link" href="#citeref-Schubert2017">Schubert2017</a>Schubert, Sander, Ester, Kriegel and Xu: DBSCAN Revisited, Revisited: Why and How You Should (Still) Use DBSCAN</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Attractors.jl</a><a class="docs-footer-nextpage" href="../basins/">Basins of Attraction »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 25 October 2022 11:20">Tuesday 25 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
