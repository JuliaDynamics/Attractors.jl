<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Attractors.jl Tutorial · Attractors.jl</title><meta name="title" content="Attractors.jl Tutorial · Attractors.jl"/><meta property="og:title" content="Attractors.jl Tutorial · Attractors.jl"/><meta property="twitter:title" content="Attractors.jl Tutorial · Attractors.jl"/><meta name="description" content="Documentation for Attractors.jl."/><meta property="og:description" content="Documentation for Attractors.jl."/><meta property="twitter:description" content="Documentation for Attractors.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Attractors.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Attractors.jl</a></li><li class="is-active"><a class="tocitem" href>Attractors.jl Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Input:-a-DynamicalSystem"><span>Input: a <code>DynamicalSystem</code></span></a></li><li><a class="tocitem" href="#Finding-attractors"><span>Finding attractors</span></a></li><li><a class="tocitem" href="#Global-continuation"><span>Global continuation</span></a></li><li><a class="tocitem" href="#Enhancing-the-continuation"><span>Enhancing the continuation</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../examples/">Examples for Attractors.jl</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Attractors.jl Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Attractors.jl Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Attractors.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Attractors.jl/blob/main/docs/src/tutorial.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="tutorial"><a class="docs-heading-anchor" href="#tutorial">Attractors.jl Tutorial</a><a id="tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial" title="Permalink"></a></h1><p><a href="../#Attractors"><code>Attractors</code></a> is a submodule of the <strong>DynamicalSystems.jl</strong> library. This tutorial will walk you through its main functionality. That is, given a <code>DynamicalSystem</code> instance, find all its attractors and their basins of attraction. Then, continue these attractors, and their stability properties, across a parameter value. It also offers various functions that compute nonlocal stability properties for an attractor, any of which can be used in the continuation to quantify stability.</p><p>Besides this main functionality, there are plenty of other stuff, like for example <a href="@ref"><code>edgestate</code></a> or <a href="../api/#Attractors.basins_fractal_dimension"><code>basins_fractal_dimension</code></a>, but we won&#39;t cover anything else in this introductory tutorial. See the <a href="@ref examples">examples</a> page instead.</p><h2 id="Input:-a-DynamicalSystem"><a class="docs-heading-anchor" href="#Input:-a-DynamicalSystem">Input: a <code>DynamicalSystem</code></a><a id="Input:-a-DynamicalSystem-1"></a><a class="docs-heading-anchor-permalink" href="#Input:-a-DynamicalSystem" title="Permalink"></a></h2><p>The key input for most functionality of Attractors.jl is an instance of a <code>DynamicalSystem</code>. If you don&#39;t know how to make a <code>DynamicalSystem</code>, you need to consult the main tutorial of the <a href="https://juliadynamics.github.io/DynamicalSystemsDocs.jl/dynamicalsystems/stable/tutorial/">DynamicalSystems.jl library</a>. For this tutorial we will use a modified Lorenz-like system with equations</p><p class="math-container">\[\begin{align*}
\dot{x} &amp; = y - x \\
\dot{y}  &amp;= -x*z + b*|z| \\
\dot{z}  &amp;= x*y - a \\
\end{align*}\]</p><p>which we define in code as</p><pre><code class="language-julia hljs">using Attractors # part of `DynamicalSystems`, so it re-exports functionality for making them!
using OrdinaryDiffEq # for accessing advanced ODE Solvers

function modified_lorenz_rule(u, p, t)
    x, y, z = u; a, b = p
    dx = y - x
    dy = - x*z + b*abs(z)
    dz = x*y - a
    return SVector(dx, dy, dz)
end

p0 = [5.0, 0.1] # parameters
u0 = [-4.0, 5, 0] # state
ds = CoupledODEs(modified_lorenz_rule, u0, p0;
    diffeq = (alg = Vern9(), abstol = 1e-9, reltol = 1e-9, dt = 0.01)
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-dimensional CoupledODEs
 deterministic: true
 discrete time: false
 in-place:      false
 dynamic rule:  modified_lorenz_rule
 ODE solver:    Vern9
 ODE kwargs:    (abstol = 1.0e-9, reltol = 1.0e-9, dt = 0.01)
 parameters:    [5.0, 0.1]
 time:          0.0
 state:         [-4.0, 5.0, 0.0]
</code></pre><h2 id="Finding-attractors"><a class="docs-heading-anchor" href="#Finding-attractors">Finding attractors</a><a id="Finding-attractors-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-attractors" title="Permalink"></a></h2><p>There are two major methods for finding attractors in dynamical systems. Explanation of how they work is in their respective docs.</p><ol><li><a href="../api/#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a>.</li><li><a href="../api/#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a>.</li></ol><p>You can consult (<a href="../references/#Datseris2023">Datseris <em>et al.</em>, 2023</a>) for a comparison between the two.</p><p>As far as the user is concerned, both algorithms are part of the same interface, and can be used in the same way. The interface is extendable as well, and works as follows.</p><p>First, we create an instance of such an &quot;attractor finding algorithm&quot;, which we call <code>AttractorMapper</code>. For example, <a href="../api/#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a> requires a tesselated grid of the state space to search for attractors in. It also allows the user to tune some meta parameters, but in our example they are already tuned for the dynamical system at hand. So we initialize</p><pre><code class="language-julia hljs">grid = (
    range(-10.0, 10.0; length = 100), # x
    range(-15.0, 15.0; length = 100), # y
    range(-15.0, 15.0; length = 100), # z
)

mapper = AttractorsViaRecurrences(ds, grid;
    consecutive_recurrences = 1000, attractor_locate_steps = 1000,
    consecutive_lost_steps = 100,
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AttractorsViaRecurrences
 system:      CoupledODEs
 grid:        (-10.0:0.20202020202020202:10.0, -15.0:0.30303030303030304:15.0, -15.0:0.30303030303030304:15.0)
 attractors:  Dict{Int64, StateSpaceSet{3, Float64}}()
</code></pre><p>This <code>mapper</code> can map any initial condition to the corresponding attractor ID, for example</p><pre><code class="language-julia hljs">mapper([-4.0, 5, 0])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><p>while</p><pre><code class="language-julia hljs">mapper([4.0, 2, 0])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2</code></pre><p>the fact that these two different initial conditions got assigned different IDs means that they converged to a different attractor. The attractors are stored in the mapper internally, to obtain them we use the function</p><pre><code class="language-julia hljs">attractors = extract_attractors(mapper)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Int64, StateSpaceSet{3, Float64}} with 2 entries:
  2 =&gt; 3-dimensional StateSpaceSet{Float64} with 207 points
  1 =&gt; 3-dimensional StateSpaceSet{Float64} with 781 points</code></pre><p>In Attractors.jl, all information regarding attractors is always a standard Julia <code>Dict</code>, which maps attractor IDs (positive integers) to the corresponding quantity. Here the quantity are the attractors themselves, represented as <code>StateSpaceSet</code>.</p><p>Let&#39;s visualize them</p><pre><code class="language-julia hljs">using CairoMakie
fig = Figure()
ax = Axis(fig[1,1]; title = &quot;bistable lorenz-like&quot;)
for (k, A) in attractors
    scatter!(ax, A[:, 1], A[:, 2]; label = &quot;ID = $(k)&quot;)
end
axislegend(ax; position = :lt)
fig</code></pre><img src="39edf7a3.png" alt="Example block output"/><p>In our example system we see that for the chosen parameters there are two coexisting attractors: a limit cycle and a chaotic attractor. There may be more attractors though! We&#39;ve only checked two initial conditions, so we could have found at most two attractors! However, it can get tedious to manually iterate over initial conditions, which is why this <code>mapper</code> is typically given to higher level functions for finding attractors and their basins of attraction. The simplest one is <a href="../api/#Attractors.basins_fractions"><code>basins_fractions</code></a>. Using the <code>mapper</code>, it finds &quot;all&quot; attractors of the dynamical system and reports the state space fraction each attractors attracts. The search is probabilistic, so &quot;all&quot; attractors means those that at least one initial condition converged to.</p><p>We can provide explicitly initial conditions to <a href="@ref"><code>basins_fraction</code></a>, however it is typically simpler to provide it with with a state space sampler instead: a function that generates random initial conditions in the region of the state space that we are interested in. Here this region coincides with <code>grid</code>, so we can simply do:</p><pre><code class="language-julia hljs">sampler, = statespace_sampler(grid)

sampler() # random i.c.</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float64}:
  4.260137019398787
 14.869649799006243
  2.312897970562407</code></pre><pre><code class="language-julia hljs">sampler() # another random i.c.</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float64}:
 -5.225237905512383
 14.509868712065654
 -4.418197973501892</code></pre><p>and finally call</p><pre><code class="language-julia hljs">fs = basins_fractions(mapper, sampler)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Int64, Float64} with 2 entries:
  2 =&gt; 0.316
  1 =&gt; 0.684</code></pre><p>The returned <code>fs</code> is a dictionary mapping each attractor ID to the fraction of the state space the corresponding basin occupies. With this we can confirm that there are (likely) only two attractors and that both attractors are robust as both have sufficiently large basin fractions.</p><p>To obtain the full basins, which is computationally much more expensive, use <a href="../api/#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>.</p><p>You can use alternative algorithms in <a href="../api/#Attractors.basins_fractions"><code>basins_fractions</code></a>, see the documentation of <a href="../api/#Attractors.AttractorMapper"><code>AttractorMapper</code></a> for possible subtypes. <a href="../api/#Attractors.AttractorMapper"><code>AttractorMapper</code></a> defines an extendable interface and can be enriched with other methods in the future!</p><h2 id="Global-continuation"><a class="docs-heading-anchor" href="#Global-continuation">Global continuation</a><a id="Global-continuation-1"></a><a class="docs-heading-anchor-permalink" href="#Global-continuation" title="Permalink"></a></h2><p>If you have heard before the word &quot;continuation&quot;, then you are likely aware of the <strong>traditional continuation-based bifurcation analysis (CBA)</strong> offered by many software, such as AUTO, MatCont, and in Julia <a href="https://github.com/bifurcationkit/BifurcationKit.jl">BifurcationKit.jl</a>. Here we offer a completely different kind of continuation called <strong>global continuation</strong>.</p><p>A direct comparison of the two approaches is not truly possible, because they do different things. The traditional continuation analysis continues the curves of individual fixed points across the joint state-parameter space and tracks their <em>local (linear) stability</em>. The global continuation in Attractors.jl finds all attractors, including chaotic ones, in the whole of the state space (that it searches in), and continues all of these attractors concurrently along a parameter axis. Additionally, this global continuation tracks a <em>nonlocal</em> stability property which by default is the basin fraction.</p><p>This is a fundamental difference. Because all attractors are simultaneously tracked across the parameter axis, the user may arbitrarily estimate <em>any</em> property of the attractors and how it varies as the parameter varies. A more detailed comparison between these two approaches can be found in (<a href="../references/#Datseris2023">Datseris <em>et al.</em>, 2023</a>).</p><p>To perform the continuation is extremely simple. First, we decide what parameter, and what range, to continue over:</p><pre><code class="language-julia hljs">prange = 4.7:0.02:6
pidx = 1 # index of the parameter</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><p>Then, we may call the <a href="../api/#Attractors.global_continuation"><code>global_continuation</code></a> function. We have to provide a continuation algorithm, which itself references an <a href="../api/#Attractors.AttractorMapper"><code>AttractorMapper</code></a>. In this example we will re-use the <code>mapper</code> to create a <a href="../api/#Attractors.RecurrencesFindAndMatch"><code>RecurrencesFindAndMatch</code></a> continuation algorithm. This algorithm uses the <code>mapper</code> to find all attractors at each parameter value. Then, it performs a &quot;matching&quot; step, ensuring a &quot;continuity&quot; of the attractor label across the parameter axis. You can read the docstring for more details, as this algorithm is quite sophisticated!</p><p>For now we can use all of its default options which are reliable most of the time</p><pre><code class="language-julia hljs">rafm = RecurrencesFindAndMatch(mapper)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AttractorSeedContinueMatch{AttractorsViaRecurrences{CoupledODEs{false, 3, OrdinaryDiffEq.ODEIntegrator{OrdinaryDiffEq.Vern9{typeof(OrdinaryDiffEq.trivial_limiter!), typeof(OrdinaryDiffEq.trivial_limiter!), Static.False}, false, SVector{3, Float64}, Nothing, Float64, Vector{Float64}, Float64, Float64, Float64, Float64, Vector{SVector{3, Float64}}, SciMLBase.ODESolution{Float64, 2, Vector{SVector{3, Float64}}, Nothing, Nothing, Vector{Float64}, Vector{Vector{SVector{3, Float64}}}, SciMLBase.ODEProblem{SVector{3, Float64}, Tuple{Float64, Float64}, false, Vector{Float64}, SciMLBase.ODEFunction{false, SciMLBase.AutoSpecialize, typeof(Main.modified_lorenz_rule), LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing, Nothing, Nothing, Nothing}, Base.Pairs{Symbol, Union{}, Tuple{}, @NamedTuple{}}, SciMLBase.StandardODEProblem}, OrdinaryDiffEq.Vern9{typeof(OrdinaryDiffEq.trivial_limiter!), typeof(OrdinaryDiffEq.trivial_limiter!), Static.False}, OrdinaryDiffEq.InterpolationData{SciMLBase.ODEFunction{false, SciMLBase.AutoSpecialize, typeof(Main.modified_lorenz_rule), LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing, Nothing, Nothing, Nothing}, Vector{SVector{3, Float64}}, Vector{Float64}, Vector{Vector{SVector{3, Float64}}}, Nothing, OrdinaryDiffEq.Vern9ConstantCache, Nothing}, SciMLBase.DEStats, Nothing, Nothing, Nothing}, SciMLBase.ODEFunction{false, SciMLBase.AutoSpecialize, typeof(Main.modified_lorenz_rule), LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing, Nothing, Nothing, Nothing}, OrdinaryDiffEq.Vern9ConstantCache, OrdinaryDiffEq.DEOptions{Float64, Float64, Float64, Float64, OrdinaryDiffEq.PIController{Rational{Int64}}, typeof(DiffEqBase.ODE_DEFAULT_NORM), typeof(LinearAlgebra.opnorm), Bool, SciMLBase.CallbackSet{Tuple{}, Tuple{}}, typeof(DiffEqBase.ODE_DEFAULT_ISOUTOFDOMAIN), typeof(DiffEqBase.ODE_DEFAULT_PROG_MESSAGE), typeof(DiffEqBase.ODE_DEFAULT_UNSTABLE_CHECK), DataStructures.BinaryHeap{Float64, DataStructures.FasterForward}, DataStructures.BinaryHeap{Float64, DataStructures.FasterForward}, Nothing, Nothing, Float64, Tuple{}, Tuple{}, Tuple{}}, SVector{3, Float64}, Float64, Nothing, OrdinaryDiffEq.DefaultInit, Nothing}, Vector{Float64}}, Attractors.BasinsInfo{3, Attractors.RegularGrid{3, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Float64, Float64, Attractors.SparseArray{Int64, 3}}, Attractors.RegularGrid{3, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Base.Pairs{Symbol, Int64, Tuple{Symbol, Symbol, Symbol}, @NamedTuple{consecutive_recurrences::Int64, attractor_locate_steps::Int64, consecutive_lost_steps::Int64}}}, MatchBySSSetDistance{Centroid{Euclidean}, Float64}, typeof(Attractors._default_seeding)}(AttractorsViaRecurrences
 system:      CoupledODEs
 grid:        (-10.0:0.20202020202020202:10.0, -15.0:0.30303030303030304:15.0, -15.0:0.30303030303030304:15.0)
 attractors:  Dict{Int64, StateSpaceSet{3, Float64}}(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 207 points, 1 =&gt; 3-dimensional StateSpaceSet{Float64} with 781 points)
, MatchBySSSetDistance{Centroid{Euclidean}, Float64}(Centroid{Euclidean}(Euclidean(0.0)), Inf, false), Attractors._default_seeding)</code></pre><p>and call</p><pre><code class="language-julia hljs">fractions_cont, attractors_cont = global_continuation(
	rafm, prange, pidx, sampler; samples_per_parameter = 1_000
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([Dict(1 =&gt; 1.0), Dict(1 =&gt; 1.0), Dict(1 =&gt; 1.0), Dict(1 =&gt; 1.0), Dict(1 =&gt; 1.0), Dict(1 =&gt; 1.0), Dict(1 =&gt; 1.0), Dict(1 =&gt; 1.0), Dict(1 =&gt; 1.0), Dict(1 =&gt; 1.0)  …  Dict(2 =&gt; 0.8711288711288712, 1 =&gt; 0.12887112887112886), Dict(2 =&gt; 0.8882235528942116, 1 =&gt; 0.11177644710578842), Dict(2 =&gt; 0.872255489021956, 1 =&gt; 0.1277445109780439), Dict(2 =&gt; 0.8902195608782435, 1 =&gt; 0.10978043912175649), Dict(2 =&gt; 0.906187624750499, 1 =&gt; 0.09381237524950099), Dict(2 =&gt; 1.0), Dict(2 =&gt; 1.0), Dict(2 =&gt; 1.0), Dict(2 =&gt; 1.0), Dict(2 =&gt; 1.0)], Dict{Int64, StateSpaceSet{3, Float64}}[Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 242 points), Dict(1 =&gt; 3-dimensional StateSpaceSet{Float64} with 402 points), Dict(1 =&gt; 3-dimensional StateSpaceSet{Float64} with 328 points), Dict(1 =&gt; 3-dimensional StateSpaceSet{Float64} with 343 points), Dict(1 =&gt; 3-dimensional StateSpaceSet{Float64} with 347 points), Dict(1 =&gt; 3-dimensional StateSpaceSet{Float64} with 355 points), Dict(1 =&gt; 3-dimensional StateSpaceSet{Float64} with 331 points), Dict(1 =&gt; 3-dimensional StateSpaceSet{Float64} with 334 points), Dict(1 =&gt; 3-dimensional StateSpaceSet{Float64} with 343 points), Dict(1 =&gt; 3-dimensional StateSpaceSet{Float64} with 342 points)  …  Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 401 points, 1 =&gt; 3-dimensional StateSpaceSet{Float64} with 526 points), Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 374 points, 1 =&gt; 3-dimensional StateSpaceSet{Float64} with 441 points), Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 389 points, 1 =&gt; 3-dimensional StateSpaceSet{Float64} with 403 points), Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 388 points, 1 =&gt; 3-dimensional StateSpaceSet{Float64} with 314 points), Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 363 points, 1 =&gt; 3-dimensional StateSpaceSet{Float64} with 317 points), Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 375 points), Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 341 points), Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 268 points), Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 245 points), Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 242 points)])</code></pre><p>the output is given as two vectors. Each vector is a dictionary mapping attractor IDs to their basin fractions, or their state space sets, respectively. Both vectors have the same size as the parameter range. For example, the attractors at the 34-th parameter value are:</p><pre><code class="language-julia hljs">attractors_cont[34]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Int64, StateSpaceSet{3, Float64}} with 2 entries:
  2 =&gt; 3-dimensional StateSpaceSet{Float64} with 545 points
  1 =&gt; 3-dimensional StateSpaceSet{Float64} with 218 points</code></pre><p>There is a fantastic convenience function for animating the attractors evolution, that utilizes things we have already defined:</p><pre><code class="language-julia hljs">animate_attractors_continuation(
    ds, attractors_cont, fractions_cont, prange, pidx;
);</code></pre><video width="auto" controls autoplay loop>
<source src="../attracont.mp4" type="video/mp4">
</video><p>Hah, how cool is that! The attractors pop in and out of existence like out of nowhere! It would be incredibly difficult to find these attractors in traditional continuation software where a rough estimate of the period is required! (It would also be too hard due to the presence of chaos for most of the parameter values, but that&#39;s another issue!)</p><p>Now typically a continuation is visualized in a 2D plot where the x axis is the parameter axis. We can do this with the convenience function:</p><pre><code class="language-julia hljs">fig = plot_basins_attractors_curves(
	fractions_cont, attractors_cont, A -&gt; minimum(A[:, 1]), prange,
)</code></pre><img src="b679f991.png" alt="Example block output"/><p>In the top panel are the basin fractions, by default plotted as stacked bars. Bottom panel is a visualization of the tracked attractors. The argument <code>A -&gt; minimum(A[:, 1])</code> is simply a function that maps an attractor into a real number for plotting. We can provide more functions to visualize other aspects of the attractors:</p><pre><code class="language-julia hljs">a2rs = [
    A -&gt; minimum(A[:, 1]),
    A -&gt; log(length(A)), # proxy for &quot;complexity&quot;
]

fig = plot_basins_attractors_curves(
	fractions_cont, attractors_cont, a2rs, prange; add_legend = false
)

ax1, ax2 = content.((fig[2,1], fig[3,1]))

ax1.ylabel = &quot;min(A₁)&quot;
ax2.ylabel = &quot;log(len(A))&quot;

fig</code></pre><img src="5556169a.png" alt="Example block output"/><h2 id="Enhancing-the-continuation"><a class="docs-heading-anchor" href="#Enhancing-the-continuation">Enhancing the continuation</a><a id="Enhancing-the-continuation-1"></a><a class="docs-heading-anchor-permalink" href="#Enhancing-the-continuation" title="Permalink"></a></h2><p>The biggest strength of Attractors.jl is that it is not an isolated software. It is part of <strong>DynamicalSystems.jl</strong>. Here, we will use the full power of <strong>DynamicalSystems.jl</strong> and enrich the above continuation with various other measures of nonlocal stability, in particular Lyapunov exponents and the minimal fatal shock.</p><p>First, let&#39;s estimate the maximum Lyapunov exponent (MLE) for all attractors, using the <code>lyapunovspectrum</code> function that comes from the ChaosTools.jl submodule.</p><pre><code class="language-julia hljs">using ChaosTools: lyapunov

lis = map(enumerate(prange)) do (i, p) # loop over parameters
    set_parameter!(ds, pidx, p) # important! We use the dynamical system!
    attractors = attractors_cont[i]
    Dict(k =&gt; lyapunov(ds, 2000.0; u0 = A[1]) for (k, A) in attractors)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">66-element Vector{Dict{Int64, Float64}}:
 Dict(2 =&gt; 0.0046660659784419104)
 Dict(1 =&gt; 0.000820958521638396)
 Dict(1 =&gt; 0.00012105297977773509)
 Dict(1 =&gt; 0.0005228889021645621)
 Dict(1 =&gt; 0.0007122832257267526)
 Dict(1 =&gt; 0.0011323996324031868)
 Dict(1 =&gt; -0.0001841333384637585)
 Dict(1 =&gt; 0.001046443209542662)
 Dict(1 =&gt; 0.00036066634000166023)
 Dict(1 =&gt; 0.0009698373504769237)
 ⋮
 Dict(2 =&gt; 0.0007203837180962439, 1 =&gt; 0.009593154378040897)
 Dict(2 =&gt; 0.0007377005984081465, 1 =&gt; -0.0017557280063368896)
 Dict(2 =&gt; 0.0009308317485278647, 1 =&gt; 0.0006876156997800471)
 Dict(2 =&gt; 0.00036876185166849924, 1 =&gt; -7.1385898911195185e-6)
 Dict(2 =&gt; 0.0006412268986589495)
 Dict(2 =&gt; 0.0014840392821047097)
 Dict(2 =&gt; 0.0013666265293786012)
 Dict(2 =&gt; 0.00027916992476203833)
 Dict(2 =&gt; 0.0001528482863680924)</code></pre><p>The above <code>map</code> loop may be intimidating if you are a beginner, but it is really just a shorter way to write a <code>for</code> loop for our example. We iterate over all parameters, and for each we first update the dynamical system with the correct parameter, and then extract the MLE for each attractor. <code>map</code> just means that we don&#39;t have to pre-allocate a new vector before the loop; it creates it for us.</p><p>We can visualize the LE with the other convenience function <a href="@ref"><code>plot_continuation_curves!</code></a>,</p><pre><code class="language-julia hljs">ax3 = Axis(fig[4, 1]; ylabel = &quot;MLE&quot;)
plot_continuation_curves!(ax3, lis, prange; add_legend = false)

fig</code></pre><img src="51423fc0.png" alt="Example block output"/><p>This reveals crucial information for tha attractors, whether they are chaotic or not, that we would otherwise obtain only by visualizing the system dynamics at every single parameter. The story we can see now is that the dynamics start with a limit cycle (0 Lyapunov exponent), go into bi-stability of chaos and limit cycle, then there is only one limit cycle again, and then a chaotic attractor appears again, for a second bistable regime.</p><p>The last piece of information to add is yet another measure of nonlocal stability: the minimal fatal shock (MFS), which is provided by <a href="../api/#Attractors.minimal_fatal_shock"><code>minimal_fatal_shock</code></a>. The code to estimate this is similar with the <code>map</code> block for the MLE. Here however we re-use the created <code>mapper</code>, but now we must not forget to reset it inbetween parameter increments:</p><pre><code class="language-julia hljs">using LinearAlgebra: norm
search_area = collect(extrema.(grid ./ 2)) # smaller search = faster results
search_algorithm = MFSBlackBoxOptim(max_steps = 1000, guess = ones(3))

mfss = map(enumerate(prange)) do (i, p)
    set_parameter!(ds, pidx, p)
    reset_mapper!(mapper) # reset so that we don&#39;t have to re-initialize
    # We need a special clause here: if there is only 1 attractor,
    # then there is no MFS. It is undefined. We set it to `NaN`,
    # which conveniently, will result to nothing being plotted by Makie.
    attractors = attractors_cont[i]
    if length(attractors) == 1
        return Dict(k =&gt; NaN for (k, A) in attractors)
    end
    # otherwise, compute the actual MFS from the first point of each attractor
    Dict(k =&gt;
        norm(minimal_fatal_shock(mapper, A[1], search_area, search_algorithm))
        for (k, A) in attractors
    )
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">66-element Vector{Dict{Int64, Float64}}:
 Dict(2 =&gt; NaN)
 Dict(1 =&gt; NaN)
 Dict(1 =&gt; NaN)
 Dict(1 =&gt; NaN)
 Dict(1 =&gt; NaN)
 Dict(1 =&gt; NaN)
 Dict(1 =&gt; NaN)
 Dict(1 =&gt; NaN)
 Dict(1 =&gt; NaN)
 Dict(1 =&gt; NaN)
 ⋮
 Dict(2 =&gt; 0.7862417776643129, 1 =&gt; 0.24609323266021074)
 Dict(2 =&gt; 0.9568274329023757, 1 =&gt; 0.4067421051053268)
 Dict(2 =&gt; 0.5062360710518748, 1 =&gt; 0.20346941670281654)
 Dict(2 =&gt; 0.7345073940782446, 1 =&gt; 0.5610450204077869)
 Dict(2 =&gt; NaN)
 Dict(2 =&gt; NaN)
 Dict(2 =&gt; NaN)
 Dict(2 =&gt; NaN)
 Dict(2 =&gt; NaN)</code></pre><p>In a real application we wouldn&#39;t use the first point of each attractor, as the first point is completely random on the attractor (at least, for the [<code>AttractorsViaRecurrences</code>] mapper we use here). We would do this by examining the whole <code>A</code> object in the above block instead of just using <code>A[1]</code>. But this is a tutorial so we don&#39;t care!</p><p>Right, so now we can visualize the MFS with the rest of the other quantities:</p><pre><code class="language-julia hljs">ax4 = Axis(fig[5, 1]; ylabel = &quot;MFS&quot;, xlabel = &quot;parameter&quot;)
plot_continuation_curves!(ax4, mfss, prange; add_legend = false)

# make the figure prettier
for ax in (ax1, ax2, ax3); hidexdecorations!(ax; grid = false); end
resize!(fig, 500, 600)
fig</code></pre><img src="5ee4c007.png" alt="Example block output"/><p>And that&#39;s the end of the tutorial! See the <a href="@ref examples">examples</a> for more runnable code, and see the <a href="../api/#API">API</a> for a list of all functions and algorithms!</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Attractors.jl</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Monday 1 July 2024 11:36">Monday 1 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
