var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"basins/#Basins-of-Attraction","page":"Basins of Attraction","title":"Basins of Attraction","text":"","category":"section"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"This page provides several functions related to the basins of attraction and their boundaries. It requires you to have first understood the Finding Attractors page.","category":"page"},{"location":"basins/#Basins-of-attraction","page":"Basins of Attraction","title":"Basins of attraction","text":"","category":"section"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"Calculating basins of attraction, or their state space fractions, can be done with the functions:","category":"page"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"basins_fractions\nbasins_of_attraction.","category":"page"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"basins_fractions\nextract_attractors\nbasins_of_attraction\nstatespace_sampler","category":"page"},{"location":"basins/#Attractors.basins_fractions","page":"Basins of Attraction","title":"Attractors.basins_fractions","text":"basins_fractions(\n    mapper::AttractorMapper,\n    ics::Union{StateSpaceSet, Function};\n    kwargs...\n)\n\nApproximate the state space fractions fs of the basins of attraction of a dynamical stystem by mapping initial conditions to attractors using mapper (which contains a reference to a DynamicalSystem). The fractions are simply the ratios of how many initial conditions ended up at each attractor.\n\nInitial conditions to use are defined by ics. It can be:\n\na StateSpaceSet of initial conditions, in which case all are used.\na 0-argument function ics() that spits out random initial conditions. Then N random initial conditions are chosen. See statespace_sampler to generate such functions.\n\nReturn\n\nThe function will always return fractions, which is a dictionary whose keys are the labels given to each attractor (always integers enumerating the different attractors), and whose values are the respective basins fractions. The label -1 is given to any initial condition where mapper could not match to an attractor (this depends on the mapper type).\n\nIf ics is a StateSpaceSet the function will also return labels, which is vector, of equal length to ics, that contains the label each initial condition was mapped to.\n\nSee AttractorMapper for all possible mapper types, and use extract_attractors (after calling basins_fractions) to extract the stored attractors from the mapper.\n\nKeyword arguments\n\nN = 1000: Number of random initial conditions to generate in case ics is a function.\nshow_progress = true: Display a progress bar of the process.\n\n\n\n\n\nbasins_fractions(basins::AbstractArray) → fs::Dict\n\nCalculate the state space fraction of the basins of attraction encoded in basins. The elements of basins are integers, enumerating the attractor that the entry of basins converges to (i.e., like the output of basins_of_attraction). Return a dictionary that maps attractor IDs to their relative fractions.\n\nIn (Menck et al., 2013) the authors use these fractions to quantify the stability of a basin of attraction, and specifically how it changes when a parameter is changed. For this, see continuation.\n\n\n\n\n\n","category":"function"},{"location":"basins/#Attractors.extract_attractors","page":"Basins of Attraction","title":"Attractors.extract_attractors","text":"extract_attractors(mapper::AttractorsMapper) → attractors\n\nReturn a dictionary mapping label IDs to attractors found by the mapper. This function should be called after calling basins_fractions with the given mapper so that the attractors have actually been found first.\n\nFor AttractorsViaFeaturizing, the attractors are only stored if the mapper was called with pre-defined initial conditions rather than a sampler (function returning initial conditions).\n\n\n\n\n\n","category":"function"},{"location":"basins/#Attractors.basins_of_attraction","page":"Basins of Attraction","title":"Attractors.basins_of_attraction","text":"basins_of_attraction(mapper::AttractorMapper, grid::Tuple) → basins, attractors\n\nCompute the full basins of attraction as identified by the given mapper, which includes a reference to a GeneralizedDynamicalSystem and return them along with (perhaps approximated) found attractors.\n\ngrid is a tuple of ranges defining the grid of initial conditions that partition the state space into boxes with size the step size of each range. For example, grid = (xg, yg) where xg = yg = range(-5, 5; length = 100). The grid has to be the same dimensionality as the state space expected by the integrator/system used in mapper. E.g., a projected_integrator could be used for lower dimensional projections, etc. A special case here is a poincaremap with plane being Tuple{Int, <: Real}. In this special scenario the grid can be one dimension smaller than the state space, in which case the partitioning happens directly on the hyperplane the Poincaré map operates on.\n\nbasins_of_attraction function is a convenience 5-lines-of-code wrapper which uses the labels returned by basins_fractions and simply assings them to a full array corresponding to the state space partitioning indicated by grid.\n\n\n\n\n\nbasins_of_attraction(mapper::AttractorsViaRecurrences; show_progress = true)\n\nThis is a special method of basins_of_attraction that using recurrences does exactly what is described in the paper by Datseris & Wagemakers Datseris2022. By enforcing that the internal grid of mapper is the same as the grid of initial conditions to map to attractors, the method can further utilize found exit and attraction basins, making the computation faster as the grid is processed more and more.\n\n\n\n\n\n","category":"function"},{"location":"basins/#StateSpaceSets.statespace_sampler","page":"Basins of Attraction","title":"StateSpaceSets.statespace_sampler","text":"statespace_sampler(region [, seed = 42]) → sampler, isinside\n\nA function that facilitates sampling points randomly and uniformly in a state space region. It generates two functions:\n\nsampler is a 0-argument function that when called generates a random point inside a state space region. The point is always a Vector for type stability irrespectively of dimension. Generally, the generated point should be copied if it needs to be stored. (i.e., calling sampler() utilizes a shared vector) sampler is a thread-safe function.\nisinside is a 1-argument function that returns true if the given state space point is inside the region.\n\nThe region can be an instance of any of the following types (input arguments if not specified are vectors of length D, with D the state space dimension):\n\nHSphere(radius::Real, center): points inside the hypersphere (boundary excluded). Convenience method HSphere(radius::Real, D::Int) makes the center a D-long vector of zeros.\nHSphereSurface(radius, center): points on the hypersphere surface. Same convenience method as above is possible.\nHRectangle(mins, maxs): points in [min, max) for the bounds along each dimension.\n\nThe random number generator is always Xoshiro with the given seed.\n\n\n\n\n\nstatespace_sampler(grid::NTuple{N, AbstractRange} [, seed])\n\nIf given a grid that is a tuple of AbstractVectors, the minimum and maximum of the vectors are used to make an HRectangle region.\n\n\n\n\n\n","category":"function"},{"location":"basins/#Final-state-sensitivity-/-fractal-boundaries","page":"Basins of Attraction","title":"Final state sensitivity / fractal boundaries","text":"","category":"section"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"Several functions are provided related with analyzing the fractality of the boundaries of the basins of attraction:","category":"page"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"basins_fractal_dimension\nbasin_entropy\nbasins_fractal_test\nuncertainty_exponent","category":"page"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"basins_fractal_dimension\nbasin_entropy\nbasins_fractal_test\nuncertainty_exponent","category":"page"},{"location":"basins/#Attractors.basins_fractal_dimension","page":"Basins of Attraction","title":"Attractors.basins_fractal_dimension","text":"basins_fractal_dimension(basins; kwargs...) -> V_ε, N_ε, d\n\nEstimate the fractal dimension d of the boundary between basins of attraction using a box-counting algorithm for the boxes that contain at least two different basin IDs.\n\nKeyword arguments\n\nrange_ε = 2:maximum(size(basins))÷20 is the range of sizes of the box to test (in pixels).\n\nDescription\n\nThe output N_ε is a vector with the number of the balls of radius ε (in pixels) that contain at least two initial conditions that lead to different attractors. V_ε is a vector with the corresponding size of the balls. The ouput d is the estimation of the box-counting dimension of the boundary by fitting a line in the log.(N_ε) vs log.(1/V_ε) curve. However it is recommended to analyze the curve directly for more accuracy.\n\nIt is the implementation of the popular algorithm of the estimation of the box-counting dimension. The algorithm search for a covering the boundary with N_ε boxes of size ε in pixels.\n\n\n\n\n\n","category":"function"},{"location":"basins/#Attractors.basin_entropy","page":"Basins of Attraction","title":"Attractors.basin_entropy","text":"basin_entropy(basins::Array, ε = 20) -> Sb, Sbb\n\nCompute the basin entropy (Daza et al., 2016) Sb and basin boundary entropy Sbb of the given basins of attraction by considering ε boxes along each dimension.\n\nDescription\n\nFirst, the input basins is divided regularly into n-dimensional boxes of side ε (along all dimensions). Then Sb is simply the average of the Gibbs entropy computed over these boxes. The function returns the basin entropy Sb as well as the boundary basin entropy Sbb. The later is the average of the entropy only for boxes that contains at least two different basins, that is, for the boxes on the boundaries.\n\nThe basin entropy is a measure of the uncertainty on the initial conditions of the basins. It is maximum at the value log(n_att) being n_att the number of attractors. In this case the boundary is intermingled: for a given initial condition we can find another initial condition that lead to another basin arbitriraly close. It provides also a simple criterion for fractality: if the boundary basin entropy Sbb is above log(2) then we have a fractal boundary. It doesn't mean that basins with values below cannot have a fractal boundary, for a more precise test see basins_fractal_test. An important feature of the basin entropy is that it allows comparisons between different basins using the same box size ε.\n\n\n\n\n\n","category":"function"},{"location":"basins/#Attractors.basins_fractal_test","page":"Basins of Attraction","title":"Attractors.basins_fractal_test","text":"basins_fractal_test(basins; ε = 20, Ntotal = 1000) -> test_res, Sbb\n\nPerform an automated test to decide if the boundary of the basins has fractal structures based on the method of Puy et al. (Puy et al., 2021). Return test_res (:fractal or :smooth) and the mean basin boundary entropy.\n\nKeyword arguments\n\nε = 20: size of the box to compute the basin boundary entropy.\nNtotal = 1000: number of balls to test in the boundary for the computation of Sbb\n\nDescription\n\nThe test \"looks\" at the basins with a magnifier of size ε at random. If what we see in the magnifier looks like a smooth boundary (onn average) we decide that the boundary is smooth. If it is not smooth we can say that at the scale ε we have structures, i.e., it is fractal.\n\nIn practice the algorithm computes the boundary basin entropy Sbb basin_entropy for Ntotal random boxes of radius ε. If the computed value is equal to theoretical value of a smooth boundary (taking into account statistical errors and biases) then we decide that we have a smooth boundary. Notice that the response test_res may depend on the chosen ball radius ε. For larger size, we may observe structures for smooth boundary and we obtain a different answer.\n\nThe output test_res is a symbol describing the nature of the basin and the output Sbb is the estimated value of the boundary basin entropy with the sampling method.\n\n\n\n\n\n","category":"function"},{"location":"basins/#Attractors.uncertainty_exponent","page":"Basins of Attraction","title":"Attractors.uncertainty_exponent","text":"uncertainty_exponent(basins; kwargs...) -> ε, N_ε, α\n\nEstimate the uncertainty exponentGrebogi1983 of the basins of attraction. This exponent is related to the final state sensitivity of the trajectories in the phase space. An exponent close to 1 means basins with smooth boundaries whereas an exponent close to 0 represent completely fractalized basins, also called riddled basins.\n\nThe output N_ε is a vector with the number of the balls of radius ε (in pixels) that contain at least two initial conditions that lead to different attractors. The ouput α is the estimation of the uncertainty exponent using the box-counting dimension of the boundary by fitting a line in the log.(N_ε) vs log.(1/ε) curve. However it is recommended to analyze the curve directly for more accuracy.\n\nKeyword arguments\n\nrange_ε = 2:maximum(size(basins))÷20 is the range of sizes of the ball to test (in pixels).\n\nDescription\n\nA phase space with a fractal boundary may cause a uncertainty on the final state of the dynamical system for a given initial condition. A measure of this final state sensitivity is the uncertainty exponent. The algorithm probes the basin of attraction with balls of size ε at random. If there are a least two initial conditions that lead to different attractors, a ball is tagged \"uncertain\". f_ε is the fraction of \"uncertain balls\" to the total number of tries in the basin. In analogy to the fractal dimension, there is a scaling law between, f_ε ~ ε^α. The number that characterizes this scaling is called the uncertainty exponent α.\n\nNotice that the uncertainty exponent and the box counting dimension of the boundary are related. We have Δ₀ = D - α where Δ₀ is the box counting dimension computed with basins_fractal_dimension and D is the dimension of the phase space. The algorithm first estimates the box counting dimension of the boundary and returns the uncertainty exponent.\n\n\n\n\n\n","category":"function"},{"location":"basins/#Tipping-points","page":"Basins of Attraction","title":"Tipping points","text":"","category":"section"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"This page discusses functionality related with tipping points in dynamical systems with known rule. If instead you are interested in identifying tipping points in measured timeseries, have a look at TransitionIndicators.jl.","category":"page"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"tipping_probabilities","category":"page"},{"location":"basins/#Attractors.tipping_probabilities","page":"Basins of Attraction","title":"Attractors.tipping_probabilities","text":"tipping_probabilities(basins_before, basins_after) → P\n\nReturn the tipping probabilities of the computed basins before and after a change in the system parameters (or time forcing), according to the definition of Kaszás2019.\n\nThe input basins are integer-valued arrays, where the integers enumerate the attractor, e.g. the output of basins_of_attraction.\n\nDescription\n\nLet mathcalB_i(p) denote the basin of attraction of attractor A_i at parameter(s) p. Kaszás et al Kaszás2019 define the tipping probability from A_i to A_j, given a parameter change in the system of p_- to p_+, as\n\nP(A_i to A_j  p_- to p_+) =\nfracmathcalB_j(p_+) cap mathcalB_i(p_-)mathcalB_i(p_-)\n\nwhere cdot is simply the volume of the enclosed set. The value of P(A_i to A_j  p_- to p_+) is P[i, j]. The equation describes something quite simple: what is the overlap of the basin of attraction of A_i at p_- with that of the attractor A_j at p_+. If basins_before, basins_after contain values of -1, corresponding to trajectories that diverge, this is considered as the last attractor of the system in P.\n\n\n\n\n\n","category":"function"},{"location":"basins/#Mimimal-Fatal-Shock","page":"Basins of Attraction","title":"Mimimal Fatal Shock","text":"","category":"section"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"The algorithm to find minimal perturbation for arbitrary initial condition u0 which will kick the system into different from the current basin. ","category":"page"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"minimal_fatal_shock\nMFSBlackBoxOptim\nMFSBruteForce","category":"page"},{"location":"basins/#Attractors.minimal_fatal_shock","page":"Basins of Attraction","title":"Attractors.minimal_fatal_shock","text":"minimal_fatal_shock(mapper::AttractorMapper, u0, search_area, algorithm) → mfs\n\nReturn the minimal fatal shock mfs for the initial point u0 according to the specified algorithm given a mapper that satisfies the id = mapper(u0) interface (see AttractorMapper if you are not sure which mappers do that). The mapper contains a reference to a DynamicalSystem. The options for algorithm are: MFSBruteForce or MFSBlackBoxOptim. Forh high dimensional systems MFSBlackBoxOptim is likely more accurate.\n\nThe search_area dictates the state space range for the search of the mfs. It can be a 2-tuple of (min, max) values, in which case the same values are used for each dimension of the system in mapper. Otherwise, it can be a vector of 2-tuples, each for each dimension of the system. The search area is defined w.r.t. to u0 (i.e., it is the search area for perturbations of u0).\n\nDescription\n\nThe minimal fatal shock is defined as the smallest (smallest norm) perturbation of the initial point u0 that will lead it a different basin of attraction. It is inspired by the paper \"Minimal fatal shocks in multistable complex networks\" (Halekotte and Feudel, 2020), however the implementation here is generic: it works for any dynamical system.\n\n\n\n\n\n","category":"function"},{"location":"basins/#Attractors.MFSBlackBoxOptim","page":"Basins of Attraction","title":"Attractors.MFSBlackBoxOptim","text":"MFSBlackBoxOptim(; kwargs...)\n\nThe black box derivative-free optimization algorithm used in minimal_fatal_shock.\n\nKeyword arguments\n\nguess = nothing a initial guess for the minimal fatal shock given to the optimization algorithm. If not nothing, random_algo below is ignored.\nmax_steps = 10000 maximum number of steps for the optimization algorithm.\npenalty penalty value for the objective function, allows to adjust optimization algorithm to find the minimal fatal shock, default = 1000.0\nprint_info boolean value, if true, the optimization algorithm will print information on the evaluation steps of objective function, default = false.\nrandom_algo = MFSBruteForce(100, 100, 0.99): an instance of MFSBruteForce that can be used to provide an initial guess.\n\nDescription\n\nThe algorithm uses BlackBoxOptim.jl and a penaltized objective function to minimize. y function used as a constraint function. So, if we hit another basin during the search we encourage the algorithm otherwise we punish it with some penalty. The function to minimize is (besides some details):\n\nfunction mfs_objective(perturbation, u0, mapper, penalty)\n    dist = norm(perturbation)\n    if mapper(u0 + perturbation) == mapper(u0)\n        # penaltize if we stay in the same basin:\n        return dist + penalty\n    else\n        return dist\n    end\nend\n\nUsing an initial guess can be beneficial to both performance and accuracy, which is why the output of a crude MFSBruteForce is used to provide a guess. This can be disabled by either passing a guess vector explicitly or by giving nothing as random_algo.\n\n\n\n\n\n","category":"type"},{"location":"basins/#Attractors.MFSBruteForce","page":"Basins of Attraction","title":"Attractors.MFSBruteForce","text":"MFSBruteForce(; kwargs...)\n\nThe brute force randomized search algorithm used in minimal_fatal_shock.\n\nIt consists of two steps: random initialization and sphere radius reduction. On the first step, the algorithm generates random pertubations within the search area and records the perturbation that leads to a different basin but with the smallest magnitude. With this obtained pertubation it proceeds to the second step. On the second step, the algorithm generates random pertubations on the surface of the hypersphere with radius equal to the norm of the pertubation found in the first step. It reduces the radius of the hypersphere and continues searching for the better result with a smaller radius. Each time a better result is found, the radius is reduced further.\n\nThe algorithm records the perturbation with smallest radius that leads to a different basin.\n\nKeyword arguments\n\ninitial_iterations = 10000: number of random pertubations to try in the first step of the algorithm.\nsphere_iterations = 10000: number of steps while initializing random points on hypersphere and decreasing its radius.\nsphere_decrease_factor = 0.999 factor by which the radius of the hypersphere is decreased (at each step the radius is multiplied by this number). Number closer to 1 means more refined accuracy\n\n\n\n\n\n","category":"type"},{"location":"continuation/#Attractor-and-Basins-Continuation","page":"Attractor & Basins Continuation","title":"Attractor & Basins Continuation","text":"","category":"section"},{"location":"continuation/#A-new-kind-of-continuation","page":"Attractor & Basins Continuation","title":"A new kind of continuation","text":"","category":"section"},{"location":"continuation/","page":"Attractor & Basins Continuation","title":"Attractor & Basins Continuation","text":"If you have heard before the word \"continuation\", then you are likely aware of the traditional continuation-based bifurcation analysis (CBA) offered by many software, such as AUTO, MatCont, and in Julia BifurcationKit.jl. Here we offer a completely different kind of continuation called attractors & basins continuation.","category":"page"},{"location":"continuation/","page":"Attractor & Basins Continuation","title":"Attractor & Basins Continuation","text":"A direct comparison of the two approaches is not truly possible, because they do different things. The traditional linearized continuation analysis continues the curves of individual fixed points across the joint state-parameter space. The attractor and basins continuation first finds all attractors at all parameter values and then matches appropriately similar attractors across different parameters, giving the illusion of continuing them individually. Additionally, the curves of stable fixed points in the joint parameter space is only a small by-product of the attractor basins continuation, and the main information is the basin fractions and how these change in the parameter space.","category":"page"},{"location":"continuation/","page":"Attractor & Basins Continuation","title":"Attractor & Basins Continuation","text":"A more detailed comparison between these two fundamentally different approaches in is given in high detail in our paper.","category":"page"},{"location":"continuation/#Continuation-API","page":"Attractor & Basins Continuation","title":"Continuation API","text":"","category":"section"},{"location":"continuation/","page":"Attractor & Basins Continuation","title":"Attractor & Basins Continuation","text":"continuation","category":"page"},{"location":"continuation/#Attractors.continuation","page":"Attractor & Basins Continuation","title":"Attractors.continuation","text":"continuation(abc::AttractorsBasinsContinuation, prange, pidx, ics; kwargs...)\n\nFind and continue attractors (or feature-based representations of attractors) and the fractions of their basins of attraction across a parameter range. continuation is the central function of the framework for global stability analysis illustrated in (Datseris et al., 2023).\n\nThe continuation type abc is a subtype of AttractorsBasinsContinuation and contains an AttractorMapper. The mapper contains information on how to find the attractors and basins of a dynamical system. Additional arguments and keyword arguments given when creating abc further tune the continuation and how attractors are matched across different parameter values.\n\nThe basin fractions and the attractors (or some representation of them) are continued across the parameter range prange, for the parameter of the system with index pidx (any index valid in set_parameter! can be used).\n\nics is a 0-argument function generating initial conditions for the dynamical system (as in basins_fractions).\n\nPossible subtypes of AttractorsBasinsContinuation are:\n\nRecurrencesFindAndMatch\nFeaturizeGroupAcrossParameter\n\nReturn\n\nfractions_curves::Vector{Dict{Int, Float64}}. The fractions of basins of attraction. fractions_curves[i] is a dictionary mapping attractor IDs to their basin fraction at the i-th parameter.\nattractors_info::Vector{Dict{Int, <:Any}}. Information about the attractors. attractors_info[i] is a dictionary mapping attractor ID to information about the attractor at the i-th parameter. The type of information stored depends on the chosen continuation type.\n\nKeyword arguments\n\nshow_progress = true: display a progress bar of the computation.\nsamples_per_parameter = 100: amount of initial conditions sampled at each parameter from ics.\n\n\n\n\n\n","category":"function"},{"location":"continuation/#Recurrences-continuation-(best)","page":"Attractor & Basins Continuation","title":"Recurrences continuation (best)","text":"","category":"section"},{"location":"continuation/","page":"Attractor & Basins Continuation","title":"Attractor & Basins Continuation","text":"RecurrencesFindAndMatch","category":"page"},{"location":"continuation/#Attractors.RecurrencesFindAndMatch","page":"Attractor & Basins Continuation","title":"Attractors.RecurrencesFindAndMatch","text":"RecurrencesFindAndMatch <: AttractorsBasinsContinuation\nRecurrencesFindAndMatch(mapper::AttractorsViaRecurrences; kwargs...)\n\nA method for continuation as in (Datseris et al., 2023) that is based on the recurrences-based algorithm for finding attractors (AttractorsViaRecurrences) and the \"matching attractors\" functionality offered by match_statespacesets!.\n\nYou can use RAFM as an alias.\n\nDescription\n\nAt the first parameter slice of the continuation process, attractors and their fractions are found as described in the AttractorsViaRecurrences mapper using recurrences in state space. At each subsequent parameter slice, new attractors are found by seeding initial conditions from the previously found attractors and then running these initial conditions through the recurrences algorithm of the mapper. Seeding initial conditions close to previous attractors accelerates the main bottleneck of AttractorsViaRecurrences, which is finding the attractors.\n\nAfter the special initial conditions are mapped to attractors, attractor basin fractions are computed by sampling random initial conditions. (using the provided sampler in continuation) and mapping them to attractors using the AttractorsViaRecurrences mapper. I.e., exactly as in basins_fractions. Naturally, during this step new attractors may be found, besides those found using the \"seeding from previous attractors\". Once the basins fractions are computed, the parameter is incremented again and we perform the steps as before.\n\nThis process continues for all parameter values. After all parameters are exhausted, the newly found attractors (and their fractions) are \"matched\" to the previous ones. I.e., their IDs are changed, so that attractors with closest distance to those at a previous parameter get assigned the same ID. Matching is rather sophisticated and is described in match_statespacesets! and match_continuation!. Typically, the matching process matches attractor IDs that are closest in state space distance, but more options are possible, see match_statespacesets!.\n\nNote that in this continuation the finding-attractors and matching-attractors steps are completely independent. This means, that if you don't like the initial outcome of the matching process, you may call match_continuation! again on the outcome with (possibly different) matching-related keywords.\n\nKeyword arguments\n\ndistance, threshold, use_vanished: propagated to match_continuation!.\ninfo_extraction = identity: A function that takes as an input an attractor (StateSpaceSet) and outputs whatever information should be stored. It is used to return the attractors_info in continuation. Note that the same attractors that are stored in attractors_info are also used to perform the matching in match_continuation!, hence this keyword should be altered with care.\nseeds_from_attractor: A function that takes as an input an attractor and returns an iterator of initial conditions to be seeded from the attractor for the next parameter slice. By default, we sample only the first stored point on the attractor.\n\n\n\n\n\n","category":"type"},{"location":"continuation/#Matching-attractors","page":"Attractor & Basins Continuation","title":"Matching attractors","text":"","category":"section"},{"location":"continuation/","page":"Attractor & Basins Continuation","title":"Attractor & Basins Continuation","text":"match_statespacesets!\nreplacement_map\nset_distance\nsetsofsets_distances\nmatch_continuation!\nmatch_basins_ids!","category":"page"},{"location":"continuation/#Attractors.match_statespacesets!","page":"Attractor & Basins Continuation","title":"Attractors.match_statespacesets!","text":"match_statespacesets!(a₊::AbstractDict, a₋; distance = Centroid(), threshold = Inf)\n\nGiven dictionaries a₊, a₋ mapping IDs to StateSpaceSet instances, match the IDs in dictionary a₊ so that its sets that are the closest to those in dictionary a₋ get assigned the same key as in a₋. Typically the +,- mean after and before some change of parameter of a system.\n\nReturn the replacement map, a dictionary mapping old keys of a₊ to the new ones that they were mapped to. You can obtain this map, without modifying the dictionaries, by calling the replacement_map function directly.\n\nKeyword arguments\n\ndistance = Centroid(): given to setsofsets_distances.\nthreshold = Inf: attractors with distance larger than the threshold are guaranteed to not be mapped to each other.\n\nDescription\n\nWhen finding attractors and their fractions in Attractors.jl, different attractors get assigned different IDs. However which attractor gets which ID is somewhat arbitrary. Finding the attractors of the same system for slightly different parameters could label \"similar\" attractors (at the different parameters) with different IDs. match_statespacesets! tries to \"match\" them by modifying the IDs, i.e., the keys of the given dictionaries. Do note however that there is nothing in this function that is limited to attractors in the formal mathematical sense. Any dictionary with StateSpaceSet values is a valid input and these sets may represent attractors, trajectories, group of features, or anything else.\n\nThe matching happens according to the output of the setsofsets_distances function with the keyword distance. distance can be whatever that function accepts, i.e., one of Centroid, Hausdorff, StrictlyMinimumDistance or any arbitrary user- provided function that given two sets it returns a positive number (their distance). State space sets are then matched according to this distance. First, all possible pairs (old, new, distance) are sorted according to their distance. The pair with smallest distance is matched. Sets in matched pairs are removed from the matching pool to ensure a unique mapping. Then, the next pair with least remaining distance is matched, and the process repeats until all pairs are exhausted.\n\nAdditionally, you can provide a threshold value. If the distance between two attractors is larger than this threshold, then it is guaranteed that the attractors will get assigned different key in the dictionary a₊ (which is the next available integer).\n\n\n\n\n\n","category":"function"},{"location":"continuation/#Attractors.replacement_map","page":"Attractor & Basins Continuation","title":"Attractors.replacement_map","text":"replacement_map(a₊, a₋; distance = Centroid(), threshold = Inf) → rmap\n\nReturn a dictionary mapping keys in a₊ to new keys in a₋, as explained in match_statespacesets!.\n\n\n\n\n\n","category":"function"},{"location":"continuation/#StateSpaceSets.set_distance","page":"Attractor & Basins Continuation","title":"StateSpaceSets.set_distance","text":"set_distance(ssset1, ssset2 [, distance])\n\nCalculate a distance between two StateSpaceSets, i.e., a distance defined between sets of points, as dictated by distance.\n\nPossible distance types are:\n\nCentroid, which is the default, and 100s of times faster than the rest\nHausdorff\nStrictlyMinimumDistance\n\n\n\n\n\n","category":"function"},{"location":"continuation/#StateSpaceSets.setsofsets_distances","page":"Attractor & Basins Continuation","title":"StateSpaceSets.setsofsets_distances","text":"setsofsets_distances(a₊, a₋ [, distance]) → distances\n\nCalculate distances between sets of StateSpaceSets. Here  a₊, a₋ are containers of StateSpaceSets, and the returned distances are dictionaries of distances. Specifically, distances[i][j] is the distance of the set in the i key of a₊ to the j key of a₋. Notice that distances from a₋ to a₊ are not computed at all (assumming symmetry in the distance function).\n\nThe distance can be as in set_distance, or it can be an arbitrary function that takes as input two state space sets and returns any positive-definite number as their \"distance\".\n\n\n\n\n\n","category":"function"},{"location":"continuation/#Attractors.match_continuation!","page":"Attractor & Basins Continuation","title":"Attractors.match_continuation!","text":"match_continuation!(fractions_curves::Vector{<:Dict}, attractors_info::Vector{<:Dict}; kwargs...)\n\nLoop over all entries in the given arguments (which are typically the direct outputs of continuation with RecurrencesFindAndMatch), and match the attractor IDs in both the attractors container and the basins fractions container. This means that we loop over each entry of the vectors (skipping the first), and in each entry we attempt to match the dictionary keys to the keys of the previous dictionary using match_statespacesets.\n\nThe keywords distance, threshold are propagated to match_statespacesets. However, there is a unique keyword for match_continuation!: use_vanished::Bool. If true, then attractors that existed before but have vanished are kept in \"memory\" when it comes to matching: the new attractors are compared to the latest istance of all attractors that have ever existed, and get match to their closest ones as per match_statespacesets!. If false, vanished attractors are ignored. Note that in this case new attractors that cannot be matched to any previous attractors will get an appropriately incremented ID. E.g., if we started with three attractors, and attractor 3 vanished, and at some later parameter value we again have three attractors, the new third attractor will not have ID 3, but 4 (i.e., the next available ID).\n\nBy default use_vanished = !isinf(threshold) and since the default value for threshold is Inf, use_vanished is false.\n\nThe last keyword is retract_keys = true which will \"retract\" keys (i.e., make the integers smaller integers) so that all unique IDs are the 1-incremented positive integers. E.g., if the IDs where 1, 6, 8, they will become 1, 2, 3. The special id -1 is unaffected by this.\n\nrematch_continuation!(attractors_info::Vector{<:Dict}; kwargs...)\n\nThis is a convenience method that only uses and modifies the state space set dictionary container without the need for a basins fractions container.\n\n\n\n\n\n","category":"function"},{"location":"continuation/#Attractors.match_basins_ids!","page":"Attractor & Basins Continuation","title":"Attractors.match_basins_ids!","text":"match_basins_ids!(b₊::AbstractArray, b₋; threshold = Inf)\n\nSimilar to match_statespacesets! but operate on basin arrays instead (the arrays typically returned by basins_of_attraction).\n\nThis method matches IDs of attractors whose basins of attraction before and after b₋,b₊ have the most overlap (in pixels). This overlap is normalized in 0-1 (with 1 meaning 100% overlap of pixels). The threshold in this case is compared to the inverse of the overlap (so, for threshold = 2 attractors that have less than 50% overlap get different IDs guaranteed).\n\n\n\n\n\n","category":"function"},{"location":"continuation/#Aggregating-attractors-and-fractions","page":"Attractor & Basins Continuation","title":"Aggregating attractors and fractions","text":"","category":"section"},{"location":"continuation/","page":"Attractor & Basins Continuation","title":"Attractor & Basins Continuation","text":"aggregate_attractor_fractions","category":"page"},{"location":"continuation/#Attractors.aggregate_attractor_fractions","page":"Attractor & Basins Continuation","title":"Attractors.aggregate_attractor_fractions","text":"aggregate_attractor_fractions(\n    fractions_curves, attractors_info, featurizer, group_config [, info_extraction]\n)\n\nAggregate the already-estimated curves of fractions of basins of attraction of similar attractors using the same pipeline used by GroupingConfig. The most typical application of this function is to transform the output of RecurrencesFindAndMatch so that similar attractors, even across parameter space, are grouped into one \"attractor\". Thus, the fractions of their basins are aggregated.\n\nYou could also use this function to aggregate attractors and their fractions even in a single parameter configuration, i.e., using the output of basins_fractions.\n\nThis function is useful in cases where you want the accuracy and performance of AttractorsViaRecurrences, but you also want the convenience of \"grouping\" similar attractrors like in AttractorsViaFeaturizing for presentation or analysis purposes. For example, a high dimesional model of competition dynamics across multispecies may have extreme multistability. After finding this multistability however, one may care about aggregating all attractors into two groups: where a given species is extinct or not. This is the example highlighted in our documentation, in Extinction of a species in a multistable competition model.\n\nInput\n\nfractions_curves: a vector of dictionaries mapping labels to basin fractions.\nattractors_info: a vector of dictionaries mapping labels to attractors. 1st and 2nd argument are exactly like the return values of continuation with RecurrencesFindAndMatch (or, they can be the return of basins_fractions).\nfeaturizer: a 1-argument function to map an attractor into an appropriate feature to be grouped later. Features expected by GroupingConfig are SVector.\ngroup_config: a subtype of GroupingConfig.\ninfo_extraction: a function accepting a vector of features and returning a description of the features. I.e., exactly as in FeaturizeGroupAcrossParameter. The 5th argument is optional and defaults to the centroid of the features.\n\nReturn\n\naggregated_fractions: same as fractions_curves but now contains the fractions of the aggregated attractors.\naggregated_info: dictionary mapping the new labels of aggregated_fractions to the extracted information using info_extraction.\n\nClustering attractors directly\n\n(this is rather advanced)\n\nYou may also use the DBSCAN clustering approach here to group attractors based on their state space distance (the set_distance) by making a distance matrix as expected by the DBSCAN implementation. For this, use identity as featurizer, and choose GroupViaClustering as the group_config with clust_distance_metric = set_distance and provide a numerical value for optimal_radius_method when initializing the GroupViaClustering, and also, for the info_extraction argument, you now need to provide a function that expects a vector of StateSpaceSets and outputs a descriptor. E.g., info_extraction = vector -> mean(mean(x) for x in vector).\n\n\n\n\n\n","category":"function"},{"location":"continuation/#Grouping-continuation","page":"Attractor & Basins Continuation","title":"Grouping continuation","text":"","category":"section"},{"location":"continuation/","page":"Attractor & Basins Continuation","title":"Attractor & Basins Continuation","text":"FeaturizeGroupAcrossParameter","category":"page"},{"location":"continuation/#Attractors.FeaturizeGroupAcrossParameter","page":"Attractor & Basins Continuation","title":"Attractors.FeaturizeGroupAcrossParameter","text":"FeaturizeGroupAcrossParameter <: AttractorsBasinsContinuation\nFeaturizeGroupAcrossParameter(mapper::AttractorsViaFeaturizing; kwargs...)\n\nA method for continuation. It uses the featurizing approach discussed in AttractorsViaFeaturizing and hence requires an instance of that mapper as an input. When used in continuation, features are extracted and then grouped across a parameter range. Said differently, all features of all initial conditions across all parameter values are put into the same \"pool\" and then grouped as dictated by the group_config of the mapper. After the grouping is finished the feature label fractions are distributed to each parameter value they came from.\n\nKeyword arguments\n\ninfo_extraction::Function a function that takes as an input a vector of feature-vectors (corresponding to a cluster) and returns a description of the cluster. By default, the centroid of the cluster is used.\npar_weight = 0: See below the section on MCBB.\n\nMCBB special version\n\nIf the chosen grouping method is GroupViaClustering, the additional keyword par_weight::Real can be used. If it is ≠ 0, the distance matrix between features obtains an extra weight that is proportional to the distance par_weight*|p[i] - p[j]| between the parameters used when extracting features. The range of parameters is normalized to 0-1 such that the largest distance in the parameter space is 1. The normalization is done because the feature space is also (by default) normalized to 0-1.\n\nThis version of the algorithm is the original \"MCBB\" continuation method described in (Gelbrecht et al., 2020), besides the improvements of clustering accuracy and performance done by the developer team of Attractors.jl.\n\n\n\n\n\n","category":"type"},{"location":"dynsysref/#DynamicalSystem-reference","page":"DynamicalSystem reference","title":"DynamicalSystem reference","text":"","category":"section"},{"location":"dynsysref/","page":"DynamicalSystem reference","title":"DynamicalSystem reference","text":"This page is a convenience reference to some of the contents of the DynamicalSystemsBase.jl package (one of the core modules of DynamicalSystems.jl).","category":"page"},{"location":"dynsysref/#Dynamical-systems","page":"DynamicalSystem reference","title":"Dynamical systems","text":"","category":"section"},{"location":"dynsysref/","page":"DynamicalSystem reference","title":"DynamicalSystem reference","text":"The kinds of dynamical systems that can be used in Attractors.jl are listed below for reference","category":"page"},{"location":"dynsysref/","page":"DynamicalSystem reference","title":"DynamicalSystem reference","text":"DynamicalSystem\nDeterministicIteratedMap\nCoupledODEs\nStroboscopicMap\nPoincareMap\nProjectedDynamicalSystem\nArbitrarySteppable","category":"page"},{"location":"dynsysref/","page":"DynamicalSystem reference","title":"DynamicalSystem reference","text":"DynamicalSystem\nDeterministicIteratedMap\nCoupledODEs\nStroboscopicMap\nPoincareMap\nProjectedDynamicalSystem\nArbitrarySteppable","category":"page"},{"location":"dynsysref/#DynamicalSystemsBase.DynamicalSystem","page":"DynamicalSystem reference","title":"DynamicalSystemsBase.DynamicalSystem","text":"DynamicalSystem\n\nDynamicalSystem is an abstract supertype encompassing all concrete implementations of what counts as a \"dynamical system\" in the DynamicalSystems.jl library.\n\nAll concrete implementations of DynamicalSystem can be iteratively evolved in time via the step! function. Hence, most library functions that evolve the system will mutate its current state and/or parameters. See the documentation online for implications this has on for parallelization.\n\nDynamicalSystem is further separated into two abstract types: ContinuousTimeDynamicalSystem, DiscreteTimeDynamicalSystem. The simplest and most common concrete implementations of a DynamicalSystem are DeterministicIteratedMap or CoupledODEs.\n\nDescription\n\nnote: Note\nThe documentation of DynamicalSystem follows chapter 1 of Nonlinear Dynamics, Datseris & Parlitz, Springer 2022.\n\nA ds::DynamicalSystem representes a flow Φ in a state space. It mainly encapsulates three things:\n\nA state, typically referred to as u, with initial value u0. The space that u occupies is the state space of ds and the length of u is the dimension of ds (and of the state space).\nA dynamic rule, typically referred to as f, that dictates how the state evolves/changes with time when calling the step! function. f is a standard Julia function, see below.\nA parameter container p that parameterizes f. p can be anything, but in general it is recommended to be a type-stable mutable container.\n\nIn sort, any set of quantities that change in time can be considered a dynamical system, however the concrete subtypes of DynamicalSystem are much more specific in their scope. Concrete subtypes typically also contain more information than the above 3 items.\n\nIn this scope dynamical systems have a known dynamic rule f defined as a standard Julia function. Observed or measured data from a dynamical system are represented using StateSpaceSet and are finite. Such data are obtained from the trajectory function or from an experimental measurement of a dynamical system with an unknown dynamic rule.\n\nConstruction instructions on f and u\n\nMost of the concrete implementations of DynamicalSystem, with the exception of ArbitrarySteppable, have two ways of implementing the dynamic rule f, and as a consequence the type of the state u. The distinction is done on whether f is defined as an in-place (iip) function or out-of-place (oop) function.\n\noop : f must be in the form f(u, p, t) -> out   which means that given a state u::SVector{<:Real} and some parameter container   p it returns the output of f as an SVector{<:Real} (static vector).\niip : f must be in the form f!(out, u, p, t)   which means that given a state u::AbstractArray{<:Real} and some parameter container p,   it writes in-place the output of f in out::AbstractArray{<:Real}.   The function must return nothing as a final statement.\n\nt stands for current time in both cases. iip is suggested for systems with high dimension and oop for small. The break-even point is between 10 to 100 dimensions but should be benchmarked on a case-by-case basis as it depends on the complexity of f.\n\nnote: Autonomous vs non-autonomous systems\nWhether the dynamical system is autonomous (f doesn't depend on time) or not, it is still necessary to include t as an argument to f. Some algorithms utilize this information, some do not, but we prefer to keep a consistent interface either way. You can also convert any system to autonomous by making time an additional variable. If the system is non-autonomous, its effective dimensionality is dimension(ds)+1.\n\nAPI\n\nThe API that the interface of DynamicalSystem employs is the functions listed below. Once a concrete instance of a subtype of DynamicalSystem is obtained, it can quieried or altered with the following functions.\n\nThe main use of a concrete dynamical system instance is to provide it to downstream functions such as lyapunovspectrum from ChaosTools.jl or basins_of_attraction from Attractors.jl. A typical user will likely not utilize directly the following API, unless when developing new algorithm implementations that use dynamical systems.\n\nAPI - information\n\nds(t) with ds an instance of DynamicalSystem: return the state of ds at time t. For continuous time systems this interpolates and extrapolates, while for discrete time systems it only works if t is the current time.\ncurrent_state\ninitial_state\ncurrent_parameters\ninitial_parameters\nisdeterministic\nisdiscretetime\ndynamic_rule\ncurrent_time\ninitial_time\nisinplace\nsuccesful_step\n\nAPI - alter status\n\nreinit!\nset_state!\nset_parameter!\nset_parameters!\n\n\n\n\n\n","category":"type"},{"location":"dynsysref/#DynamicalSystemsBase.DeterministicIteratedMap","page":"DynamicalSystem reference","title":"DynamicalSystemsBase.DeterministicIteratedMap","text":"DeterministicIteratedMap <: DynamicalSystem\nDeterministicIteratedMap(f, u0, p = nothing; t0 = 0)\n\nA deterministic discrete time dynamical system defined by an iterated map as follows:\n\nvecu_n+1 = vecf(vecu_n p n)\n\nAn alias for DeterministicIteratedMap is DiscreteDynamicalSystem.\n\nOptionally configure the parameter container p and initial time t0.\n\nFor construction instructions regarding f, u0 see DynamicalSystem.\n\n\n\n\n\n","category":"type"},{"location":"dynsysref/#DynamicalSystemsBase.CoupledODEs","page":"DynamicalSystem reference","title":"DynamicalSystemsBase.CoupledODEs","text":"CoupledODEs <: ContinuousTimeDynamicalSystem\nCoupledODEs(f, u0 [, p]; diffeq, t0 = 0.0)\n\nA deterministic continuous time dynamical system defined by a set of coupled ordinary differential equations as follows:\n\nfracdvecudt = vecf(vecu p t)\n\nAn alias for CoupledODE is ContinuousDynamicalSystem.\n\nOptionally provide the parameter container p and initial time as keyword t0.\n\nFor construction instructions regarding f, u0 see DynamicalSystem.\n\nDifferentialEquations.jl keyword arguments and interfacing\n\nThe ODEs are evolved via the solvers of DifferentialEquations.jl. When initializing a CoupledODEs, you can specify the solver that will integrate f in time, along with any other integration options, using the diffeq keyword. For example you could use diffeq = (abstol = 1e-9, reltol = 1e-9). If you want to specify a solver, do so by using the keyword alg, e.g.: diffeq = (alg = Tsit5(), reltol = 1e-6). This requires you to have been first using OrdinaryDiffEq to access the solvers. The default diffeq is:\n\n(alg = Tsit5(; stagelimiter! = triviallimiter!, steplimiter! = triviallimiter!, thread = static(false),), abstol = 1.0e-6, reltol = 1.0e-6)\n\ndiffeq keywords can also include callback for event handling , however the majority of downstream functions in DynamicalSystems.jl assume that f is differentiable.\n\nThe convenience constructor CoupledODEs(prob::ODEProblem, diffeq) and CoupledODEs(ds::CoupledODEs, diffeq) are also available.\n\nDev note: CoupledODEs is a light wrapper of ODEIntegrator from DifferentialEquations.jl. The integrator is available as the field integ, and the ODEProblem is integ.sol.prob. The convenience syntax ODEProblem(ds::CoupledODEs, tspan = (t0, Inf)) is available.\n\n\n\n\n\n","category":"type"},{"location":"dynsysref/#DynamicalSystemsBase.StroboscopicMap","page":"DynamicalSystem reference","title":"DynamicalSystemsBase.StroboscopicMap","text":"StroboscopicMap <: DiscreteTimeDynamicalSystem\nStroboscopicMap(ds::CoupledODEs, period::Real) → smap\nStroboscopicMap(period::Real, f, u0, p = nothing; kwargs...)\n\nA discrete time dynamical system that produces iterations of a time-dependent (non-autonomous) CoupledODEs system exactly over a given period. The second signature first creates a CoupledODEs and then calls the first.\n\nStroboscopicMap follows the DynamicalSystem interface. In addition, the function set_period!(smap, period) is provided, that sets the period of the system to a new value (as if it was a parameter). As this system is in discrete time, current_time and initial_time are integers. The initial time is always 0, because current_time counts elapsed periods. Call these functions on the parent of StroboscopicMap to obtain the corresponding continuous time. In contrast, reinit! expects t0 in continuous time.\n\nThe convenience constructor\n\nStroboscopicMap(T::Real, f, u0, p = nothing; diffeq, t0 = 0) → smap\n\nis also provided.\n\nSee also PoincareMap.\n\n\n\n\n\n","category":"type"},{"location":"dynsysref/#DynamicalSystemsBase.PoincareMap","page":"DynamicalSystem reference","title":"DynamicalSystemsBase.PoincareMap","text":"PoincareMap <: DiscreteTimeDynamicalSystem\nPoincareMap(ds::CoupledODEs, plane; kwargs...) → pmap\n\nA discrete time dynamical system that produces iterations over the Poincaré map[DatserisParlitz2022] of the given continuous time ds. This map is defined as the sequence of points on the Poincaré surface of section, which is defined by the plane argument.\n\nSee also StroboscopicMap, poincaresos.\n\nKeyword arguments\n\ndirection = -1: Only crossings with sign(direction) are considered to belong to the surface of section. Negative direction means going from less than b to greater than b.\nu0 = nothing: Specify an initial state.\nrootkw = (xrtol = 1e-6, atol = 1e-8): A NamedTuple of keyword arguments passed to find_zero from Roots.jl.\nTmax = 1e3: The argument Tmax exists so that the integrator can terminate instead of being evolved for infinite time, to avoid cases where iteration would continue forever for ill-defined hyperplanes or for convergence to fixed points, where the trajectory would never cross again the hyperplane. If during one step! the system has been evolved for more than Tmax, then step!(pmap) will terminate and error.\n\nDescription\n\nThe Poincaré surface of section is defined as sequential transversal crossings a trajectory has with any arbitrary manifold, but here the manifold must be a hyperplane. PoincareMap iterates over the crossings of the section.\n\nIf the state of ds is mathbfu = (u_1 ldots u_D) then the equation defining a hyperplane is\n\na_1u_1 + dots + a_Du_D = mathbfacdotmathbfu=b\n\nwhere mathbfa b are the parameters of the hyperplane.\n\nIn code, plane can be either:\n\nA Tuple{Int, <: Real}, like (j, r): the plane is defined as when the jth variable of the system equals the value r.\nA vector of length D+1. The first D elements of the vector correspond to mathbfa while the last element is b.\n\nPoincareMap uses ds, higher order interpolation from DifferentialEquations.jl, and root finding from Roots.jl, to create a high accuracy estimate of the section.\n\nPoincareMap follows the DynamicalSystem interface with the following adjustments:\n\ndimension(pmap) == dimension(ds), even though the Poincaré map is effectively 1 dimension less.\nLike StroboscopicMap time is discrete and counts the iterations on the surface of section. initial_time is always 0 and current_time is current iteration number.\nA new function current_crossing_time returns the real time corresponding to the latest crossing of the hyperplane, which is what the current_state(ds) corresponds to as well.\nFor the special case of plane being a Tuple{Int, <:Real}, a special reinit! method is allowed with input state of length D-1 instead of D, i.e., a reduced state already on the hyperplane that is then converted into the D dimensional state.\n\nExample\n\nusing DynamicalSystemsBase\nds = Systems.rikitake(zeros(3); μ = 0.47, α = 1.0)\npmap = poincaremap(ds, (3, 0.0))\nstep!(pmap)\nnext_state_on_psos = current_state(pmap)\n\n[DatserisParlitz2022]: Datseris & Parlitz 2022, Nonlinear Dynamics: A Concise Introduction Interlaced with Code, Springer Nature, Undergrad. Lect. Notes In Physics\n\n\n\n\n\n","category":"type"},{"location":"dynsysref/#DynamicalSystemsBase.ProjectedDynamicalSystem","page":"DynamicalSystem reference","title":"DynamicalSystemsBase.ProjectedDynamicalSystem","text":"ProjectedDynamicalSystem <: DynamicalSystem\nProjectedDynamicalSystem(ds::DynamicalSystem, projection, complete_state)\n\nA dynamical system that represents a projection of an existing ds on a (projected) space.\n\nThe projection defines the projected space. If projection isa AbstractVector{Int}, then the projected space is simply the variable indices that projection contains. Otherwise, projection can be an arbitrary function that given the state of the original system ds, returns the state in the projected space. In this case the projected space can be equal, or even higher-dimensional, than the original.\n\ncomplete_state produces the state for the original system from the projected state. complete_state can always be a function that given the projected state returns a state in the original space. However, if projection isa AbstractVector{Int}, then complete_state can also be a vector that contains the values of the remaining variables of the system, i.e., those not contained in the projected space. In this case the projected space needs to be lower-dimensional than the original.\n\nNotice that ProjectedDynamicalSystem does not require an invertible projection, complete_state is only used during reinit!. ProjectedDynamicalSystem is in fact a rather trivial wrapper of ds which steps it as normal in the original state space and only projects as a last step, e.g., during current_state.\n\nExamples\n\nCase 1: project 5-dimensional system to its last two dimensions.\n\nds = Systems.lorenz96(5)\nprojection = [4, 5]\ncomplete_state = [0.0, 0.0, 0.0] # completed state just in the plane of last two dimensions\npds = ProjectedDynamicalSystem(ds, projection, complete_state)\nreinit!(pds, [0.2, 0.4])\nstep!(pds)\nget_state(pds)\n\nCase 2: custom projection to general functions of state.\n\nds = Systems.lorenz96(5)\nprojection(u) = [sum(u), sqrt(u[1]^2 + u[2]^2)]\ncomplete_state(y) = repeat([y[1]/5], 5)\npds = # same as in above example...\n\n\n\n\n\n","category":"type"},{"location":"dynsysref/#DynamicalSystemsBase.ArbitrarySteppable","page":"DynamicalSystem reference","title":"DynamicalSystemsBase.ArbitrarySteppable","text":"ArbitrarySteppable <: DiscreteTimeDynamicalSystem\nArbitrarySteppable(\n    model, step!, extract_state, extract_parameters, reset_model!;\n    isdeterministic = true, set_state = reinit!,\n)\n\nA dynamical system generated by an arbitrary \"model\" that can be stepped in-place with some function step!(model) for 1 step. The state of the model is extracted by the extract_state(model) -> u function The parameters of the model are extracted by the extract_parameters(model) -> p function. The system may be re-initialized, via reinit!, with the reset_model! user-provided function that must have the call signature\n\nreset_model!(model, u, p)\n\ngiven a (potentially new) state u and parameter container p, both of which will default to the initial ones in the reinit! call.\n\nArbitrarySteppable exists to provide the DynamicalSystems.jl interface to models from other packages that could be used within the DynamicalSystems.jl library. ArbitrarySteppable follows the DynamicalSystem interface with the following adjustments:\n\ninitial_time is always 0, as time counts the steps the model has taken since creation or last reinit! call.\nset_state! is the same as reinit! by default. If not, the keyword argument set_state is a function set_state(model, u) that sets the state of the model to u.\nThe keyword isdeterministic should be set properly, as it decides whether downstream algorithms should error or not.\n\n\n\n\n\n","category":"type"},{"location":"dynsysref/#Relevant-dynamical-systems-API","page":"DynamicalSystem reference","title":"Relevant dynamical systems API","text":"","category":"section"},{"location":"dynsysref/","page":"DynamicalSystem reference","title":"DynamicalSystem reference","text":"Here we state only the relevant API functions; others can be found in the DynamicalSystemsBase.jl documentation.","category":"page"},{"location":"dynsysref/","page":"DynamicalSystem reference","title":"DynamicalSystem reference","text":"step!(::DynamicalSystem, args...; kwargs...)\nreinit!(::DynamicalSystem, args...; kwargs...)\nset_parameter!","category":"page"},{"location":"dynsysref/#CommonSolve.step!-Tuple{DynamicalSystem, Vararg{Any}}","page":"DynamicalSystem reference","title":"CommonSolve.step!","text":"step!(ds::DiscreteTimeDynamicalSystem [, n::Integer]) → ds\n\nEvolve the discrete time dynamical system for 1 or n steps.\n\nstep!(ds::ContinuousTimeDynamicalSystem, [, dt::Real [, stop_at_tdt]]) → ds\n\nEvolve the continuous time dynamical system for one integration step.\n\nAlternatively, if a dt is given, then progress the integration until there is a temporal difference ≥ dt (so, step at least for dt time).\n\nWhen true is passed to the optional third argument, the integration advances for exactly dt time.\n\n\n\n\n\n","category":"method"},{"location":"dynsysref/#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}","page":"DynamicalSystem reference","title":"SciMLBase.reinit!","text":"reinit!(ds::DynamicalSystem, u = initial_state(ds); kwargs...) → ds\n\nReset the status of ds, so that it is as if it has be just initialized with initial state u. Practically every function of the ecosystem that evolves ds first calls this function on it. Besides the new initial state u, you can also configure the keywords t0 = initial_time(ds) and p = current_parameters(ds).\n\nNote the default settings: the state and time are the initial, but the parameters are the current.\n\nThe special method reinit!(ds, ::Nothing; kwargs...) is also available, which does nothing and leaves the system as is. This is so that downstream functions that call reinit! can still be used without resetting the system but rather continuing from its exact current state.\n\n\n\n\n\n","category":"method"},{"location":"dynsysref/#DynamicalSystemsBase.set_parameter!","page":"DynamicalSystem reference","title":"DynamicalSystemsBase.set_parameter!","text":"set_parameter!(ds::DynamicalSystem, index, value)\n\nChange a parameter of ds given the index it has in the parameter container and the value to set it to. This function works for both array/dictionary containers as well as composite types. In the latter case index needs to be a Symbol.\n\n\n\n\n\n","category":"function"},{"location":"dynsysref/#StateSpaceSet-reference","page":"DynamicalSystem reference","title":"StateSpaceSet reference","text":"","category":"section"},{"location":"dynsysref/","page":"DynamicalSystem reference","title":"DynamicalSystem reference","text":"StateSpaceSet","category":"page"},{"location":"dynsysref/#StateSpaceSets.StateSpaceSet","page":"DynamicalSystem reference","title":"StateSpaceSets.StateSpaceSet","text":"StateSpaceSet{D, T} <: AbstractStateSpaceSet{D,T}\n\nA dedicated interface for sets in a state space. It is an ordered container of equally-sized points of length D. Each point is represented by SVector{D, T}. The data are a standard Julia Vector{SVector}, and can be obtained with vec(ssset::StateSpaceSet). Typically the order of points in the set is the time direction, but it doesn't have to be.\n\nWhen indexed with 1 index, StateSpaceSet is like a vector of points. When indexed with 2 indices it behaves like a matrix that has each of the columns be the timeseries of each of the variables. When iterated over, it iterates over its contained points. See description of indexing below for more.\n\nStateSpaceSet also supports almost all sensible vector operations like append!, push!, hcat, eachrow, among others.\n\nDescription of indexing\n\nIn the following let i, j be integers, typeof(X) <: AbstractStateSpaceSet and v1, v2 be <: AbstractVector{Int} (v1, v2 could also be ranges, and for performance benefits make v2 an SVector{Int}).\n\nX[i] == X[i, :] gives the ith point (returns an SVector)\nX[v1] == X[v1, :], returns a StateSpaceSet with the points in those indices.\nX[:, j] gives the jth variable timeseries (or collection), as Vector\nX[v1, v2], X[:, v2] returns a StateSpaceSet with the appropriate entries (first indices being \"time\"/point index, while second being variables)\nX[i, j] value of the jth variable, at the ith timepoint\n\nUse Matrix(ssset) or StateSpaceSet(matrix) to convert. It is assumed that each column of the matrix is one variable. If you have various timeseries vectors x, y, z, ... pass them like StateSpaceSet(x, y, z, ...). You can use columns(dataset) to obtain the reverse, i.e. all columns of the dataset in a tuple.\n\n\n\n\n\n","category":"type"},{"location":"examples/#Examples-for-Attractors.jl","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Note that the examples utilize some convenience plotting functions offered by Attractors.jl which come into scope when using Makie (or any of its backends such as CairoMakie), see the visualization utilities for more.","category":"page"},{"location":"examples/#Newton's-fractal-(basins-of-2D-map)","page":"Examples for Attractors.jl","title":"Newton's fractal (basins of 2D map)","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using Attractors\nfunction newton_map(z, p, n)\n    z1 = z[1] + im*z[2]\n    dz1 = newton_f(z1, p[1])/newton_df(z1, p[1])\n    z1 = z1 - dz1\n    return SVector(real(z1), imag(z1))\nend\nnewton_f(x, p) = x^p - 1\nnewton_df(x, p)= p*x^(p-1)\n\nds = DiscreteDynamicalSystem(newton_map, [0.1, 0.2], [3.0])\nxg = yg = range(-1.5, 1.5; length = 400)\n# Use non-sparse for using `basins_of_attraction`\nmapper = AttractorsViaRecurrences(ds, (xg, yg);\n    sparse = false, mx_chk_lost = 1000\n)\nbasins, attractors = basins_of_attraction(mapper; show_progress = false)\nbasins","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"attractors","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Now let's plot this as a heatmap, and on top of the heatmap, let's scatter plot the attractors. We do this in one step by utilizing one of the pre-defined plotting functions offered by Attractors.jl","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using CairoMakie\nxg = yg = range(-1.5, 1.5; length = 400)\ngrid = (xg, yg)\nfig = heatmap_basins_attractors(grid, basins, attractors)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Instead of computing the full basins, we could get only the fractions of the basins of attractions using basins_fractions, which is typically the more useful thing to do in a high dimensional system. In such cases it is also typically more useful to define a sampler that generates initial conditions on the fly instead of pre-defining some initial conditions (as is done in basins_of_attraction. This is simple to do:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"\ngrid = (xg, yg)\nmapper = AttractorsViaRecurrences(ds, grid;\n    sparse = false, mx_chk_lost = 1000\n)\n\nsampler, = statespace_sampler(grid)\n\nbasins = basins_fractions(mapper, sampler)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"in this case, to also get the attractors we simply extract them from the underlying storage of the mapper:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"attractors = extract_attractors(mapper)","category":"page"},{"location":"examples/#Minimal-Fatal-Shock","page":"Examples for Attractors.jl","title":"Minimal Fatal Shock","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Finding Minimal Fatal Shock for some point u0 on example of Newton's fractal attractors","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"attractors = extract_attractors(mapper)\nshocks = Dict()\nalgo_bb = Attractors.MFSBlackBoxOptim()\nfor atr in values(attractors)\n    u0 = vec(atr)[1]\n    shocks[u0] = minimal_fatal_shock(mapper, u0, (-1.5,1.5), algo_bb)\n\nend\nshocks","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"To visualize results we can make use of previously defined heatmap","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"ax =  content(fig[1,1])\nfor (atr, shock) in shocks\n    lines!(ax, [atr[1], atr[1] + shock]; color = :orange)\nend\nfig","category":"page"},{"location":"examples/#Fractality-of-2D-basins-of-the-(4D)-magnetic-pendulum","page":"Examples for Attractors.jl","title":"Fractality of 2D basins of the (4D) magnetic pendulum","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"In this section we will calculate the basins of attraction of the four-dimensional magnetic pendulum. We know that the attractors of this system are all individual fixed points on the (x, y) plane so we will only compute the basins there. We can also use this opportunity to highlight a different method, the AttractorsViaProximity which works when we already know where the attractors are. Furthermore we will also use a ProjectedDynamicalSystem to project the 4D system onto a 2D plane, saving a lot of computational time!","category":"page"},{"location":"examples/#Computing-the-basins","page":"Examples for Attractors.jl","title":"Computing the basins","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"First we need to load in the magnetic pendulum from the predefined dynamical systems library","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using Attractors, CairoMakie\nusing PredefinedDynamicalSystems\nds = PredefinedDynamicalSystems.magnetic_pendulum(d=0.2, α=0.2, ω=0.8, N=3)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Then, we create a projected system on the x-y plane","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"psys = ProjectedDynamicalSystem(ds, [1, 2], [0.0, 0.0])","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"For this systems we know the attractors are close to the magnet positions. The positions can be obtained from the equations of the system, provided that one has seen the source code (not displayed here), like so:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"attractors = Dict(i => StateSpaceSet([dynamic_rule(ds).magnets[i]]) for i in 1:3)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"and then create a","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"mapper = AttractorsViaProximity(psys, attractors)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"and as before, get the basins of attraction","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"xg = yg = range(-4, 4; length = 201)\ngrid = (xg, yg)\nbasins, = basins_of_attraction(mapper, grid; show_progress = false)\n\nheatmap_basins_attractors(grid, basins, attractors)","category":"page"},{"location":"examples/#Computing-the-uncertainty-exponent","page":"Examples for Attractors.jl","title":"Computing the uncertainty exponent","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Let's now calculate the uncertainty_exponent for this system as well. The calculation is straightforward:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using CairoMakie\nε, f_ε, α = uncertainty_exponent(basins)\nfig, ax = lines(log.(ε), log.(f_ε))\nax.title = \"α = $(round(α; digits=3))\"\nfig","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"The actual uncertainty exponent is the slope of the curve (α) and indeed we get an exponent near 0 as we know a-priory the basins have fractal boundaries for the magnetic pendulum.","category":"page"},{"location":"examples/#Computing-the-tipping-probabilities","page":"Examples for Attractors.jl","title":"Computing the tipping probabilities","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"We will compute the tipping probabilities using the magnetic pendulum's example as the \"before\" state. For the \"after\" state we will change the γ parameter of the third magnet to be so small, its basin of attraction will virtually disappear. As we don't know when the basin of the third magnet will disappear, we switch the attractor finding algorithm back to AttractorsViaRecurrences.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"set_parameter!(psys, :γs, [1.0, 1.0, 0.1])\nmapper = AttractorsViaRecurrences(psys, (xg, yg); Δt = 1)\nbasins_after, attractors_after = basins_of_attraction(\n    mapper, (xg, yg); show_progress = false\n)\n# matching attractors is important!\nrmap = match_statespacesets!(attractors_after, attractors)\n# Don't forget to update the labels of the basins as well!\nreplace!(basins_after, rmap...)\n\n# now plot\nheatmap_basins_attractors(grid, basins_after, attractors_after)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"And let's compute the tipping \"probabilities\":","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"P = tipping_probabilities(basins, basins_after)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"As you can see P has size 3×2, as after the change only 2 attractors have been identified in the system (3 still exist but our state space discretization isn't fine enough to find the 3rd because it has such a small basin). Also, the first row of P is 50% probability to each other magnet, as it should be due to the system's symmetry.","category":"page"},{"location":"examples/#D-basins-via-recurrences","page":"Examples for Attractors.jl","title":"3D basins via recurrences","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"To showcase the true power of AttractorsViaRecurrences we need to use a system whose attractors span higher-dimensional space. An example is","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using Attractors\nusing PredefinedDynamicalSystems\nds = PredefinedDynamicalSystems.thomas_cyclical(b = 0.1665)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"which, for this parameter, contains 3 coexisting attractors which are entangled periodic orbits that span across all three dimensions.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"To compute the basins we define a three-dimensional grid and call on it basins_of_attraction.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"# This computation takes about an hour\nxg = yg = zg = range(-6.0, 6.0; length = 251)\nmapper = AttractorsViaRecurrences(ds, (xg, yg, zg); sparse = false)\nbasins, attractors = basins_of_attraction(mapper)\nattractors","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Dict{Int16, StateSpaceSet{3, Float64}} with 5 entries:\n  5 => 3-dimensional StateSpaceSet{Float64} with 1 points\n  4 => 3-dimensional StateSpaceSet{Float64} with 379 points\n  6 => 3-dimensional StateSpaceSet{Float64} with 1 points\n  2 => 3-dimensional StateSpaceSet{Float64} with 538 points\n  3 => 3-dimensional StateSpaceSet{Float64} with 537 points\n  1 => 3-dimensional StateSpaceSet{Float64} with 1 points","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Note: the reason we have 6 attractors here is because the algorithm also finds 3 unstable fixed points and labels them as attractors. This happens because we have provided initial conditions on the grid xg, yg, zg that start exactly on the unstable fixed points, and hence stay there forever, and hence are perceived as attractors by the recurrence algorithm. As you will see in the video below, they don't have any basin fractions","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"The basins of attraction are very complicated. We can try to visualize them by animating the 2D slices at each z value, to obtain:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"<video width=\"75%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/attractors/cyclical_basins.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Then, we visualize the attractors to obtain:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"<video width=\"75%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/attractors/cyclical_attractors.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"In the animation above, the scattered points are the attractor values the function AttractorsViaRecurrences found by itself. Of course, for the periodic orbits these points are incomplete. Once the function's logic understood we are on an attractor, it stops computing. However, we also simulated lines, by evolving initial conditions colored appropriately with the basins output.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"The animation was produced with the code:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using GLMakie\nfig = Figure()\ndisplay(fig)\nax = fig[1,1] = Axis3(fig; title = \"found attractors\")\ncmap = cgrad(:dense, 6; categorical = true)\n\nfor i in keys(attractors)\n    tr = attractors[i]\n    markersize = length(attractors[i]) > 10 ? 2000 : 6000\n    marker = length(attractors[i]) > 10 ? :circle : :rect\n    scatter!(ax, columns(tr)...; markersize, marker, transparency = true, color = cmap[i])\n    j = findfirst(isequal(i), bsn)\n    x = xg[j[1]]\n    y = yg[j[2]]\n    z = zg[j[3]]\n    tr = trajectory(ds, 100, SVector(x,y,z); Ttr = 100)\n    lines!(ax, columns(tr)...; linewidth = 1.0, color = cmap[i])\nend\n\na = range(0, 2π; length = 200) .+ π/4\n\nrecord(fig, \"cyclical_attractors.mp4\", 1:length(a)) do i\n    ax.azimuth = a[i]\nend","category":"page"},{"location":"examples/#Basins-of-attraction-of-a-Poincaré-map","page":"Examples for Attractors.jl","title":"Basins of attraction of a Poincaré map","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"PoincareMap is just another discrete time dynamical system within the DynamicalSystems.jl ecosystem. With respect to Attractors.jl functionality, there is nothing special about Poincaré maps. You simply initialize one use it like any other type of system. Let's continue from the above example  of the Thomas cyclical system","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using Attractors\nusing PredefinedDynamicalSystems\nds = PredefinedDynamicalSystems.thomas_cyclical(b = 0.1665);","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"The three limit cycles attractors we have above become fixed points in the Poincaré map (for appropriately chosen hyperplanes). Since we already know the 3D structure of the basins, we can see that an appropriately chosen hyperplane is just the plane z = 0. Hence, we define a Poincaré map on this plane:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"plane = (3, 0.0)\npmap = PoincareMap(ds, plane)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"We define the same grid as before, but now only we only use the x-y coordinates. This is because we can utilize the special reinit! method of the PoincareMap, that allows us to initialize a new state directly on the hyperplane (and then the remaining variable of the dynamical system takes its value from the hyperplane itself).","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"xg = yg = range(-6.0, 6.0; length = 251)\ngrid = (xg, yg)\nmapper = AttractorsViaRecurrences(pmap, grid; sparse = false)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"All that is left to do is to call basins_of_attraction:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"basins, attractors = basins_of_attraction(mapper; show_progress = false);","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"heatmap_basins_attractors(grid, basins, attractors)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"just like in the example above, there is a fourth attractor with 0 basin fraction. This is an unstable fixed point, and exists exactly because we provided a grid with the unstable fixed point exactly on this grid","category":"page"},{"location":"examples/#Irregular-grid-for-AttractorsViaRecurrences","page":"Examples for Attractors.jl","title":"Irregular grid for AttractorsViaRecurrences","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"It is possible to provide an irregularly spaced grid to AttractorsViaRecurrences. This can make algorithm performance better for continuous time systems where the state space flow has significantly different speed in some state space regions versus others.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"In the following example the dynamical system has only one attractor: a limit cycle. However, near the origin (0, 0) the timescale of the dynamics becomes very slow. As the trajectory is stuck there for quite a while, the recurrences algorithm may identify this region as an \"attractor\" (incorrectly). The solutions vary and can be to increase drastically the max time checks for finding attractors, or making the grid much more fine. Alternatively, one can provide a grid that is only more fine near the origin and not fine elsewhere.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"The example below highlights that for rather coarse settings of grid and convergence thresholds, using a grid that is finer near (0, 0) gives correct results:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using Attractors, CairoMakie\n\nfunction predator_prey_fastslow(u, p, t)\n    α, γ, ϵ, ν, h, K, m = p\n    N, P = u\n    du1 = α*N*(1 - N/K) - γ*N*P / (N+h)\n    du2 = ϵ*(ν*γ*N*P/(N+h) - m*P)\n    return SVector(du1, du2)\nend\nγ = 2.5\nh = 1\nν = 0.5\nm = 0.4\nϵ = 1.0\nα = 0.8\nK = 15\nu0 = rand(2)\np0 = [α, γ, ϵ, ν, h, K, m]\nds = CoupledODEs(predator_prey_fastslow, u0, p0)\n\nfig = Figure()\nax = Axis(fig[1,1])\n\n# when pow > 1, the grid is finer close to zero\nfor pow in (1, 2)\n    xg = yg = range(0, 18.0^(1/pow); length = 200).^pow\n    mapper = AttractorsViaRecurrences(ds, (xg, yg);\n        Dt = 0.1, sparse = true,\n        mx_chk_fnd_att = 10, mx_chk_loc_att = 10,\n        mx_chk_safety = 1000,\n    )\n\n    # Find attractor and its fraction (fraction is always 1 here)\n    sampler, _ = statespace_sampler(HRectangle(zeros(2), fill(18.0, 2)), 42)\n    fractions = basins_fractions(mapper, sampler; N = 100, show_progress = false)\n    attractors = extract_attractors(mapper)\n    scatter!(ax, vec(attractors[1]); markersize = 16/pow, label = \"pow = $(pow)\")\nend\n\naxislegend(ax)\n\nfig","category":"page"},{"location":"examples/#Subdivision-Based-Grid-for-AttractorsViaRecurrences","page":"Examples for Attractors.jl","title":"Subdivision Based Grid for AttractorsViaRecurrences","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"To achieve even better results for this kind of problematic systems than with previuosly introduced Irregular Grids  we provide a functionality to construct Subdivision Based Grids in which one can obtain more coarse or dense structure not only along some axis but for a specific regions where the state space flow has significantly different speed. subdivided_based_grid enables automatic evaluation of velocity vectors for regions of originally user specified grid to further treat those areas as having more dense or coarse structure than others.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using Attractors, CairoMakie\n\nfunction predator_prey_fastslow(u, p, t)\n    α, γ, ϵ, ν, h, K, m = p\n    N, P = u\n    du1 = α*N*(1 - N/K) - γ*N*P / (N+h)\n    du2 = ϵ*(ν*γ*N*P/(N+h) - m*P)\nreturn SVector(du1, du2)\nend\nγ = 2.5\nh = 1\nν = 0.5\nm = 0.4\nϵ = 1.0\nα = 0.8\nK = 15\nu0 = rand(2)\np0 = [α, γ, ϵ, ν, h, K, m]\nds = CoupledODEs(predator_prey_fastslow, u0, p0)\n\nxg = yg = range(0, 18, length = 30)\n# Construct `Subdivision Based Grid`\ngrid = subdivision_based_grid(ds, (xg, yg))\ngrid.lvl_array","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"The constructed array corresponds to levels of dicretization for specific regions of the grid as a powers of 2, meaning that if area index is assigned to be 3, for example, the algorithm will treat the region as one being 2^3 = 8 times more dense than originally user provided grid (xg, yg).","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Now upon the construction of this structure, one can simply pass it into mapper function as usual.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"fig = Figure()\nax = Axis(fig[1,1])\n# passing SubdivisionBasedGrid into mapper\nmapper = AttractorsViaRecurrences(ds, grid;\n        Dt = 0.1, sparse = true,\n        mx_chk_fnd_att = 10, mx_chk_loc_att = 10,\n        mx_chk_safety = 1000,\n    )\n\n# Find attractor and its fraction (fraction is always 1 here)\nsampler, _ = statespace_sampler(HRectangle(zeros(2), fill(18.0, 2)), 42)\nfractions = basins_fractions(mapper, sampler; N = 100, show_progress = false)\nattractors_SBD = extract_attractors(mapper)\nscatter!(ax, vec(attractors_SBD[1]); label = \"SubdivisionBasedGrid\")\n\n\n# to compare the results we also construct RegularGrid of same length here\nxg = yg = range(0, 18, length = 30)\nmapper = AttractorsViaRecurrences(ds, (xg, yg);\n        Dt = 0.1, sparse = true,\n        mx_chk_fnd_att = 10, mx_chk_loc_att = 10,\n        mx_chk_safety = 1000,\n    )\n\nsampler, _ = statespace_sampler(HRectangle(zeros(2), fill(18.0, 2)), 42)\nfractions = basins_fractions(mapper, sampler; N = 100, show_progress = false)\nattractors_reg = extract_attractors(mapper)\nscatter!(ax, vec(attractors_reg[1]); label = \"RegularGrid\")\n\naxislegend(ax)\nfig\n","category":"page"},{"location":"examples/#Basin-fractions-continuation-in-the-magnetic-pendulum","page":"Examples for Attractors.jl","title":"Basin fractions continuation in the magnetic pendulum","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Perhaps the simplest application of continuation is to produce a plot of how the fractions of attractors change as we continuously change the parameter we changed above to calculate tipping probabilities.","category":"page"},{"location":"examples/#Computing-the-fractions","page":"Examples for Attractors.jl","title":"Computing the fractions","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"This is what the following code does:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"# initialize projected magnetic pendulum\nusing Attractors, PredefinedDynamicalSystems\nusing Random: Xoshiro\nds = Systems.magnetic_pendulum(; d = 0.3, α = 0.2, ω = 0.5)\nxg = yg = range(-3, 3; length = 101)\nds = ProjectedDynamicalSystem(ds, 1:2, [0.0, 0.0])\n# Choose a mapper via recurrences\nmapper = AttractorsViaRecurrences(ds, (xg, yg); Δt = 1.0)\n# What parameter to change, over what range\nγγ = range(1, 0; length = 101)\nprange = [[1, 1, γ] for γ in γγ]\npidx = :γs\n# important to make a sampler that respects the symmetry of the system\nregion = HSphere(3.0, 2)\nsampler, = statespace_sampler(region, 1234)\n# continue attractors and basins:\n# `Inf` threshold fits here, as attractors move smoothly in parameter space\nrsc = RecurrencesFindAndMatch(mapper; threshold = Inf)\nfractions_curves, attractors_info = continuation(\n    rsc, prange, pidx, sampler;\n    show_progress = false, samples_per_parameter = 100\n)\n# Show some characteristic fractions:\nfractions_curves[[1, 50, 101]]","category":"page"},{"location":"examples/#Plotting-the-fractions","page":"Examples for Attractors.jl","title":"Plotting the fractions","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"We visualize them using a predefined function that you can find in docs/basins_plotting.jl","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"# careful; `prange` isn't a vector of reals!\nplot_basins_curves(fractions_curves, γγ)","category":"page"},{"location":"examples/#Fixed-point-curves","page":"Examples for Attractors.jl","title":"Fixed point curves","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"A by-product of the analysis is that we can obtain the curves of the position of fixed points for free. However, only the stable branches can be obtained!","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using CairoMakie\nfig = Figure()\nax = Axis(fig[1,1]; xlabel = L\"\\gamma_3\", ylabel = \"fixed point\")\n# choose how to go from attractor to real number representation\nfunction real_number_repr(attractor)\n    p = attractor[1]\n    return (p[1] + p[2])/2\nend\n\nfor (i, γ) in enumerate(γγ)\n    for (k, attractor) in attractors_info[i]\n        scatter!(ax, γ, real_number_repr(attractor); color = Cycled(k))\n    end\nend\nfig","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"as you can see, two of the three fixed points, and their stability, do not depend at all on the parameter value, since this parameter value tunes the magnetic strength of only the third magnet. Nevertheless, the fractions of basin of attraction of all attractors depend strongly on the parameter. This is a simple example that highlights excellently how this new approach we propose here should be used even if one has already done a standard linearized bifurcation analysis.","category":"page"},{"location":"examples/#Extinction-of-a-species-in-a-multistable-competition-model","page":"Examples for Attractors.jl","title":"Extinction of a species in a multistable competition model","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"In this advanced example we utilize both RecurrencesFindAndMatch and aggregate_attractor_fractions in analyzing species extinction in a dynamical model of competition between multiple species. The final goal is to show the percentage of how much of the state space leads to the extinction or not of a pre-determined species, as we vary a parameter. The model however displays extreme multistability, a feature we want to measure and preserve before aggregating information into \"extinct or not\".","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"To measure and preserve this we will apply RecurrencesFindAndMatch as-is first. Then we can aggregate information. First we have","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using Attractors, OrdinaryDiffEq\nusing PredefinedDynamicalSystems\nusing Random: Xoshiro\n# arguments to algorithms\nsamples_per_parameter = 1000\ntotal_parameter_values = 101\ndiffeq = (alg = Vern9(), reltol = 1e-9, abstol = 1e-9, maxiters = Inf)\nrecurrences_kwargs = (; Δt= 1.0, mx_chk_fnd_att=9, diffeq);\n# initialize dynamical syste and sampler\nds = PredefinedDynamicalSystems.multispecies_competition() # 8-dimensional\nds = CoupledODEs(ODEProblem(ds), diffeq)\n# define grid in state space\nxg = range(0, 60; length = 300)\ngrid = ntuple(x -> xg, 8)\nprange = range(0.2, 0.3; length = total_parameter_values)\npidx = :D\nsampler, = statespace_sampler(grid, 1234)\n# initialize mapper\nmapper = AttractorsViaRecurrences(ds, grid; recurrences_kwargs...)\n# perform continuation of attractors and their basins\ncontinuation = RecurrencesFindAndMatch(mapper; threshold = Inf)\nfractions_curves, attractors_info = continuation(\n    continuation, prange, pidx, sampler;\n    show_progress = true, samples_per_parameter\n);\nplot_basins_curves(fractions_curves, prange; separatorwidth = 1)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"this example is not actually run when building the docs, because it takes about 60 minutes to complete depending on the computer; we load precomputed results instead","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"As you can see, the system has extreme multistability with 64 unique attractors (according to the default matching behavior in RecurrencesFindAndMatch; a stricter matching with less than Inf threshold would generate more \"distinct\" attractors). One could also isolate a specific parameter slice, and do the same as what we do in the Fractality of 2D basins of the (4D) magnetic pendulum example, to prove that the basin boundaries are fractal, thereby indeed confirming the paper title \"Fundamental Unpredictability\".","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Regardless, we now want to continue our analysis to provide a figure similar to the above but only with two colors: fractions of attractors where a species is extinct or not. Here's how:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"species = 3 # species we care about its existence\n\nfeaturizer = (A) -> begin\n    i = isextinct(A, species)\n    return SVector(Int32(i))\nend\nisextinct(A, idx = unitidxs) = all(a -> a <= 1e-2, A[:, idx])\n\n# `minneighbors = 1` is crucial for grouping single attractors\ngroupingconfig = GroupViaClustering(; min_neighbors=1, optimal_radius_method=0.5)\n\naggregated_fractions, aggregated_info = aggregate_attractor_fractions(\n    fractions_curves, attractors_info, featurizer, groupingconfig\n)\n\nplot_basins_curves(aggregated_fractions, prange;\n    separatorwidth = 1, colors = [\"green\", \"black\"],\n    labels = Dict(1 => \"extinct\", 2 => \"alive\"),\n)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"(in hindsight, the labels are reversed; attractor 1 is the alive one, but oh well)","category":"page"},{"location":"examples/#Trivial-featurizing-and-grouping-for-basins-fractions","page":"Examples for Attractors.jl","title":"Trivial featurizing and grouping for basins fractions","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"This is a rather trivial example showcasing the usage of AttractorsViaFeaturizing. Let us use once again the magnetic pendulum example. For it, we have a really good idea of what features will uniquely describe each attractor: the last points of a trajectory (which should be very close to the magnetic the trajectory converged to). To provide this information to the AttractorsviaFeaturizing we just create a julia function that returns this last point","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using Attractors\nusing PredefinedDynamicalSystems\n\nds = Systems.magnetic_pendulum(d=0.2, α=0.2, ω=0.8, N=3)\npsys = ProjectedDynamicalSystem(ds, [1, 2], [0.0, 0.0])\n\nfunction featurizer(X, t)\n    return X[end]\nend\n\nmapper = AttractorsViaFeaturizing(psys, featurizer; Ttr = 200, T = 1)\n\nxg = yg = range(-4, 4; length = 101)\n\nregion = HRectangle([-4, 4], [4, 4])\nsampler, = statespace_sampler(region)\n\nfs = basins_fractions(mapper, sampler; show_progress = false)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"As expected, the fractions are each about 1/3 due to the system symmetry.","category":"page"},{"location":"examples/#Featurizing-and-grouping-across-parameters-(MCBB)","page":"Examples for Attractors.jl","title":"Featurizing and grouping across parameters (MCBB)","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Here we showcase the example of the Monte Carlo Basin Bifurcation publication. For this, we will use FeaturizeGroupAcrossParameter while also providing a par_weight = 1 keyword. However, we will not use a network of 2nd order Kuramoto oscillators (as done in the paper by Gelbrecht et al.) because it is too costly to run on CI. Instead, we will use \"dummy\" system which we know analytically the attractors and how they behave versus a parameter.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"the Henon map and try to group attractors into period 1 (fixed point), period 3, and divergence to infinity. We will also use a pre-determined optimal radius for clustering, as we know a-priory the expected distances of features in feature space (due to the contrived form of the featurizer function below).","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using Attractors, Random\n\nfunction dumb_map(dz, z, p, n)\n    x, y = z\n    r = p[1]\n    if r < 0.5\n        dz[1] = dz[2] = 0.0\n    else\n        if x > 0\n            dz[1] = r\n            dz[2] = r\n        else\n            dz[1] = -r\n            dz[2] = -r\n        end\n    end\n    return\nend\n\nr = 3.833\nds = DiscreteDynamicalSystem(dumb_map, [0., 0.], [r])","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"sampler, = statespace_sampler(HRectangle([-3.0, -3.0], [3.0, 3.0]), 1234)\n\nrrange = range(0, 2; length = 21)\nridx = 1\n\nfeaturizer(a, t) = a[end]\nclusterspecs = GroupViaClustering(optimal_radius_method = \"silhouettes\", max_used_features = 200)\nmapper = AttractorsViaFeaturizing(ds, featurizer, clusterspecs; T = 20, threaded = true)\ngap = FeaturizeGroupAcrossParameter(mapper; par_weight = 1.0)\nfractions_curves, clusters_info = continuation(\n    gap, rrange, ridx, sampler; show_progress = false\n)\nfractions_curves","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Looking at the information of the \"attractors\" (here the clusters of the grouping procedure) does not make it clear which label corresponds to which kind of attractor, but we can look at the:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"clusters_info","category":"page"},{"location":"examples/#Using-histograms-and-histogram-distances-as-features","page":"Examples for Attractors.jl","title":"Using histograms and histogram distances as features","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"One of the aspects discussed in the original MCBB paper and implementation was the usage of histograms of the means of the variables of a dynamical system as the feature vector. This is useful in very high dimensional systems, such as oscillator networks, where the histogram of the means is significantly different in synchronized or unsychronized states.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"This is possible to do with current interface without any modifications, by using two more packages: ComplexityMeasures.jl to compute histograms, and Distances.jl for the Kullback-Leibler divergence (or any other measure of distance in the space of probability distributions you fancy).","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"The only code we need to write to achieve this feature is a custom featurizer and providing an alternative distance to GroupViaClustering. The code would look like this:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using Distances: KLDivergence\nusing ComplexityMeasures: ValueHistogram, FixedRectangularBinning, probabilities\n\n# you decide the binning for the histogram, but for a valid estimation of\n# distances, all histograms must have exactly the same bins, and hence be\n# computed with fixed ranges, i.e., using the `FixedRectangularBinning`\nconst binning = FixedRectangularBinning(range(-5, 5; length = 11))\n\nfunction histogram_featurizer(A, t)\n    ms = mean.(columns(A)) # vector of mean of each variable\n    p = probabilities(ValueHistogram(binning), ms) # this is the histogram\n    return vec(p) # because Distances.jl doesn't know `Probabilities`\nend\n\ngconfig = GroupViaClustering(;\n    clust_distance_metric = KLDivergence(), # or any other PDF distance\n)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"You can then pass the histogram_featurizer and gconfig to an AttractorsViaFeaturizing and use the rest of the library as usual.","category":"page"},{"location":"attractors/#Finding-Attractors","page":"Finding Attractors","title":"Finding Attractors","text":"","category":"section"},{"location":"attractors/","page":"Finding Attractors","title":"Finding Attractors","text":"Attractors.jl defines a generic interface for finding attractors of dynamical systems. One first decides the instance of DynamicalSystem they need. Then, an instance of AttractorMapper is created from this dynamical system. This mapper instance can be used to compute e.g., basins_of_attraction, and the output can be further analyzed to get e.g., the basin_entropy.","category":"page"},{"location":"attractors/","page":"Finding Attractors","title":"Finding Attractors","text":"AttractorMapper","category":"page"},{"location":"attractors/#Attractors.AttractorMapper","page":"Finding Attractors","title":"Attractors.AttractorMapper","text":"AttractorMapper(ds::DynamicalSystem, args...; kwargs...) → mapper\n\nSubtypes of AttractorMapper are structures that map initial conditions of ds to attractors. Currently available mapping methods:\n\nAttractorsViaProximity\nAttractorsViaRecurrences\nAttractorsViaFeaturizing\n\nAll AttractorMapper subtypes can be used with basins_fractions or basins_of_attraction.\n\nIn addition, some mappers can be called as a function of an initial condition:\n\nlabel = mapper(u0)\n\nand this will on the fly compute and return the label of the attractor u0 converges at. The mappers that can do this are:\n\nAttractorsViaProximity\nAttractorsViaRecurrences\nAttractorsViaFeaturizing with the GroupViaHistogram configuration.\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Recurrences","page":"Finding Attractors","title":"Recurrences","text":"","category":"section"},{"location":"attractors/","page":"Finding Attractors","title":"Finding Attractors","text":"AttractorsViaRecurrences\nautomatic_Δt_basins\nSubdivisionBasedGrid\nsubdivision_based_grid","category":"page"},{"location":"attractors/#Attractors.AttractorsViaRecurrences","page":"Finding Attractors","title":"Attractors.AttractorsViaRecurrences","text":"AttractorsViaRecurrences(ds::DynamicalSystem, grid::Tuple; kwargs...)\n\nMap initial conditions of ds to attractors by identifying attractors on the fly based on recurrences in the state space, as outlined by Datseris & Wagemakers (Datseris and Wagemakers, 2022).\n\ngrid is instructions for partitioning the state space into finite-sized cells so that a finite state machine can operate on top of it. Possibilities are:\n\nA tuple of sorted AbstractRanges for a regular grid.\n\nExample is grid = (xg, yg) where xg = yg = range(-5, 5; length = 100)   for a two-dimensional system\n\nA tuple of sorted AbstractVectors for an irregular grid, for example\n\ngrid = (xg, yg) with xg = vcat(range(-5, -2; length = 50), range(-2, 5; length = 50)),   yg = range(-5, 5; length = 100).\n\nAn instance of the special grid type\n\nSubdividedBasedGrid, which can be created either manually or by using subdivision_based_grid.   This automatically analyzes and adapts grid discretization   levels in accordance with state space flow speed in different regions.\n\nThe grid has to be the same dimensionality as the state space, use a ProjectedDynamicalSystem if you want to search for attractors in a lower dimensional subspace.\n\nKeyword arguments\n\nsparse = true: control the storage type of the state space grid. If true,  uses a sparse array, whose memory usage is in general more efficient than a regular  array obtained with sparse=false. In practice, the sparse representation should  always be preferred when searching for basins_fractions. Only for very low  dimensional systems and for computing the full basins_of_attraction the  non-sparse version should be used.\n\nTime evolution configuration\n\nTtr = 0: Skip a transient before the recurrence routine begins.\nΔt: Approximate integration time step (second argument of the step! function). The keyword Dt can also be used instead if Δ (\\Delta) is not accessible. It is 1 for discrete time systems. For continuous systems, an automatic value is calculated using automatic_Δt_basins. For very fine grids, this can become very small, much smaller than the typical integrator internal step size in case of adaptive integrators. In such cases, use force_non_adaptive = true.\nforce_non_adaptive = false: Only used if the input dynamical system is CoupledODEs. If true the additional keywords adaptive = false, dt = Δt are given as diffeq to the CoupledODEs. This means that adaptive integration is turned off and Δt is used as the ODE integrator timestep. This is useful in (1) very fine grids, and (2) if some of the attractors are limit cycles. We have noticed that in this case the integrator timestep becomes commensurate with the limit cycle period, leading to incorrectly counting the limit cycle as more than one attractor.\n\nFinite state machine configuration\n\nmx_chk_att = 2: Μaximum checks of consecutives hits of an existing attractor cell before declaring convergence to that existing attractor.\nmx_chk_hit_bas = 10: Maximum check of consecutive visits of the same basin of attraction before declaring convergence to an existing attractor. This is ignored if sparse = true, as basins are not stored internally.\nmx_chk_fnd_att = 100: Maximum check of consecutive visits to a previously visited unlabeled cell before declaring we have found a new attractor.\nmx_chk_loc_att = 100: Maximum check of consecutive visits to cells marked as a new attractor, during the attractor identification phase, before declaring we that we have identified the new attractor with sufficient cells.\nstore_once_per_cell = true: Control if multiple points in state space that belong to the same cell are stored or not in the attractor, after an attractor is found. If true, each visited cell will only store a point once, which is desirable for fixed points and limit cycles. If false, at least mx_chk_loc_att points are stored per attractor, leading to more densely stored attractors, which may be desirable for instance in chaotic attractors.\nmx_chk_lost = 20: Maximum check of iterations outside the defined grid before we declare the orbit lost outside and hence assign it label -1.\nhorizon_limit = 1e6: If the norm of the integrator state reaches this limit we declare that the orbit diverged to infinity.\nmx_chk_safety = Int(1e6): A safety counter that is always increasing for each initial condition. Once exceeded, the algorithm assigns -1 and throws a warning. This clause exists to stop the algorithm never haulting for innappropriate grids, where a found attractor may intersect in the same cell with a new attractor the orbit traces (which leads to infinite resetting of all counters).\n\nDescription\n\nAn initial condition given to an instance of AttractorsViaRecurrences is iterated based on the integrator corresponding to ds. A recurrence in the state space means that the trajectory has converged to an attractor. This is the basis for finding attractors.\n\nA finite state machine (FSM) follows the trajectory in the state space, and constantly maps it to the given grid. The FSM decides when an initial condition has successfully converged into an attractor. An array, internally called \"basins\", stores the state of the FSM on the grid, according to the indexing system described in (Datseris and Wagemakers, 2022). As the system is integrated more and more, the information of the \"basins\" becomes richer and richer with more identified attractors or with grid cells that belong to basins of already found attractors. Notice that only in the special method basins_of_attraction(mapper::AttractorsViaRecurrences) the information of the attraction or exit basins is utilized. In other functions like basins_fractions only the attractor locations are utilized, as the basins themselves are not stored.\n\nThe iteration of a given initial condition continues until one of the following happens:\n\nThe trajectory hits mx_chk_fnd_att times in a row grid cells previously visited:  it is considered that an attractor is found and is labelled with a new ID. Then,  iteration continues a bit more until we have identified the attractor with sufficient  accuracy, i.e., until mx_chk_loc_att cells with the new ID have been visited.\nThe trajectory hits an already identified attractor mx_chk_att consecutive times:  the initial condition is numbered with the attractor's ID.\nThe trajectory hits a known basin mx_chk_hit_bas times in a row: the initial condition  belongs to that basin and is numbered accordingly. Notice that basins are stored and  used only when sparse = false.\nThe trajectory spends mx_chk_lost steps outside the defined grid or the norm  of the integrator state becomes > than horizon_limit: the initial  condition's label is set to -1.\nIf none of the above happens, the initial condition is labelled -1 after  and mx_chk_safety integrator steps.\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Attractors.automatic_Δt_basins","page":"Finding Attractors","title":"Attractors.automatic_Δt_basins","text":"automatic_Δt_basins(ds::DynamicalSystem, grid; N = 5000) → Δt\n\nCalculate an optimal Δt value for basins_of_attraction. This is done by evaluating the dynamic rule f (vector field) at N randomly chosen points within the bounding box of the grid. The average f is then compared with the average diagonal length of a grid cell and their ratio provides Δt.\n\nNotice that Δt should not be too small which happens typically if the grid resolution is high. It is okay if the trajectory skips a few cells. Also, Δt that is smaller than the internal step size of the integrator will cause a performance drop.\n\n\n\n\n\n","category":"function"},{"location":"attractors/#Attractors.SubdivisionBasedGrid","page":"Finding Attractors","title":"Attractors.SubdivisionBasedGrid","text":"SubdivisionBasedGrid(grid::NTuple{D, <:AbstractRange}, lvl_array::Array{Int, D})\n\nGiven a coarse grid tesselating the state space, construct a SubdivisionBasedGrid based on the given level array lvl_array. The level array is has non-negative integer values. Value 0 means that the corresponding cell of the coarse grid is not subdivided any further. Value n > 0 means that the corresponding cell will be subdivided in total 2^n times (along each dimension), resulting in finer cells within the original coarse cell.\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Attractors.subdivision_based_grid","page":"Finding Attractors","title":"Attractors.subdivision_based_grid","text":"subdivision_based_grid(ds::DynamicalSystem, grid; maxlevel = 4)\n\nConstruct a grid structure SubdivisionBasedGrid that can be directly passed as a grid to AttractorsViaRecurrences. The input grid is an orginally coarse grid (a tuple of AbstractRanges).\n\nThis approach is designed for continuous time systems in which different areas of the state space flow may have significantly different velocity. In case of originally coarse grids, this may lead AttractorsViaRecurrences being stuck in some state space regions with a small motion speed and false identification of attractors. To prevent this from happening we provide an algorithm expansion to dynamically evaluate different regions speed of motion to handle areas of the grid which should be more coarse or dense than others.\n\nTo achieve this, function make use of make_irregular_array which automatically constructs an array of discretization levels indices for a grid (a tuple of AbstractRanges) originally specified by user. Upon construction function automatically stores necessary parameters to further adopt mapping of initial conditions to specific grid density levels.\n\n\n\n\n\n","category":"function"},{"location":"attractors/#Proximity","page":"Finding Attractors","title":"Proximity","text":"","category":"section"},{"location":"attractors/","page":"Finding Attractors","title":"Finding Attractors","text":"AttractorsViaProximity","category":"page"},{"location":"attractors/#Attractors.AttractorsViaProximity","page":"Finding Attractors","title":"Attractors.AttractorsViaProximity","text":"AttractorsViaProximity(ds::DynamicalSystem, attractors::Dict [, ε]; kwargs...)\n\nMap initial conditions to attractors based on whether the trajectory reaches ε-distance close to any of the user-provided attractors. They have to be in a form of a dictionary mapping attractor labels to StateSpaceSets containing the attractors.\n\nThe system gets stepped, and at each step the minimum distance to all attractors is computed. If any of these distances is < ε, then the label of the nearest attractor is returned.\n\nIf an ε::Real is not provided by the user, a value is computed automatically as half of the minimum distance between all attractors. This operation can be expensive for large attractor StateSpaceSets. If length(attractors) == 1, then ε becomes 1/10 of the diagonal of the box containing the attractor. If length(attractors) == 1 and the attractor is a single point, an error is thrown.\n\nBecause in this method the attractors are already known to the user, the method can also be called supervised.\n\nKeywords\n\nTtr = 100: Transient time to first evolve the system for before checking for proximity.\nΔt = 1: Step time given to step!.\nhorizon_limit = 1e3: If the maximum distance of the trajectory from any of the given attractors exceeds this limit, it is assumed that the trajectory diverged (gets labelled as -1).\nmx_chk_lost = 1000: If the integrator has been stepped this many times without coming ε-near to any attractor,  it is assumed that the trajectory diverged (gets labelled as -1).\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Featurizing","page":"Finding Attractors","title":"Featurizing","text":"","category":"section"},{"location":"attractors/","page":"Finding Attractors","title":"Finding Attractors","text":"AttractorsViaFeaturizing","category":"page"},{"location":"attractors/#Attractors.AttractorsViaFeaturizing","page":"Finding Attractors","title":"Attractors.AttractorsViaFeaturizing","text":"AttractorsViaFeaturizing(\n    ds::DynamicalSystem, featurizer::Function,\n    grouping_config = GroupViaClustering(); kwargs...\n)\n\nInitialize a mapper that maps initial conditions to attractors using a featurizing and grouping approach. This is a supercase of the featurizing and clustering approach that is utilized by bSTAB (Stender and Hoffmann, 2021) and MCBB Gelbrecht2021. See AttractorMapper for how to use the mapper. This mapper also allows the syntax mapper(u0) but only if the grouping_config is not GroupViaClustering.\n\nfeaturizer is a function f(A, t) that takes as an input an integrated trajectoryA::StateSpaceSetand the corresponding time vectortand returns a vectorvof features describing the trajectory. For better performance, it is strongly recommended thatv  isa SVector{<:Real}`.\n\ngrouping_config is an instance of any subtype of GroupingConfig and decides how features will be grouped into attractors, see below.\n\nSee also the intermediate functions extract_features and group_features, which can be utilized when wanting to work directly with features.\n\nKeyword arguments\n\nT=100, Ttr=100, Δt=1: Propagated to trajectory.\nthreaded = true: Whether to run the generation of features over threads by integrating trajectories in parallel.\n\nDescription\n\nThe trajectory X of an initial condition is transformed into features. Each feature is a number useful in characterizing the attractor the initial condition ends up at, and distinguishing it from other attractors. Example features are the mean or standard deviation of some the dimensions of the trajectory, the entropy of some of the dimensions, the fractal dimension of X, or anything else you may fancy.\n\nAll feature vectors (each initial condition = 1 vector) are then grouped using one of the sevaral available grouping configurations. Each group is assumed to be a unique attractor, and hence each initial condition is labelled according to the group it is part of. The method thus relies on the user having at least some basic idea about what attractors to expect in order to pick the right features, and the right way to group them, in contrast to AttractorsViaRecurrences.\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Grouping-configurations","page":"Finding Attractors","title":"Grouping configurations","text":"","category":"section"},{"location":"attractors/#Grouping-types","page":"Finding Attractors","title":"Grouping types","text":"","category":"section"},{"location":"attractors/","page":"Finding Attractors","title":"Finding Attractors","text":"GroupingConfig\nGroupViaClustering\nGroupViaHistogram\nGroupViaNearestFeature","category":"page"},{"location":"attractors/#Attractors.GroupingConfig","page":"Finding Attractors","title":"Attractors.GroupingConfig","text":"GroupingConfig\n\nSupertype for configuration structs on how to group features together. Used in several occasions such as AttractorsViaFeaturizing or aggregate_attractor_fractions.\n\nCurrently available grouping configurations are:\n\nGroupViaClustering\nGroupViaNearestFeature\nGroupViaHistogram\n\nGroupingConfig defines an extendable interface. The only thing necessary for a new grouping configuration is to:\n\nMake a new type and subtype GroupingConfig.\nIf the grouping allows for mapping individual initial conditions to IDs, then instead extend the internal function feature_to_group(feature, config). This will allow doing id = mapper(u0) with AttractorsViaFeaturizing.\nElse, extend the function group_features(features, config). You could still extend group_features even if (2.) is satisfied, if there are any performance benefits.\nInclude the new grouping file in the grouping/all_grouping_configs.jl and list it in this documentation string.\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Attractors.GroupViaClustering","page":"Finding Attractors","title":"Attractors.GroupViaClustering","text":"GroupViaClustering(; kwargs...)\n\nInitialize a struct that contains instructions on how to group features in AttractorsViaFeaturizing. GroupViaClustering clusters features into groups using DBSCAN, similar to the original work by bSTAB (Stender and Hoffmann, 2021) and MCBB Gelbrecht2021. Several options on clustering are available, see keywords below.\n\nThe defaults are a significant improvement over existing literature, see Description.\n\nKeyword arguments\n\nclust_distance_metric = Euclidean(): A metric to be used in the clustering. It can be any function f(a, b) that returns the distance between real-valued vectors a, b. All metrics from Distances.jl can be used here.\nrescale_features = true: if true, rescale each dimension of the extracted features separately into the range [0,1]. This typically leads to more accurate clustering.\nmin_neighbors = 10: minimum number of neighbors (i.e. of similar features) each feature needs to have, including counting its own self, in order to be considered in a cluster (fewer than this, it is labeled as an outlier, -1).\nuse_mmap = false: whether to use an on-disk map for creating the distance matrix of the features. Useful when the features are so many where a matrix with side their length would not fit to memory.\n\nKeywords for optimal radius estimation\n\noptimal_radius_method::Union{Real, String} = \"silhouettes_optim\": if a real number, it is the radius used to cluster features. Otherwise, it determines the method used to automatically determine that radius. Possible values are:\n\"silhouettes\": Performs a linear (sequential) search for the radius that maximizes a   statistic of the silhouette values of clusters (typically the mean). This can be chosen   with silhouette_statistic. The linear search may take some time to finish. To   increase speed, the number of radii iterated through can be reduced by decreasing   num_attempts_radius (see its entry below).\n\"silhouettes_optim\": Same as \"silhouettes\" but performs an optimized search via   Optim.jl. It's faster than \"silhouettes\", with typically the same accuracy (the   search here is not guaranteed to always find the global maximum, though it typically   gets close).\n\"knee\": chooses the the radius according to the knee (a.k.a. elbow,   highest-derivative method) and is quicker, though generally leading to much worse   clustering. It requires that min_neighbors > 1.\nnum_attempts_radius = 100: number of radii that the optimal_radius_method will try out in its iterative procedure. Higher values increase the accuracy of clustering, though not necessarily much, while always reducing speed.\nsilhouette_statistic::Function = mean: statistic (e.g. mean or minimum) of the silhouettes that is maximized in the \"optimal\" clustering. The original implementation in (Stender and Hoffmann, 2021) used the minimum of the silhouettes, and typically performs less accurately than the mean.\nmax_used_features = 0: if not 0, it should be an Int denoting the max amount of features to be used when finding the optimal radius. Useful when clustering a very large number of features (e.g., high accuracy estimation of fractions of basins of attraction).\n\nDescription\n\nThe DBSCAN clustering algorithm is used to automatically identify clusters of similar features. Each feature vector is a point in a feature space. Each cluster then basically groups points that are closely packed together. Closely packed means that the points have at least min_neighbors inside a ball of radius optimal_radius centered on them. This method typically works well if the radius is chosen well, which is not necessarily an easy task. Currently, three methods are implemented to automatically estimate an \"optimal\" radius.\n\nEstimating the optimal radius\n\nThe default method is the silhouettes method, which includes keywords silhouette and silhouette_optim. Both of them search for the radius that optimizes the clustering, meaning the one that maximizes a statistic silhouette_statistic (e.g. mean value) of a quantifier for the quality of each cluster. This quantifier is the silhouette value of each identified cluster. A silhouette value measures how similar a point is to the cluster it currently belongs to, compared to the other clusters, and ranges from -1 (worst matching) to +1 (ideal matching). If only one cluster is found, the assigned silhouette is zero. So for each attempted radius in the search the clusters are computed, their silhouettes calculated, and the statistic of these silhouettes computed. The algorithm then finds the radius that leads to the maximum such statistic. For optimal_radius_method = \"silhouettes\", the search is done linearly, from a minimum to a maximum candidate radius for optimal_radius_method = \"silhouettes\"; optimal_radius_method = silhouettes_optim, it is done via an optimized search performed by Optim.jl which is typically faster and with similar accuracy. A third alternative is the\"elbow\" method, which works by calculating the distance of each point to its k-nearest-neighbors (with k=min_neighbors) and finding the distance corresponding to the highest derivative in the curve of the distances, sorted in ascending order. This distance is chosen as the optimal radius. It is described in (Ester et al., 1996) and (Schubert et al., 2017). It typically performs considerably worse than the \"silhouette\" methods.\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Attractors.GroupViaHistogram","page":"Finding Attractors","title":"Attractors.GroupViaHistogram","text":"GroupViaHistogram(binning::FixedRectangularBinning)\n\nInitialize a struct that contains instructions on how to group features in AttractorsViaFeaturizing. GroupViaHistogram performs a histogram in feature space. Then, all features that are in the same histogram bin get the same label. The binning is an instance of FixedRectangularBinning from ComplexityMeasures.jl. (the reason to not allow RectangularBinning is because during continuation we need to ensure that bins remain identical).\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Attractors.GroupViaNearestFeature","page":"Finding Attractors","title":"Attractors.GroupViaNearestFeature","text":"GroupViaNearestFeature(templates; kwargs...)\n\nInitialize a struct that contains instructions on how to group features in AttractorsViaFeaturizing. GroupViaNearestFeature accepts a template, which is a vector of features. Then, generated features from initial conditions in AttractorsViaFeaturizing are labelled according to the feature in templates that is closest (the label is the index of the closest template).\n\ntemplates can be a vector or dictionary mapping keys to templates. Internally all templates are converted to SVector for performance. Hence, it is strongly recommended that both templates and the output of the featurizer function in AttractorsViaFeaturizing return SVector types.\n\nKeyword arguments\n\nmetric = Euclidean(): metric to be used to quantify distances in the feature space.\nmax_distance = Inf: Maximum allowed distance between a feature and its nearest template for it to be assigned to that template. By default, Inf guarantees that a feature is assigned to its nearest template regardless of the distance. Features that exceed max_distance to their nearest template get labelled -1.\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Grouping-utility-functions","page":"Finding Attractors","title":"Grouping utility functions","text":"","category":"section"},{"location":"attractors/","page":"Finding Attractors","title":"Finding Attractors","text":"group_features\nextract_features","category":"page"},{"location":"attractors/#Attractors.group_features","page":"Finding Attractors","title":"Attractors.group_features","text":"group_features(features, group_config::GroupingConfig) → labels\n\nGroup the given vector of feature vectors according to the configuration and return the labels (vector of equal length as features). See AttractorsViaFeaturizing for possible configurations.\n\n\n\n\n\n","category":"function"},{"location":"attractors/#Attractors.extract_features","page":"Finding Attractors","title":"Attractors.extract_features","text":"extract_features(mapper, ics; N = 1000, show_progress = true)\n\nReturn a vector of the features of each initial condition in ics (as in basins_fractions), using the configuration of mapper::AttractorsViaFeaturizing. Keyword N is ignored if ics isa StateSpaceSet.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Visualization-utilities","page":"Visualization utilities","title":"Visualization utilities","text":"","category":"section"},{"location":"visualization/","page":"Visualization utilities","title":"Visualization utilities","text":"In this page we document several plotting utility functions that have been created to make the visualization of the output of Attractors.jl seamless. See the examples page for usage of all these plotting functions.","category":"page"},{"location":"visualization/","page":"Visualization utilities","title":"Visualization utilities","text":"Note that most functions have an out-of-place and an in-place form, the in-place form always taking as a first input a pre-initialized Axis to plot in while the out-of-place creates and returns a new figure object.","category":"page"},{"location":"visualization/","page":"Visualization utilities","title":"Visualization utilities","text":"E.g.,","category":"page"},{"location":"visualization/","page":"Visualization utilities","title":"Visualization utilities","text":"heatmap_basins_attractors(grid, basins, attractors; kwargs...)\nheatmap_basins_attractors!(ax, grid, basins, attractors; kwargs...)","category":"page"},{"location":"visualization/#Common-plotting-keywords","page":"Visualization utilities","title":"Common plotting keywords","text":"","category":"section"},{"location":"visualization/","page":"Visualization utilities","title":"Visualization utilities","text":"Common keywords for plotting functions in Attractors.jl are:","category":"page"},{"location":"visualization/","page":"Visualization utilities","title":"Visualization utilities","text":"ukeys: the basin ids (unique keys, vector of integers) to use. By default all existing keys are used.\naccess = [1, 2]: indices of which dimensions of an attractor to select and visualize in a two-dimensional plot. Only these ids will be visualized. By default all are used.\ncolors: a dictionary mapping basin ids (i.e., including the -1 key) to a color. By default the JuliaDynamics colorscheme is used if less than 7 ids are present, otherwise random colors from the :darktest colormap.\nmarkers: dictionary mapping attractor ids to markers they should be plotted as\nlabels = Dict(ukeys .=> ukeys): how to label each attractor.\nadd_legend = length(ukeys) < 7: whether to add a legend mapping colors to labels.","category":"page"},{"location":"visualization/#Basins-related","page":"Visualization utilities","title":"Basins related","text":"","category":"section"},{"location":"visualization/","page":"Visualization utilities","title":"Visualization utilities","text":"heatmap_basins_attractors","category":"page"},{"location":"visualization/#Attractors.heatmap_basins_attractors","page":"Visualization utilities","title":"Attractors.heatmap_basins_attractors","text":"heatmap_basins_attractors(grid, basins, attractors; kwargs...)\n\nPlot a heatmap of found (2-dimensional) basins of attraction and corresponding attractors, i.e., the output of basins_of_attraction.\n\nKeyword arguments\n\nAll the common plotting keywords.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Continuation-related","page":"Visualization utilities","title":"Continuation related","text":"","category":"section"},{"location":"visualization/","page":"Visualization utilities","title":"Visualization utilities","text":"plot_basins_curves\nplot_attractors_curves\nplot_basins_attractors_curves","category":"page"},{"location":"visualization/#Attractors.plot_basins_curves","page":"Visualization utilities","title":"Attractors.plot_basins_curves","text":"plot_basins_curves(fractions_curves, prange = 1:length(); kwargs...)\n\nPlot the fractions of basins of attraction versus a parameter range, i.e., visualize the output of continuation.\n\nKeyword arguments\n\nstyle = :band: how to visualize the basin fractions. Choices are :band for a band plot with cumulative sum = 1 or :lines for a lines plot of each basin fraction\nseparatorwidth = 1, separatorcolor = \"white\": adds a line separating the fractions if the style is :band\naxislegend_kwargs = (position = :lt,): propagated to axislegend if a legend is added\nseries_kwargs = NamedTuple(): propagated to the band or scatterline plot\nAlso all common plotting keywords.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Attractors.plot_attractors_curves","page":"Visualization utilities","title":"Attractors.plot_attractors_curves","text":"plot_attractors_curves(attractors_info, attractor_to_real, prange = 1:length(); kwargs...)\n\nSame as in plot_basins_curves but visualizes the attractor dependence on the parameter instead of their fraction. The function attractor_to_real takes as input a StateSpaceSet (attractor) and returns a real number so that it can be plotted versus the parameter axis.\n\nSame keywords as plot_basins_curves.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Attractors.plot_basins_attractors_curves","page":"Visualization utilities","title":"Attractors.plot_basins_attractors_curves","text":"plot_basins_attractors_curves(\n    fractions_curves, attractors_info, attractor_to_real [, prange]\n    kwargs...\n)\n\nConvinience combination of plot_basins_curves and plot_attractors_curves in a two-panel plot that shares legend, colors, markers, etc.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Video-output","page":"Visualization utilities","title":"Video output","text":"","category":"section"},{"location":"visualization/","page":"Visualization utilities","title":"Visualization utilities","text":"animate_attractors_continuation","category":"page"},{"location":"visualization/#Attractors.animate_attractors_continuation","page":"Visualization utilities","title":"Attractors.animate_attractors_continuation","text":"animate_attractors_continuation(\n    ds::DynamicalSystem, attractors_info, fractions_curves, prange, pidx;\n    kwargs...\n)\n\nAnimate how the found system attractors and their corresponding basin fractions change as the system parameter is increased. This function combines the input and output of the continuation function into a video output.\n\nThe input dynamical system ds is used to evolve initial conditions sampled from the found attractors, so that the attractors are better visualized. attractors_info, fractions_curves are the output of continuation while ds, prange, pidx are the input to continuation.\n\nKeyword arguments\n\nsavename = \"test.mp4\": name of video output file\nframerate = 4: framerate of video output\nmarkersize = 10\nΔt, T: propagated to trajectory for evolving an initial condition sampled from an attractor\nAlso all common plotting keywords.\n\n\n\n\n\n","category":"function"},{"location":"#Attractors.jl","page":"Attractors.jl","title":"Attractors.jl","text":"","category":"section"},{"location":"","page":"Attractors.jl","title":"Attractors.jl","text":"Attractors","category":"page"},{"location":"#Attractors","page":"Attractors.jl","title":"Attractors","text":"Attractors.jl\n\n(Image: ) (Image: ) (Image: Paper) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia module for\n\nfinding attractors of arbitrary dynamical systems\nfinding their basins of attraction or the state space fractions of the basins\nanalyzing global stability of attractors (also called non-local stability or  resilience)\n\"continuing\" the attractors and their basins over a parameter range\nfinding the basin boundaries and analyzing their fractal properties\ntipping points related functionality for systems with known dynamic rule\nand more!\n\nIt can be used as a standalone package, or as part of DynamicalSystems.jl.\n\nTo install it, run import Pkg; Pkg.add(\"Attractors\").\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\nPreviously, Attractors.jl was part of ChaosTools.jl\n\n\n\n\n\n","category":"module"},{"location":"","page":"Attractors.jl","title":"Attractors.jl","text":"using CairoMakie, Attractors","category":"page"},{"location":"#Latest-news","page":"Attractors.jl","title":"Latest news","text":"","category":"section"},{"location":"","page":"Attractors.jl","title":"Attractors.jl","text":"Our paper on the global stability analysis framework offered by Attractors.jl (continuation) and the novel continuation offered by RecurrencesFindAndMatch is published as a Featured Article in Chaos (https://pubs.aip.org/aip/cha/article/33/7/073151/2904709/Framework-for-global-stability-analysis-of) and has been featured in the AIP publishing showcase (https://www.growkudos.com/publications/10.1063%25252F5.0159675/reader)\nNew function minimal_fatal_shock\nNew function match_continuation! which improves the matching during a continuation process where attractors dissapear and re-appear.","category":"page"},{"location":"#Outline-of-Attractors.jl","page":"Attractors.jl","title":"Outline of Attractors.jl","text":"","category":"section"},{"location":"","page":"Attractors.jl","title":"Attractors.jl","text":"(Image: Attractors.jl flowchart)","category":"page"},{"location":"","page":"Attractors.jl","title":"Attractors.jl","text":"First be sure that you are aware of what is a DynamicalSystem. This is the input to the whole infrastructure of Attractors.jl.\nThe bulk of the work in Attractors.jl is done by the AttractorMapper type, that instructs how to find attractors and maps initial conditions to them. It can be used in functions like basins_fractions.\nFor grouping features, there is a sub-infrastructure for instructing how to group features, which is governed by GroupingConfig.\nThe infrastructure of finding attractors and their basins fractions is then integrated into a brand new way of doing bifurcation analysis in the continuation function.\nSee Examples for Attractors.jl for several applications in real world cases.","category":"page"}]
}
