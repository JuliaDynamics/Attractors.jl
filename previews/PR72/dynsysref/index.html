<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DynamicalSystem reference · Attractors.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Attractors.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Attractors.jl</a></li><li class="is-active"><a class="tocitem" href><code>DynamicalSystem</code> reference</a><ul class="internal"><li><a class="tocitem" href="#Dynamical-systems"><span>Dynamical systems</span></a></li><li><a class="tocitem" href="#Relevant-dynamical-systems-API"><span>Relevant dynamical systems API</span></a></li><li><a class="tocitem" href="#StateSpaceSet-reference"><span><code>StateSpaceSet</code> reference</span></a></li></ul></li><li><a class="tocitem" href="../attractors/">Finding Attractors</a></li><li><a class="tocitem" href="../basins/">Basins of Attraction</a></li><li><a class="tocitem" href="../continuation/">Attractor &amp; Basins Continuation</a></li><li><a class="tocitem" href="../visualization/">Visualization utilities</a></li><li><a class="tocitem" href="../examples/">Examples for Attractors.jl</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href><code>DynamicalSystem</code> reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href><code>DynamicalSystem</code> reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/Attractors.jl/blob/main/docs/src/dynsysref.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="DynamicalSystem-reference"><a class="docs-heading-anchor" href="#DynamicalSystem-reference"><code>DynamicalSystem</code> reference</a><a id="DynamicalSystem-reference-1"></a><a class="docs-heading-anchor-permalink" href="#DynamicalSystem-reference" title="Permalink"></a></h1><p>This page is a convenience reference to some of the contents of the DynamicalSystemsBase.jl package (one of the core modules of DynamicalSystems.jl).</p><h2 id="Dynamical-systems"><a class="docs-heading-anchor" href="#Dynamical-systems">Dynamical systems</a><a id="Dynamical-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Dynamical-systems" title="Permalink"></a></h2><p>The kinds of dynamical systems that can be used in Attractors.jl are listed below for reference</p><ul><li><a href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a></li><li><a href="#DynamicalSystemsBase.DeterministicIteratedMap"><code>DeterministicIteratedMap</code></a></li><li><a href="#DynamicalSystemsBase.CoupledODEs"><code>CoupledODEs</code></a></li><li><a href="#DynamicalSystemsBase.StroboscopicMap"><code>StroboscopicMap</code></a></li><li><a href="#DynamicalSystemsBase.PoincareMap"><code>PoincareMap</code></a></li><li><a href="#DynamicalSystemsBase.ProjectedDynamicalSystem"><code>ProjectedDynamicalSystem</code></a></li><li><a href="#DynamicalSystemsBase.ArbitrarySteppable"><code>ArbitrarySteppable</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.DynamicalSystem" href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystemsBase.DynamicalSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DynamicalSystem</code></pre><p><code>DynamicalSystem</code> is an abstract supertype encompassing all concrete implementations of what counts as a &quot;dynamical system&quot; in the DynamicalSystems.jl library.</p><p><strong><em>All concrete implementations of <code>DynamicalSystem</code> can be iteratively evolved in time via the <a href="#SciMLBase.step!-Tuple{DynamicalSystem, Vararg{Any}}"><code>step!</code></a> function.</em></strong> Hence, most library functions that evolve the system will mutate its current state and/or parameters. See the documentation online for implications this has on for parallelization.</p><p><code>DynamicalSystem</code> is further separated into two abstract types: <code>ContinuousTimeDynamicalSystem, DiscreteTimeDynamicalSystem</code>. The simplest and most common concrete implementations of a <code>DynamicalSystem</code> are <a href="#DynamicalSystemsBase.DeterministicIteratedMap"><code>DeterministicIteratedMap</code></a> or <a href="#DynamicalSystemsBase.CoupledODEs"><code>CoupledODEs</code></a>.</p><p><strong>Description</strong></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The documentation of <code>DynamicalSystem</code> follows chapter 1 of <a href="https://link.springer.com/book/10.1007/978-3-030-91032-7">Nonlinear Dynamics</a>, Datseris &amp; Parlitz, Springer 2022.</p></div></div><p>A <code>ds::DynamicalSystem</code> <strong><em>representes a flow Φ in a state space</em></strong>. It mainly encapsulates three things:</p><ol><li>A state, typically referred to as <code>u</code>, with initial value <code>u0</code>. The space that <code>u</code> occupies is the state space of <code>ds</code> and the length of <code>u</code> is the dimension of <code>ds</code> (and of the state space).</li><li>A dynamic rule, typically referred to as <code>f</code>, that dictates how the state evolves/changes with time when calling the <a href="#SciMLBase.step!-Tuple{DynamicalSystem, Vararg{Any}}"><code>step!</code></a> function. <code>f</code> is a standard Julia function, see below.</li><li>A parameter container <code>p</code> that parameterizes <code>f</code>. <code>p</code> can be anything, but in general it is recommended to be a type-stable mutable container.</li></ol><p>In sort, any set of quantities that change in time can be considered a dynamical system, however the concrete subtypes of <code>DynamicalSystem</code> are much more specific in their scope. Concrete subtypes typically also contain more information than the above 3 items.</p><p>In this scope dynamical systems have a known dynamic rule <code>f</code> defined as a standard Julia function. <em>Observed</em> or <em>measured</em> data from a dynamical system are represented using <code>StateSpaceSet</code> and are finite. Such data are obtained from the <a href="@ref"><code>trajectory</code></a> function or from an experimental measurement of a dynamical system with an unknown dynamic rule.</p><p><strong>Construction instructions on <code>f</code> and <code>u</code></strong></p><p>Most of the concrete implementations of <code>DynamicalSystem</code>, with the exception of <a href="#DynamicalSystemsBase.ArbitrarySteppable"><code>ArbitrarySteppable</code></a>, have two ways of implementing the dynamic rule <code>f</code>, and as a consequence the type of the state <code>u</code>. The distinction is done on whether <code>f</code> is defined as an in-place (iip) function or out-of-place (oop) function.</p><ul><li><strong>oop</strong> : <code>f</code> <strong>must</strong> be in the form <code>f(u, p, t) -&gt; out</code>   which means that given a state <code>u::SVector{&lt;:Real}</code> and some parameter container   <code>p</code> it returns the output of <code>f</code> as an <code>SVector{&lt;:Real}</code> (static vector).</li><li><strong>iip</strong> : <code>f</code> <strong>must</strong> be in the form <code>f!(out, u, p, t)</code>   which means that given a state <code>u::AbstractArray{&lt;:Real}</code> and some parameter container <code>p</code>,   it writes in-place the output of <code>f</code> in <code>out::AbstractArray{&lt;:Real}</code>.   The function <strong>must</strong> return <code>nothing</code> as a final statement.</li></ul><p><code>t</code> stands for current time in both cases. <strong>iip</strong> is suggested for systems with high dimension and <strong>oop</strong> for small. The break-even point is between 10 to 100 dimensions but should be benchmarked on a case-by-case basis as it depends on the complexity of <code>f</code>.</p><div class="admonition is-info"><header class="admonition-header">Autonomous vs non-autonomous systems</header><div class="admonition-body"><p>Whether the dynamical system is autonomous (<code>f</code> doesn&#39;t depend on time) or not, it is still necessary to include <code>t</code> as an argument to <code>f</code>. Some algorithms utilize this information, some do not, but we prefer to keep a consistent interface either way. You can also convert any system to autonomous by making time an additional variable. If the system is non-autonomous, its <em>effective dimensionality</em> is <code>dimension(ds)+1</code>.</p></div></div><p><strong>API</strong></p><p>The API that the interface of <code>DynamicalSystem</code> employs is the functions listed below. Once a concrete instance of a subtype of <code>DynamicalSystem</code> is obtained, it can quieried or altered with the following functions.</p><p>The main use of a concrete dynamical system instance is to provide it to downstream functions such as <code>lyapunovspectrum</code> from ChaosTools.jl or <code>basins_of_attraction</code> from Attractors.jl. A typical user will likely not utilize directly the following API, unless when developing new algorithm implementations that use dynamical systems.</p><p><strong>API - information</strong></p><ul><li><code>ds(t)</code> with <code>ds</code> an instance of <code>DynamicalSystem</code>: return the state of <code>ds</code> at time <code>t</code>. For continuous time systems this interpolates and extrapolates, while for discrete time systems it only works if <code>t</code> is the current time.</li><li><a href="@ref"><code>current_state</code></a></li><li><a href="@ref"><code>initial_state</code></a></li><li><a href="@ref"><code>current_parameters</code></a></li><li><a href="@ref"><code>initial_parameters</code></a></li><li><a href="@ref"><code>isdeterministic</code></a></li><li><a href="@ref"><code>isdiscretetime</code></a></li><li><a href="@ref"><code>dynamic_rule</code></a></li><li><a href="@ref"><code>current_time</code></a></li><li><a href="@ref"><code>initial_time</code></a></li><li><a href="@ref"><code>isinplace</code></a></li><li><a href="@ref"><code>succesful_step</code></a></li></ul><p><strong>API - alter status</strong></p><ul><li><a href="#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}"><code>reinit!</code></a></li><li><a href="@ref"><code>set_state!</code></a></li><li><a href="#DynamicalSystemsBase.set_parameter!"><code>set_parameter!</code></a></li><li><a href="@ref"><code>set_parameters!</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.DeterministicIteratedMap" href="#DynamicalSystemsBase.DeterministicIteratedMap"><code>DynamicalSystemsBase.DeterministicIteratedMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DeterministicIteratedMap &lt;: DynamicalSystem
DeterministicIteratedMap(f, u0, p = nothing; t0 = 0)</code></pre><p>A deterministic discrete time dynamical system defined by an iterated map as follows:</p><p class="math-container">\[\vec{u}_{n+1} = \vec{f}(\vec{u}_n, p, n)\]</p><p>An alias for <code>DeterministicIteratedMap</code> is <code>DiscreteDynamicalSystem</code>.</p><p>Optionally configure the parameter container <code>p</code> and initial time <code>t0</code>.</p><p>For construction instructions regarding <code>f, u0</code> see <a href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.CoupledODEs" href="#DynamicalSystemsBase.CoupledODEs"><code>DynamicalSystemsBase.CoupledODEs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CoupledODEs &lt;: ContinuousTimeDynamicalSystem
CoupledODEs(f, u0 [, p]; diffeq, t0 = 0.0)</code></pre><p>A deterministic continuous time dynamical system defined by a set of coupled ordinary differential equations as follows:</p><p class="math-container">\[\frac{d\vec{u}}{dt} = \vec{f}(\vec{u}, p, t)\]</p><p>An alias for <code>CoupledODE</code> is <code>ContinuousDynamicalSystem</code>.</p><p>Optionally provide the parameter container <code>p</code> and initial time as keyword <code>t0</code>.</p><p>For construction instructions regarding <code>f, u0</code> see <a href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a>.</p><p><strong>DifferentialEquations.jl keyword arguments and interfacing</strong></p><p>The ODEs are evolved via the solvers of DifferentialEquations.jl. When initializing a <code>CoupledODEs</code>, you can specify the solver that will integrate <code>f</code> in time, along with any other integration options, using the <code>diffeq</code> keyword. For example you could use <code>diffeq = (abstol = 1e-9, reltol = 1e-9)</code>. If you want to specify a solver, do so by using the keyword <code>alg</code>, e.g.: <code>diffeq = (alg = Tsit5(), reltol = 1e-6)</code>. This requires you to have been first <code>using OrdinaryDiffEq</code> to access the solvers. The default <code>diffeq</code> is:</p><p>(alg = Tsit5(stage<em>limiter! = trivial</em>limiter!, step<em>limiter! = trivial</em>limiter!, thread = static(false)), abstol = 1.0e-6, reltol = 1.0e-6)</p><p><code>diffeq</code> keywords can also include <code>callback</code> for <a href="http://docs.juliadiffeq.org/latest/features/callback_functions.html">event handling </a>, however the majority of downstream functions in DynamicalSystems.jl assume that <code>f</code> is differentiable.</p><p>The convenience constructor <code>CoupledODEs(prob::ODEProblem, diffeq)</code> and <code>CoupledODEs(ds::CoupledODEs, diffeq)</code> are also available.</p><p>Dev note: <code>CoupledODEs</code> is a light wrapper of <code>ODEIntegrator</code> from DifferentialEquations.jl. The integrator is available as the field <code>integ</code>, and the <code>ODEProblem</code> is <code>integ.sol.prob</code>. The convenience syntax <code>ODEProblem(ds::CoupledODEs, tspan = (t0, Inf))</code> is available.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.StroboscopicMap" href="#DynamicalSystemsBase.StroboscopicMap"><code>DynamicalSystemsBase.StroboscopicMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StroboscopicMap &lt;: DiscreteTimeDynamicalSystem
StroboscopicMap(ds::CoupledODEs, period::Real) → smap
StroboscopicMap(period::Real, f, u0, p = nothing; kwargs...)</code></pre><p>A discrete time dynamical system that produces iterations of a time-dependent (non-autonomous) <a href="#DynamicalSystemsBase.CoupledODEs"><code>CoupledODEs</code></a> system exactly over a given <code>period</code>. The second signature first creates a <a href="#DynamicalSystemsBase.CoupledODEs"><code>CoupledODEs</code></a> and then calls the first.</p><p><code>StroboscopicMap</code> follows the <a href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a> interface. In addition, the function <code>set_period!(smap, period)</code> is provided, that sets the period of the system to a new value (as if it was a parameter). As this system is in discrete time, <a href="@Ref"><code>current_time</code></a> and <a href="@ref"><code>initial_time</code></a> are integers. The initial time is always 0, because <code>current_time</code> counts elapsed periods. Call these functions on the <code>parent</code> of <code>StroboscopicMap</code> to obtain the corresponding continuous time. In contrast, <a href="#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}"><code>reinit!</code></a> expects <code>t0</code> in continuous time.</p><p>The convenience constructor</p><pre><code class="language-julia hljs">StroboscopicMap(T::Real, f, u0, p = nothing; diffeq, t0 = 0) → smap</code></pre><p>is also provided.</p><p>See also <a href="#DynamicalSystemsBase.PoincareMap"><code>PoincareMap</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.PoincareMap" href="#DynamicalSystemsBase.PoincareMap"><code>DynamicalSystemsBase.PoincareMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PoincareMap &lt;: DiscreteTimeDynamicalSystem
PoincareMap(ds::CoupledODEs, plane; kwargs...) → pmap</code></pre><p>A discrete time dynamical system that produces iterations over the Poincaré map<sup class="footnote-reference"><a id="citeref-DatserisParlitz2022" href="#footnote-DatserisParlitz2022">[DatserisParlitz2022]</a></sup> of the given continuous time <code>ds</code>. This map is defined as the sequence of points on the Poincaré surface of section, which is defined by the <code>plane</code> argument.</p><p>See also <a href="#DynamicalSystemsBase.StroboscopicMap"><code>StroboscopicMap</code></a>, <a href="@ref"><code>poincaresos</code></a>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>direction = -1</code>: Only crossings with <code>sign(direction)</code> are considered to belong to the surface of section. Positive direction means going from less than <span>$b$</span> to greater than <span>$b$</span>.</li><li><code>u0 = nothing</code>: Specify an initial state.</li><li><code>rootkw = (xrtol = 1e-6, atol = 1e-8)</code>: A <code>NamedTuple</code> of keyword arguments passed to <code>find_zero</code> from <a href="https://github.com/JuliaMath/Roots.jl">Roots.jl</a>.</li><li><code>Tmax = 1e3</code>: The argument <code>Tmax</code> exists so that the integrator can terminate instead of being evolved for infinite time, to avoid cases where iteration would continue forever for ill-defined hyperplanes or for convergence to fixed points, where the trajectory would never cross again the hyperplane. If during one <code>step!</code> the system has been evolved for more than <code>Tmax</code>, then <code>step!(pmap)</code> will terminate and error.</li></ul><p><strong>Description</strong></p><p>The Poincaré surface of section is defined as sequential transversal crossings a trajectory has with any arbitrary manifold, but here the manifold must be a hyperplane. <code>PoincareMap</code> iterates over the crossings of the section.</p><p>If the state of <code>ds</code> is <span>$\mathbf{u} = (u_1, \ldots, u_D)$</span> then the equation defining a hyperplane is</p><p class="math-container">\[a_1u_1 + \dots + a_Du_D = \mathbf{a}\cdot\mathbf{u}=b\]</p><p>where <span>$\mathbf{a}, b$</span> are the parameters of the hyperplane.</p><p>In code, <code>plane</code> can be either:</p><ul><li>A <code>Tuple{Int, &lt;: Real}</code>, like <code>(j, r)</code>: the plane is defined as when the <code>j</code>th variable of the system equals the value <code>r</code>.</li><li>A vector of length <code>D+1</code>. The first <code>D</code> elements of the vector correspond to <span>$\mathbf{a}$</span> while the last element is <span>$b$</span>.</li></ul><p><code>PoincareMap</code> uses <code>ds</code>, higher order interpolation from DifferentialEquations.jl, and root finding from Roots.jl, to create a high accuracy estimate of the section.</p><p><code>PoincareMap</code> follows the <a href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a> interface with the following adjustments:</p><ol><li><code>dimension(pmap) == dimension(ds)</code>, even though the Poincaré map is effectively 1 dimension less.</li><li>Like <a href="#DynamicalSystemsBase.StroboscopicMap"><code>StroboscopicMap</code></a> time is discrete and counts the iterations on the surface of section. <a href="@ref"><code>initial_time</code></a> is always <code>0</code> and <a href="@ref"><code>current_time</code></a> is current iteration number.</li><li>A new function <a href="@ref"><code>current_crossing_time</code></a> returns the real time corresponding to the latest crossing of the hyperplane, which is what the <a href="@ref"><code>current_state(ds)</code></a> corresponds to as well.</li><li>For the special case of <code>plane</code> being a <code>Tuple{Int, &lt;:Real}</code>, a special <code>reinit!</code> method is allowed with input state of length <code>D-1</code> instead of <code>D</code>, i.e., a reduced state already on the hyperplane that is then converted into the <code>D</code> dimensional state.</li></ol><p><strong>Example</strong></p><pre><code class="language-julia hljs">using DynamicalSystemsBase
ds = Systems.rikitake(zeros(3); μ = 0.47, α = 1.0)
pmap = poincaremap(ds, (3, 0.0))
step!(pmap)
next_state_on_psos = current_state(pmap)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.ProjectedDynamicalSystem" href="#DynamicalSystemsBase.ProjectedDynamicalSystem"><code>DynamicalSystemsBase.ProjectedDynamicalSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProjectedDynamicalSystem &lt;: DynamicalSystem
ProjectedDynamicalSystem(ds::DynamicalSystem, projection, complete_state)</code></pre><p>A dynamical system that represents a projection of an existing <code>ds</code> on a (projected) space.</p><p>The <code>projection</code> defines the projected space. If <code>projection isa AbstractVector{Int}</code>, then the projected space is simply the variable indices that <code>projection</code> contains. Otherwise, <code>projection</code> can be an arbitrary function that given the state of the original system <code>ds</code>, returns the state in the projected space. In this case the projected space can be equal, or even higher-dimensional, than the original.</p><p><code>complete_state</code> produces the state for the original system from the projected state. <code>complete_state</code> can always be a function that given the projected state returns a state in the original space. However, if <code>projection isa AbstractVector{Int}</code>, then <code>complete_state</code> can also be a vector that contains the values of the <em>remaining</em> variables of the system, i.e., those <em>not</em> contained in the projected space. In this case the projected space needs to be lower-dimensional than the original.</p><p>Notice that <code>ProjectedDynamicalSystem</code> does not require an invertible projection, <code>complete_state</code> is only used during <a href="#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}"><code>reinit!</code></a>. <code>ProjectedDynamicalSystem</code> is in fact a rather trivial wrapper of <code>ds</code> which steps it as normal in the original state space and only projects as a last step, e.g., during <a href="@ref"><code>current_state</code></a>.</p><p><strong>Examples</strong></p><p>Case 1: project 5-dimensional system to its last two dimensions.</p><pre><code class="language-julia hljs">ds = Systems.lorenz96(5)
projection = [4, 5]
complete_state = [0.0, 0.0, 0.0] # completed state just in the plane of last two dimensions
pds = projected_integrator(ds, projection, complete_state)
reinit!(pds, [0.2, 0.4])
step!(pds)
get_state(pds)</code></pre><p>Case 2: custom projection to general functions of state. <code>julia ds = Systems.lorenz96(5) projection(u) = [sum(u), sqrt(u[1]^2 + u[2]^2)] complete_state(y) = repeat(y[1]/5, 5) pds = # same as in above example...</code>`</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.ArbitrarySteppable" href="#DynamicalSystemsBase.ArbitrarySteppable"><code>DynamicalSystemsBase.ArbitrarySteppable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ArbitrarySteppable &lt;: DiscreteTimeDynamicalSystem
ArbitrarySteppable(
    model, step!, extract_state, extract_parameters, reset_model!;
    isdeterministic = true, set_state = reinit!,
)</code></pre><p>A dynamical system generated by an arbitrary &quot;model&quot; that can be stepped <em>in-place</em> with some function <code>step!(model)</code> for 1 step. The state of the model is extracted by the <code>extract_state(model) -&gt; u</code> function The parameters of the model are extracted by the <code>extract_parameters(model) -&gt; p</code> function. The system may be re-initialized, via <a href="#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}"><code>reinit!</code></a>, with the <code>reset_model!</code> user-provided function that must have the call signature</p><pre><code class="language-julia hljs">reset_model!(model, u, p)</code></pre><p>given a (potentially new) state <code>u</code> and parameter container <code>p</code>, both of which will default to the initial ones in the <a href="#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}"><code>reinit!</code></a> call.</p><p><code>ArbitrarySteppable</code> exists to provide the DynamicalSystems.jl interface to models from other packages that could be used within the DynamicalSystems.jl library. <code>ArbitrarySteppable</code> follows the <a href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a> interface with the following adjustments:</p><ul><li><a href="@ref"><code>initial_time</code></a> is always 0, as time counts the steps the model has taken since creation or last <a href="#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}"><code>reinit!</code></a> call.</li><li><a href="@ref"><code>set_state!</code></a> is the same as <a href="#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}"><code>reinit!</code></a> by default. If not, the keyword argument <code>set_state</code> is a function <code>set_state(model, u)</code> that sets the state of the model to <code>u</code>.</li><li>The keyword <code>isdeterministic</code> should be set properly, as it decides whether downstream algorithms should error or not.</li></ul></div></section></article><h2 id="Relevant-dynamical-systems-API"><a class="docs-heading-anchor" href="#Relevant-dynamical-systems-API">Relevant dynamical systems API</a><a id="Relevant-dynamical-systems-API-1"></a><a class="docs-heading-anchor-permalink" href="#Relevant-dynamical-systems-API" title="Permalink"></a></h2><p>Here we state only the relevant API functions; others can be found in the DynamicalSystemsBase.jl documentation.</p><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.step!-Tuple{DynamicalSystem, Vararg{Any}}" href="#SciMLBase.step!-Tuple{DynamicalSystem, Vararg{Any}}"><code>SciMLBase.step!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">step!(ds::DiscreteTimeDynamicalSystem [, n::Integer]) → ds</code></pre><p>Evolve the discrete time dynamical system for 1 or <code>n</code> steps.</p><pre><code class="nohighlight hljs">step!(ds::ContinuousTimeDynamicalSystem, [, dt::Real [, stop_at_tdt]]) → ds</code></pre><p>Evolve the continuous time dynamical system for one integration step.</p><p>Alternatively, if a <code>dt</code> is given, then progress the integration until there is a temporal difference <code>≥ dt</code> (so, step <em>at least</em> for <code>dt</code> time).</p><p>When <code>true</code> is passed to the optional third argument, the integration advances for exactly <code>dt</code> time.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}" href="#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}"><code>SciMLBase.reinit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reinit!(ds::DynamicalSystem, u = initial_state(ds); kwargs...) → ds</code></pre><p>Reset the status of <code>ds</code>, so that it is as if it has be just initialized with initial state <code>u</code>. Practically every function of the ecosystem that evolves <code>ds</code> first calls this function on it. Besides the new initial state <code>u</code>, you can also configure the keywords <code>t0 = initial_time(ds)</code> and <code>p = current_parameters(ds)</code>.</p><p>Note the default settings: the state and time are the initial, but the parameters are the current.</p><p>The special method <code>reinit!(ds, ::Nothing; kwargs...)</code> is also available, which does nothing and leaves the system as is. This is so that downstream functions that call <code>reinit!</code> can still be used without resetting the system but rather continuing from its exact current state.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.set_parameter!" href="#DynamicalSystemsBase.set_parameter!"><code>DynamicalSystemsBase.set_parameter!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_parameter!(ds::DynamicalSystem, index, value)</code></pre><p>Change a parameter of <code>ds</code> given the <code>index</code> it has in the parameter container and the <code>value</code> to set it to. This function works for both array/dictionary containers as well as composite types. In the latter case <code>index</code> needs to be a <code>Symbol</code>.</p></div></section></article><h2 id="StateSpaceSet-reference"><a class="docs-heading-anchor" href="#StateSpaceSet-reference"><code>StateSpaceSet</code> reference</a><a id="StateSpaceSet-reference-1"></a><a class="docs-heading-anchor-permalink" href="#StateSpaceSet-reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.StateSpaceSet" href="#StateSpaceSets.StateSpaceSet"><code>StateSpaceSets.StateSpaceSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StateSpaceSet{D, T} &lt;: AbstractStateSpaceSet{D,T}</code></pre><p>A dedicated interface for sets in a state space. It is an <strong>ordered container of equally-sized points</strong> of length <code>D</code>. Each point is represented by <code>SVector{D, T}</code>. The data are a standard Julia <code>Vector{SVector}</code>, and can be obtained with <code>vec(ssset::StateSpaceSet)</code>. Typically the order of points in the set is the time direction, but it doesn&#39;t have to be.</p><p>When indexed with 1 index, <code>StateSpaceSet</code> is like a vector of points. When indexed with 2 indices it behaves like a matrix that has each of the columns be the timeseries of each of the variables. When iterated over, it iterates over its contained points. See description of indexing below for more.</p><p><code>StateSpaceSet</code> also supports almost all sensible vector operations like <code>append!, push!, hcat, eachrow</code>, among others.</p><p><strong>Description of indexing</strong></p><p>In the following let <code>i, j</code> be integers, <code>typeof(X) &lt;: AbstractStateSpaceSet</code> and <code>v1, v2</code> be <code>&lt;: AbstractVector{Int}</code> (<code>v1, v2</code> could also be ranges, and for performance benefits make <code>v2</code> an <code>SVector{Int}</code>).</p><ul><li><code>X[i] == X[i, :]</code> gives the <code>i</code>th point (returns an <code>SVector</code>)</li><li><code>X[v1] == X[v1, :]</code>, returns a <code>StateSpaceSet</code> with the points in those indices.</li><li><code>X[:, j]</code> gives the <code>j</code>th variable timeseries (or collection), as <code>Vector</code></li><li><code>X[v1, v2], X[:, v2]</code> returns a <code>StateSpaceSet</code> with the appropriate entries (first indices being &quot;time&quot;/point index, while second being variables)</li><li><code>X[i, j]</code> value of the <code>j</code>th variable, at the <code>i</code>th timepoint</li></ul><p>Use <code>Matrix(ssset)</code> or <code>StateSpaceSet(matrix)</code> to convert. It is assumed that each <em>column</em> of the <code>matrix</code> is one variable. If you have various timeseries vectors <code>x, y, z, ...</code> pass them like <code>StateSpaceSet(x, y, z, ...)</code>. You can use <code>columns(dataset)</code> to obtain the reverse, i.e. all columns of the dataset in a tuple.</p></div></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-DatserisParlitz2022"><a class="tag is-link" href="#citeref-DatserisParlitz2022">DatserisParlitz2022</a>Datseris &amp; Parlitz 2022, <em>Nonlinear Dynamics: A Concise Introduction Interlaced with Code</em>, <a href="https://doi.org/10.1007/978-3-030-91032-7">Springer Nature, Undergrad. Lect. Notes In Physics</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Attractors.jl</a><a class="docs-footer-nextpage" href="../attractors/">Finding Attractors »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 1 June 2023 10:16">Thursday 1 June 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
