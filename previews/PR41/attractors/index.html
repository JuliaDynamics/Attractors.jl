<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Finding Attractors · Attractors.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Attractors.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Attractors.jl</a></li><li class="is-active"><a class="tocitem" href>Finding Attractors</a><ul class="internal"><li><a class="tocitem" href="#Recurrences"><span>Recurrences</span></a></li><li><a class="tocitem" href="#Proximity"><span>Proximity</span></a></li><li><a class="tocitem" href="#Featurizing"><span>Featurizing</span></a></li><li><a class="tocitem" href="#Grouping-configurations"><span>Grouping configurations</span></a></li></ul></li><li><a class="tocitem" href="../basins/">Basins of Attraction</a></li><li><a class="tocitem" href="../continuation/">Attractor &amp; Basins Continuation</a></li><li><a class="tocitem" href="../examples/">Examples for Attractors.jl</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Finding Attractors</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Finding Attractors</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/Attractors.jl/blob/main/docs/src/attractors.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Finding-Attractors"><a class="docs-heading-anchor" href="#Finding-Attractors">Finding Attractors</a><a id="Finding-Attractors-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-Attractors" title="Permalink"></a></h1><p>Attractors.jl defines a generic interface for finding attractors of dynamical systems. One first decides the instance of <a href="@ref"><code>GeneralizedDynamicalSystem</code></a> they need. Then, an instance of <a href="#Attractors.AttractorMapper"><code>AttractorMapper</code></a> is created from this dynamical system. This <code>mapper</code> instance can be used to compute e.g., <a href="../basins/#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>, and the output can be further analyzed to get e.g., the <a href="../basins/#Attractors.basin_entropy"><code>basin_entropy</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Attractors.AttractorMapper" href="#Attractors.AttractorMapper"><code>Attractors.AttractorMapper</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AttractorMapper(ds::DynamicalSystem, args...; kwargs...) → mapper</code></pre><p>Subtypes of <code>AttractorMapper</code> are structures that map initial conditions of <code>ds</code> to attractors. The type of <code>ds</code> cannot be <a href="@ref"><code>ParallelDynamicalSystem</code></a> or <a href="@ref"><code>TangentDynamicalSystem</code></a> (because it doesn&#39;t make sense).</p><p>Currently available mapping methods:</p><ul><li><a href="#Attractors.AttractorsViaProximity"><code>AttractorsViaProximity</code></a></li><li><a href="#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a></li><li><a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a></li></ul><p>All <code>AttractorMapper</code> subtypes can be used with <a href="../basins/#Attractors.basins_fractions"><code>basins_fractions</code></a> or <a href="../basins/#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>.</p><p>In addition, some mappers can be called as a function of an initial condition:</p><pre><code class="language-julia hljs">label = mapper(u0)</code></pre><p>and this will on the fly compute and return the label of the attractor <code>u0</code> converges at. The mappers that can do this are:</p><ul><li><a href="#Attractors.AttractorsViaProximity"><code>AttractorsViaProximity</code></a></li><li><a href="#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a></li><li><a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a> with the <a href="#Attractors.GroupViaHistogram"><code>GroupViaHistogram</code></a> configuration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/b129b4f8dc5670e5107ead19699addf2fcee1a82/src/mapping/attractor_mapping.jl#L16-L40">source</a></section></article><h2 id="Recurrences"><a class="docs-heading-anchor" href="#Recurrences">Recurrences</a><a id="Recurrences-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrences" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Attractors.AttractorsViaRecurrences" href="#Attractors.AttractorsViaRecurrences"><code>Attractors.AttractorsViaRecurrences</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AttractorsViaRecurrences(ds::DynamicalSystem, grid::Tuple; kwargs...)</code></pre><p>Map initial conditions of <code>ds</code> to attractors by identifying attractors on the fly based on recurrences in the state space, as outlined by Datseris &amp; Wagemakers<sup class="footnote-reference"><a id="citeref-Datseris2022" href="#footnote-Datseris2022">[Datseris2022]</a></sup>.</p><p><code>grid</code> is a tuple of ranges partitioning the state space so that a finite state machine can operate on top of it. For example <code>grid = (xg, yg)</code> where <code>xg = yg = range(-5, 5; length = 100)</code> for a two-dimensional system. The grid has to be the same dimensionality as the state space, use a <a href="@ref"><code>ProjectedDynamicalSystem</code></a> if you want to search for attractors in a lower dimensional subspace.</p><p><strong>Keyword arguments</strong></p><ul><li><code>sparse = true</code>: control the interval representation of the state space grid. If true,  uses a sparse array, whose memory usage is in general more efficient than a regular  array obtained with <code>sparse=false</code>. In practice, the sparse representation should  always be preferred when searching for <a href="../basins/#Attractors.basins_fractions"><code>basins_fractions</code></a>. Only for very low  dimensional systems and for computing the full <a href="../basins/#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a> the  non-sparse version should be used.</li></ul><p><strong>Time evolution configuration</strong></p><ul><li><code>Ttr = 0</code>: Skip a transient before the recurrence routine begins.</li><li><code>Δt</code>: Approximate integration time step (second argument of the <code>step!</code> function). It is <code>1</code> for discrete time systems. For continuous systems, an automatic value is calculated using <a href="#Attractors.automatic_Δt_basins"><code>automatic_Δt_basins</code></a>. For very fine grids, this can become very small, much smaller than the typical integrator internal step size in case of adaptive integrators. In such cases, it is much better to use non-adaptive ODE solvers with a small step size, e.g., <code>diffeq = (alg = Tsit5(), adaptive = false, dt = 0.001)</code> (and also give <code>Δt = dt</code> in this case for best performance)</li></ul><p><strong>Finite state machine configuration</strong></p><ul><li><code>mx_chk_att = 2</code>: Μaximum checks of consecutives hits of an existing attractor cell before declaring convergence to that existing attractor.</li><li><code>mx_chk_hit_bas = 10</code>: Maximum check of consecutive visits of the same basin of attraction before declaring convergence to an existing attractor.</li><li><code>mx_chk_fnd_att = 100</code>: Maximum check of consecutive visits to a previously visited unlabeled cell before declaring we have found a new attractor.</li><li><code>mx_chk_loc_att = 100</code>: Maximum check of consecutive visits to cells marked as a new attractor, during the attractor identification phase, before declaring we that we have identified the new attractor with sufficient cells.</li><li><code>store_once_per_cell = true</code>: Control if multiple points in state space that belong to the same cell are stored or not in the attractor, after an attractor is found. If <code>true</code>, each visited cell will only store a point once, which is desirable for fixed points and limit cycles. If <code>false</code>, at least <code>mx_chk_loc_att</code> points are stored per attractor, leading to more densely stored attractors, which may be desirable for instance in chaotic attractors.</li><li><code>mx_chk_lost = 20</code>: Maximum check of iterations outside the defined grid before we declare the orbit lost outside and hence assign it label <code>-1</code>.</li><li><code>horizon_limit = 1e6</code>: If the norm of the integrator state reaches this limit we declare that the orbit diverged to infinity.</li><li><code>mx_chk_safety = Int(1e6)</code>: A safety counter that is always increasing for each initial condition. Once exceeded, the algorithm assigns <code>-1</code> and throws a warning. This clause exists to stop the algorithm never haulting for innappropriate grids, where a found attractor may intersect in the same cell with a new attractor the orbit traces (which leads to infinite resetting of all counters).</li></ul><p><strong>Description</strong></p><p>An initial condition given to an instance of <code>AttractorsViaRecurrences</code> is iterated based on the integrator corresponding to <code>ds</code>. A recurrence in the state space means that the trajectory has converged to an attractor. This is the basis for finding attractors.</p><p>A finite state machine (FSM) follows the trajectory in the state space, and constantly maps it to the given <code>grid</code>. The FSM decides when an initial condition has successfully converged into an attractor. An array, internally called &quot;basins&quot;, stores the state of the FSM on the grid, according to the indexing system described in <sup class="footnote-reference"><a id="citeref-Datseris2022" href="#footnote-Datseris2022">[Datseris2022]</a></sup>. As the system is integrated more and more, the information of the &quot;basins&quot; becomes richer and richer with more identified attractors or with grid cells that belong to basins of already found attractors. Notice that only in the special method <code>basins_of_attraction(mapper::AttractorsViaRecurrences)</code> the information of the attraction or exit basins is utilized. In other functions like <code>basins_fractions</code> only the attractor locations are utilized, as the basins themselves are not stored.</p><p>The iteration of a given initial condition continues until one of the following happens:</p><ul><li>The trajectory hits <code>mx_chk_fnd_att</code> times in a row grid cells previously visited:  it is considered that an attractor is found and is labelled with a new ID. Then,  iteration continues a bit more until we have identified the attractor with sufficient  accuracy, i.e., until <code>mx_chk_loc_att</code> cells with the new ID have been visited.</li><li>The trajectory hits an already identified attractor <code>mx_chk_att</code> consecutive times:  the initial condition is numbered with the attractor&#39;s ID.</li><li>The trajectory hits a known basin <code>mx_chk_hit_bas</code> times in a row: the initial condition  belongs to that basin and is numbered accordingly. Notice that basins are stored and  used only when <code>sparse = false</code>.</li><li>The trajectory spends <code>mx_chk_lost</code> steps outside the defined grid or the norm  of the integrator state becomes &gt; than <code>horizon_limit</code>: the initial  condition&#39;s label is set to <code>-1</code>.</li><li>If none of the above happens, the initial condition is labelled <code>-1</code> after  and <code>mx_chk_safety</code> integrator steps.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/b129b4f8dc5670e5107ead19699addf2fcee1a82/src/mapping/attractor_mapping_recurrences.jl#L5-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Attractors.automatic_Δt_basins" href="#Attractors.automatic_Δt_basins"><code>Attractors.automatic_Δt_basins</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">automatic_Δt_basins(ds::DynamicalSystem, grid; N = 5000) → Δt</code></pre><p>Calculate an optimal <code>Δt</code> value for <a href="../basins/#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>. This is done by evaluating the dynamic rule <code>f</code> (vector field) at <code>N</code> randomly chosen points of the grid. The average <code>f</code> is then compared with the diagonal length of a grid cell and their ratio provides <code>Δt</code>.</p><p>Notice that <code>Δt</code> should not be too small which happens typically if the grid resolution is high. It is okay for <a href="../basins/#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a> if the trajectory skips a few cells. But if <code>Δt</code> is too small the default values for all other keywords such as <code>mx_chk_hit_bas</code> need to be increased drastically.</p><p>Also, <code>Δt</code> that is smaller than the internal step size of the integrator will cause a performance drop.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/b129b4f8dc5670e5107ead19699addf2fcee1a82/src/mapping/attractor_mapping_recurrences.jl#L242-L257">source</a></section></article><h2 id="Proximity"><a class="docs-heading-anchor" href="#Proximity">Proximity</a><a id="Proximity-1"></a><a class="docs-heading-anchor-permalink" href="#Proximity" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Attractors.AttractorsViaProximity" href="#Attractors.AttractorsViaProximity"><code>Attractors.AttractorsViaProximity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AttractorsViaProximity(ds::DynamicalSystem, attractors::Dict [, ε]; kwargs...)</code></pre><p>Map initial conditions to attractors based on whether the trajectory reaches <code>ε</code>-distance close to any of the user-provided <code>attractors</code>. They have to be in a form of a dictionary mapping attractor labels to <code>Dataset</code>s containing the attractors.</p><p>The system gets stepped, and at each step the minimum distance to all attractors is computed. If any of these distances is <code>&lt; ε</code>, then the label of the nearest attractor is returned.</p><p>If an <code>ε::Real</code> is <em>not</em> provided by the user, a value is computed automatically as half of the minimum distance between all attractors. This operation can be expensive for large attractor datasets. If <code>length(attractors) == 1</code>, then <code>ε</code> becomes 1/10 of the diagonal of the box containing the attractor. If <code>length(attractors) == 1</code> and the attractor is a single point, an error is thrown.</p><p>Because in this method the attractors are already known to the user, the method can also be called <em>supervised</em>.</p><p><strong>Keywords</strong></p><ul><li><code>Ttr = 100</code>: Transient time to first evolve the system for before checking for proximity.</li><li><code>Δt = 1</code>: Step time given to <code>step!</code>.</li><li><code>horizon_limit = 1e3</code>: If the maximum distance of the trajectory from any of the given attractors exceeds this limit, it is assumed that the trajectory diverged (gets labelled as <code>-1</code>).</li><li><code>mx_chk_lost = 1000</code>: If the integrator has been stepped this many times without coming <code>ε</code>-near to any attractor,  it is assumed that the trajectory diverged (gets labelled as <code>-1</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/b129b4f8dc5670e5107ead19699addf2fcee1a82/src/mapping/attractor_mapping_proximity.jl#L1-L31">source</a></section></article><h2 id="Featurizing"><a class="docs-heading-anchor" href="#Featurizing">Featurizing</a><a id="Featurizing-1"></a><a class="docs-heading-anchor-permalink" href="#Featurizing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Attractors.AttractorsViaFeaturizing" href="#Attractors.AttractorsViaFeaturizing"><code>Attractors.AttractorsViaFeaturizing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AttractorsViaFeaturizing(
    ds::DynamicalSystem, featurizer::Function,
    grouping_config = GroupViaClustering(); kwargs...
)</code></pre><p>Initialize a <code>mapper</code> that maps initial conditions to attractors using a featurizing and grouping approach. This is a supercase of the featurizing and clustering approach that is utilized by bSTAB<sup class="footnote-reference"><a id="citeref-Stender2021" href="#footnote-Stender2021">[Stender2021]</a></sup> and MCBB<sup class="footnote-reference"><a id="citeref-Gelbrecht2021" href="#footnote-Gelbrecht2021">[Gelbrecht2021]</a></sup>. See <a href="#Attractors.AttractorMapper"><code>AttractorMapper</code></a> for how to use the <code>mapper</code>. This <code>mapper</code> also allows the syntax <code>mapper(u0)</code> but only if the <code>grouping_config</code> is <em>not</em> <code>GroupViaClustering</code>.</p><p><code>featurizer</code> is a function that takes as an input an integrated trajectory <code>A::Dataset</code> and the corresponding time vector <code>t</code> and returns an <code>SVector{&lt;:Real}</code> of features describing the trajectory. It is important to use static vectors for better performance.</p><p><code>grouping_config</code> is an instance of any subtype of <a href="#Attractors.GroupingConfig"><code>GroupingConfig</code></a> and decides how features will be grouped into attractors, see below.</p><p>See also the intermediate functions <a href="#Attractors.extract_features"><code>extract_features</code></a> and <a href="#Attractors.group_features"><code>group_features</code></a>, which can be utilized when wanting to work directly with features.</p><p><strong>Keyword arguments</strong></p><ul><li><code>T=100, Ttr=100, Δt=1</code>: Propagated to <a href="@ref"><code>trajectory</code></a>.</li><li><code>threaded = true</code>: Whether to run the generation of features over threads by integrating trajectories in parallel.</li></ul><p><strong>Description</strong></p><p>The trajectory <code>X</code> of an initial condition is transformed into features. Each feature is a number useful in <em>characterizing the attractor</em> the initial condition ends up at, and distinguishing it from other attractors. Example features are the mean or standard deviation of some the dimensions of the trajectory, the entropy of some of the dimensions, the fractal dimension of <code>X</code>, or anything else you may fancy.</p><p>All feature vectors (each initial condition = 1 vector) are then grouped using one of the sevaral available grouping configurations. Each group is assumed to be a unique attractor, and hence each initial condition is labelled according to the group it is part of. The method thus relies on the user having at least some basic idea about what attractors to expect in order to pick the right features, and the right way to group them, in contrast to <a href="#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/b129b4f8dc5670e5107ead19699addf2fcee1a82/src/mapping/attractor_mapping_featurizing.jl#L21-L71">source</a></section></article><h2 id="Grouping-configurations"><a class="docs-heading-anchor" href="#Grouping-configurations">Grouping configurations</a><a id="Grouping-configurations-1"></a><a class="docs-heading-anchor-permalink" href="#Grouping-configurations" title="Permalink"></a></h2><h3 id="Grouping-types"><a class="docs-heading-anchor" href="#Grouping-types">Grouping types</a><a id="Grouping-types-1"></a><a class="docs-heading-anchor-permalink" href="#Grouping-types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Attractors.GroupingConfig" href="#Attractors.GroupingConfig"><code>Attractors.GroupingConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><p>GroupingConfig</p><p>Supertype for configuration structs on how to group features together. Used in several occasions such as <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a> or <a href="../continuation/#Attractors.aggregate_attractor_fractions"><code>aggregate_attractor_fractions</code></a>.</p><p>Currently available grouping configurations are:</p><ul><li><a href="#Attractors.GroupViaClustering"><code>GroupViaClustering</code></a></li><li><a href="#Attractors.GroupViaNearestFeature"><code>GroupViaNearestFeature</code></a></li><li><a href="#Attractors.GroupViaHistogram"><code>GroupViaHistogram</code></a></li></ul><p><code>GroupingConfig</code> defines an extendable interface. The only thing necessary for a new grouping configuration is to:</p><ol><li>Make a new type and subtype <code>GroupingConfig</code>.</li><li>If the grouping allows for mapping individual initial conditions to IDs, then instead extend the <strong>internal function</strong> <code>feature_to_group(feature, config)</code>. This will allow doing <code>id = mapper(u0)</code> with <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a>.</li><li>Else, extend the function <code>group_features(features, config)</code>. You could still extend <code>group_features</code> even if (2.) is satisfied, if there are any performance benefits.</li><li>Include the new grouping file in the <code>grouping/all_grouping_configs.jl</code> and list it in this documentation string.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/b129b4f8dc5670e5107ead19699addf2fcee1a82/src/mapping/grouping/all_grouping_configs.jl#L3-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Attractors.GroupViaClustering" href="#Attractors.GroupViaClustering"><code>Attractors.GroupViaClustering</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GroupViaClustering(; kwargs...)</code></pre><p>Initialize a struct that contains instructions on how to group features in <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a>. <code>GroupViaClustering</code> clusters features into groups using DBSCAN, similar to the original work by bSTAB<sup class="footnote-reference"><a id="citeref-Stender2021" href="#footnote-Stender2021">[Stender2021]</a></sup> and MCBB<sup class="footnote-reference"><a id="citeref-Gelbrecht2021" href="#footnote-Gelbrecht2021">[Gelbrecht2021]</a></sup>. Several options on clustering are available, see keywords below.</p><p>The defaults are a significant improvement over existing literature, see Description.</p><p><strong>Keyword arguments</strong></p><ul><li><code>clust_distance_metric = Euclidean()</code>: metric to be used in the clustering.</li><li><code>rescale_features = true</code>: if true, rescale each dimension of the extracted features separately into the range <code>[0,1]</code>. This typically leads to more accurate clustering.</li><li><code>min_neighbors = 10</code>: minimum number of neighbors (i.e. of similar features) each feature needs to have, including counting its own self, in order to be considered in a cluster (fewer than this, it is labeled as an outlier, <code>-1</code>).</li><li><code>use_mmap = false</code>: whether to use an on-disk map for creating the distance matrix of the features. Useful when the features are so many where a matrix with side their length would not fit to memory.</li></ul><p><strong>Keywords for optimal radius estimation</strong></p><ul><li><code>optimal_radius_method::Union{Real, String} = &quot;silhouettes_optim&quot;</code>: if a real number, it is the radius used to cluster features. Otherwise, it determines the method used to automatically determine that radius. Possible values are:<ul><li><code>&quot;silhouettes&quot;</code>: Performs a linear (sequential) search for the radius that maximizes a   statistic of the silhouette values of clusters (typically the mean). This can be chosen   with <code>silhouette_statistic</code>. The linear search may take some time to finish. To   increase speed, the number of radii iterated through can be reduced by decreasing   <code>num_attempts_radius</code> (see its entry below).</li><li><code>&quot;silhouettes_optim&quot;</code>: Same as <code>&quot;silhouettes&quot;</code> but performs an optimized search via   Optim.jl. It&#39;s faster than <code>&quot;silhouettes&quot;</code>, with typically the same accuracy (the   search here is not guaranteed to always find the global maximum, though it typically   gets close).</li><li><code>&quot;knee&quot;</code>: chooses the the radius according to the knee (a.k.a. elbow,   highest-derivative method) and is quicker, though generally leading to much worse   clustering. It requires that <code>min_neighbors</code> &gt; 1.</li></ul></li><li><code>num_attempts_radius = 100</code>: number of radii that the <code>optimal_radius_method</code> will try out in its iterative procedure. Higher values increase the accuracy of clustering, though not necessarily much, while always reducing speed.</li><li><code>silhouette_statistic::Function = mean</code>: statistic (e.g. mean or minimum) of the silhouettes that is maximized in the &quot;optimal&quot; clustering. The original implementation in <sup class="footnote-reference"><a id="citeref-Stender2021" href="#footnote-Stender2021">[Stender2021]</a></sup> used the <code>minimum</code> of the silhouettes, and typically performs less accurately than the <code>mean</code>.</li><li><code>max_used_features = 0</code>: if not <code>0</code>, it should be an <code>Int</code> denoting the max amount of features to be used when finding the optimal radius. Useful when clustering a very large number of features (e.g., high accuracy estimation of fractions of basins of attraction).</li></ul><p><strong>Description</strong></p><p>The DBSCAN clustering algorithm is used to automatically identify clusters of similar features. Each feature vector is a point in a feature space. Each cluster then basically groups points that are closely packed together. Closely packed means that the points have at least <code>min_neighbors</code> inside a ball of radius <code>optimal_radius</code> centered on them. This method typically works well if the radius is chosen well, which is not necessarily an easy task. Currently, three methods are implemented to automatically estimate an &quot;optimal&quot; radius.</p><p><strong>Estimating the optimal radius</strong></p><p>The default method is the <strong>silhouettes method</strong>, which includes keywords <code>silhouette</code> and <code>silhouette_optim</code>. Both of them search for the radius that optimizes the clustering, meaning the one that maximizes a statistic <code>silhouette_statistic</code> (e.g. mean value) of a quantifier for the quality of each cluster. This quantifier is the silhouette value of each identified cluster. A silhouette value measures how similar a point is to the cluster it currently belongs to, compared to the other clusters, and ranges from -1 (worst matching) to +1 (ideal matching). If only one cluster is found, the assigned silhouette is zero. So for each attempted radius in the search the clusters are computed, their silhouettes calculated, and the statistic of these silhouettes computed. The algorithm then finds the radius that leads to the maximum such statistic. For <code>optimal_radius_method = &quot;silhouettes&quot;</code>, the search is done linearly, from a minimum to a maximum candidate radius for <code>optimal_radius_method = &quot;silhouettes&quot;</code>; <code>optimal_radius_method = silhouettes_optim</code>, it is done via an optimized search performed by Optim.jl which is typically faster and with similar accuracy. A third alternative is the<code>&quot;elbow&quot;</code> method, which works by calculating the distance of each point to its k-nearest-neighbors (with <code>k=min_neighbors</code>) and finding the distance corresponding to the highest derivative in the curve of the distances, sorted in ascending order. This distance is chosen as the optimal radius. It is described in <sup class="footnote-reference"><a id="citeref-Kriegel1996" href="#footnote-Kriegel1996">[Kriegel1996]</a></sup> and <sup class="footnote-reference"><a id="citeref-Schubert2017" href="#footnote-Schubert2017">[Schubert2017]</a></sup>. It typically performs considerably worse than the <code>&quot;silhouette&quot;</code> methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/b129b4f8dc5670e5107ead19699addf2fcee1a82/src/mapping/grouping/cluster_config.jl#L5-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Attractors.GroupViaHistogram" href="#Attractors.GroupViaHistogram"><code>Attractors.GroupViaHistogram</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GroupViaHistogram(binning::FixedRectangularBinning)</code></pre><p>Initialize a struct that contains instructions on how to group features in <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a>. <code>GroupViaHistogram</code> performs a histogram in feature space. Then, all features that are in the same histogram bin get the same label. The <code>binning</code> is an instance of <a href="@ref"><code>FixedRectangularBinning</code></a> from ComplexityMeasures.jl. (the reason to not allow <code>RectangularBinning</code> is because during continuation we need to ensure that bins remain identical).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/b129b4f8dc5670e5107ead19699addf2fcee1a82/src/mapping/grouping/histogram_config.jl#L5-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Attractors.GroupViaNearestFeature" href="#Attractors.GroupViaNearestFeature"><code>Attractors.GroupViaNearestFeature</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GroupViaNearestFeature(templates; kwargs...)</code></pre><p>Initialize a struct that contains instructions on how to group features in <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a>. <code>GroupViaNearestFeature</code> accepts a <code>template</code>, which is a vector of features. Then, generated features from initial conditions in <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a> are labelled according to the feature in <code>templates</code> that is closest (the label is the index of the closest template).</p><p><code>templates</code> can be a vector or dictionary mapping keys to templates. Internally all templates are converted to <code>SVector</code> for performance. Hence, it is strongly recommended that both <code>templates</code> and the output of the <code>featurizer</code> function in <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a> return <code>SVector</code> types.</p><p><strong>Keyword arguments</strong></p><ul><li><code>metric = Euclidean()</code>: metric to be used to quantify distances in the feature space.</li><li><code>max_distance = Inf</code>: Maximum allowed distance between a feature and its nearest template for it to be assigned to that template. By default, <code>Inf</code> guarantees that a feature is assigned to its nearest template regardless of the distance. Features that exceed <code>max_distance</code> to their nearest template get labelled <code>-1</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/b129b4f8dc5670e5107ead19699addf2fcee1a82/src/mapping/grouping/nearest_feature_config.jl#L4-L24">source</a></section></article><h3 id="Grouping-utility-functions"><a class="docs-heading-anchor" href="#Grouping-utility-functions">Grouping utility functions</a><a id="Grouping-utility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Grouping-utility-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Attractors.group_features" href="#Attractors.group_features"><code>Attractors.group_features</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">group_features(features, group_config::GroupingConfig) → labels</code></pre><p>Group the given vector of feature vectors according to the configuration and return the labels (vector of equal length as <code>features</code>). See <a href="#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a> for possible configurations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/b129b4f8dc5670e5107ead19699addf2fcee1a82/src/mapping/grouping/all_grouping_configs.jl#L31-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Attractors.extract_features" href="#Attractors.extract_features"><code>Attractors.extract_features</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_features(mapper, ics; N = 1000, show_progress = true)</code></pre><p>Return a vector of the features of each initial condition in <code>ics</code> (as in <a href="../basins/#Attractors.basins_fractions"><code>basins_fractions</code></a>), using the configuration of <code>mapper::AttractorsViaFeaturizing</code>. Keyword <code>N</code> is ignored if <code>ics isa Dataset</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Attractors.jl/blob/b129b4f8dc5670e5107ead19699addf2fcee1a82/src/mapping/attractor_mapping_featurizing.jl#L121-L127">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Datseris2022"><a class="tag is-link" href="#citeref-Datseris2022">Datseris2022</a>G. Datseris and A. Wagemakers, <em>Effortless estimation of basins of attraction</em>, <a href="https://doi.org/10.1063/5.0076568">Chaos 32, 023104 (2022)</a></li><li class="footnote" id="footnote-Stender2021"><a class="tag is-link" href="#citeref-Stender2021">Stender2021</a>Stender &amp; Hoffmann 2021, <a href="https://doi.org/10.1007/s11071-021-06786-5">bSTAB: an open-source software for computing the basin stability of multi-stable dynamical systems</a></li><li class="footnote" id="footnote-Gelbrecht2021"><a class="tag is-link" href="#citeref-Gelbrecht2021">Gelbrecht2021</a>Maximilian Gelbrecht et al 2021, Monte Carlo basin bifurcation analysis, <a href="http://dx.doi.org/10.1088/1367-2630/ab7a05">New J. Phys.22 03303</a></li><li class="footnote" id="footnote-Stender2021"><a class="tag is-link" href="#citeref-Stender2021">Stender2021</a>Stender &amp; Hoffmann 2021, <a href="https://doi.org/10.1007/s11071-021-06786-5">bSTAB: an open-source software for computing the basin stability of multi-stable dynamical systems</a></li><li class="footnote" id="footnote-Gelbrecht2021"><a class="tag is-link" href="#citeref-Gelbrecht2021">Gelbrecht2021</a>Maximilian Gelbrecht et al 2021, Monte Carlo basin bifurcation analysis, <a href="http://dx.doi.org/10.1088/1367-2630/ab7a05">2020 New J. Phys.22 03303</a></li><li class="footnote" id="footnote-Kriegel1996"><a class="tag is-link" href="#citeref-Kriegel1996">Kriegel1996</a>Ester, Kriegel, Sander and Xu: A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise</li><li class="footnote" id="footnote-Schubert2017"><a class="tag is-link" href="#citeref-Schubert2017">Schubert2017</a>Schubert, Sander, Ester, Kriegel and Xu: DBSCAN Revisited, Revisited: Why and How You Should (Still) Use DBSCAN</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Attractors.jl</a><a class="docs-footer-nextpage" href="../basins/">Basins of Attraction »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 20 February 2023 15:44">Monday 20 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
