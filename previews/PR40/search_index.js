var documenterSearchIndex = {"docs":
[{"location":"basins/#Basins-of-Attraction","page":"Basins of Attraction","title":"Basins of Attraction","text":"","category":"section"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"This page provides several functions related to the basins of attraction and their boundaries. It requires you to have first understood the Finding Attractors page.","category":"page"},{"location":"basins/#Basins-of-attraction","page":"Basins of Attraction","title":"Basins of attraction","text":"","category":"section"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"Calculating basins of attraction, or their state space fractions, can be done with the functions:","category":"page"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"basins_fractions\nbasins_of_attraction.","category":"page"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"basins_fractions\nbasins_of_attraction\nstatespace_sampler","category":"page"},{"location":"basins/#Attractors.basins_fractions","page":"Basins of Attraction","title":"Attractors.basins_fractions","text":"basins_fractions(mapper::AttractorMapper, ics::Union{Dataset, Function}; kwargs...)\n\nApproximate the state space fractions fs of the basins of attraction of a dynamical stystem by mapping initial conditions to attractors using mapper (which contains a reference to a GeneralizedDynamicalSystem). The fractions are simply the ratios of how many initial conditions ended up at each attractor.\n\nInitial conditions to use are defined by ics. It can be:\n\na Dataset of initial conditions, in which case all are used.\na 0-argument function ics() that spits out random initial conditions. Then N random initial conditions are chosen. See statespace_sampler to generate such functions.\n\nThe returned arguments are fs. If ics is a Dataset then the labels of each initial condition and roughly approximated attractors are also returned: fs, labels, attractors.\n\nThe output fs is a dictionary whose keys are the labels given to each attractor (always integers enumerating the different attractors), and the values are their respective fractions. The label -1 is given to any initial condition where mapper could not match to an attractor (this depends on the mapper type). attractors has the same structure, mapping labels to Datasets.\n\nSee AttractorMapper for all possible mapper types.\n\nKeyword arguments\n\nN = 1000: Number of random initial conditions to generate in case ics is a function.\nshow_progress = true: Display a progress bar of the process.\n\n\n\n\n\nbasins_fractions(basins::AbstractArray) → fs::Dict\n\nCalculate the state space fraction of the basins of attraction encoded in basins. The elements of basins are integers, enumerating the attractor that the entry of basins converges to (i.e., like the output of basins_of_attraction). Return a dictionary that maps attractor IDs to their relative fractions.\n\nIn[Menck2013] the authors use these fractions to quantify the stability of a basin of attraction, and specifically how it changes when a parameter is changed. For this, see continuation.\n\n[Menck2013]: Menck, Heitzig, Marwan & Kurths. How basin stability complements the linear stability paradigm. Nature Physics, 9(2), 89–92\n\n\n\n\n\n","category":"function"},{"location":"basins/#Attractors.basins_of_attraction","page":"Basins of Attraction","title":"Attractors.basins_of_attraction","text":"basins_of_attraction(mapper::AttractorMapper, grid::Tuple) → basins, attractors\n\nCompute the full basins of attraction as identified by the given mapper, which includes a reference to a GeneralizedDynamicalSystem and return them along with (perhaps approximated) found attractors.\n\ngrid is a tuple of ranges defining the grid of initial conditions that partition the state space into boxes with size the step size of each range. For example, grid = (xg, yg) where xg = yg = range(-5, 5; length = 100). The grid has to be the same dimensionality as the state space expected by the integrator/system used in mapper. E.g., a projected_integrator could be used for lower dimensional projections, etc. A special case here is a poincaremap with plane being Tuple{Int, <: Real}. In this special scenario the grid can be one dimension smaller than the state space, in which case the partitioning happens directly on the hyperplane the Poincaré map operates on.\n\nbasins_of_attraction function is a convenience 5-lines-of-code wrapper which uses the labels returned by basins_fractions and simply assings them to a full array corresponding to the state space partitioning indicated by grid.\n\n\n\n\n\nbasins_of_attraction(mapper::AttractorsViaRecurrences; show_progress = true)\n\nThis is a special method of basins_of_attraction that using recurrences does exactly what is described in the paper by Datseris & Wagemakers[Datseris2022]. By enforcing that the internal grid of mapper is the same as the grid of initial conditions to map to attractors, the method can further utilize found exit and attraction basins, making the computation faster as the grid is processed more and more.\n\n[Datseris2022]: G. Datseris and A. Wagemakers, Effortless estimation of basins of attraction, Chaos 32, 023104 (2022)\n\n\n\n\n\n","category":"function"},{"location":"basins/#StateSpaceSets.statespace_sampler","page":"Basins of Attraction","title":"StateSpaceSets.statespace_sampler","text":"statespace_sampler(rng = Random.GLOBAL_RNG; kwargs...) → sampler, isinside\n\nConvenience function that creates two functions. sampler is a 0-argument function that generates random points inside a state space region defined by the keywords. isinside is a 1-argument function that decides returns true if the given state space point is inside that region.\n\nThe regions can be:\n\nRectangular box, with edges min_bounds and max_bounds. The sampling of the points inside the box is decided by the keyword method which can be either \"uniform\" or \"multgauss\".\nSphere, of spheredims dimensions, radius radius and centered on center.\n\n\n\n\n\n","category":"function"},{"location":"basins/#Final-state-sensitivity-/-fractal-boundaries","page":"Basins of Attraction","title":"Final state sensitivity / fractal boundaries","text":"","category":"section"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"Several functions are provided related with analyzing the fractality of the boundaries of the basins of attraction:","category":"page"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"basins_fractal_dimension\nbasin_entropy\nbasins_fractal_test\nuncertainty_exponent","category":"page"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"basins_fractal_dimension\nbasin_entropy\nbasins_fractal_test\nuncertainty_exponent","category":"page"},{"location":"basins/#Attractors.basins_fractal_dimension","page":"Basins of Attraction","title":"Attractors.basins_fractal_dimension","text":"basins_fractal_dimension(basins; kwargs...) -> V_ε, N_ε ,d\n\nEstimate the Fractal Dimension d of the boundary between basins of attraction using the box-counting algorithm.\n\nThe output N_ε is a vector with the number of the balls of radius ε (in pixels) that contain at least two initial conditions that lead to different attractors. V_ε is a vector with the corresponding size of the balls. The ouput d is the estimation of the box-counting dimension of the boundary by fitting a line in the log.(N_ε) vs log.(1/V_ε) curve. However it is recommended to analyze the curve directly for more accuracy.\n\nKeyword arguments\n\nrange_ε = 2:maximum(size(basins))÷20 is the range of sizes of the ball to test (in pixels).\n\nDescription\n\nIt is the implementation of the popular algorithm of the estimation of the box-counting dimension. The algorithm search for a covering the boundary with N_ε boxes of size ε in pixels.\n\n\n\n\n\n","category":"function"},{"location":"basins/#Attractors.basin_entropy","page":"Basins of Attraction","title":"Attractors.basin_entropy","text":"basin_entropy(basins, ε = 20) -> Sb, Sbb\n\nThis algorithm computes the basin entropy Sb of the basins of attraction. First, the input basins is divided regularly into n-dimensional boxes of side ε (along all dimensions). Then Sb is simply the average of the Gibbs entropy computed over these boxes. The function returns the basin entropy Sb as well as the boundary basin entropy Sbb. The later is the average of the entropy only for boxes that contains at least two different basins, that is, for the boxes on the boundary.\n\nThe basin entropy is a measure of the uncertainty on the initial conditions of the basins. It is maximum at the value log(n_att) being n_att the number of attractors. In this case the boundary is intermingled: for a given initial condition we can find another initial condition that lead to another basin arbitriraly close. It provides also a simple criterion for fractality: if the boundary basin entropy Sbb is above log(2) then we have a fractal boundary. It doesn't mean that basins with values below cannot have a fractal boundary, for a more precise test see basins_fractal_test. An important feature of the basin entropy is that it allows comparisons between different basins using the same box size ε.\n\n[Daza2016]: A. Daza, A. Wagemakers, B. Georgeot, D. Guéry-Odelin and M. A. F. Sanjuán, Basin entropy: a new tool to analyze uncertainty in dynamical systems, Sci. Rep., 6, 31416, 2016.\n\n\n\n\n\n","category":"function"},{"location":"basins/#Attractors.basins_fractal_test","page":"Basins of Attraction","title":"Attractors.basins_fractal_test","text":"basins_fractal_test(basins; ε = 20, Ntotal = 1000) -> test_res, Sbb\n\nThis is an automated test to decide if the boundary of the basins has fractal structures. The bottom line is to look at the basins with a magnifier of size ε at random in basins. If what we see in the magnifier looks like a smooth boundary (in average) we decide that the boundary is smooth. If it is not smooth we can say that at the scale ε we have structures, i.e., it is fractal.\n\nIn practice the algorithm computes the boundary basin entropy Sbb basin_entropy for Ntotal random balls of radius ε. If the computed value is equal to theoretical value of a smooth boundary (taking into account statistical errors and biases) then we decide that we have a smooth boundary. Notice that the response test_res may depend on the chosen ball radius ε. For larger size, we may observe structures for smooth boundary and we obtain a different answer.\n\nThe output test_res is a symbol describing the nature of the basin and the output Sbb is the estimated value of the boundary basin entropy with the sampling method.\n\n[Puy2021] Andreu Puy, Alvar Daza, Alexandre Wagemakers, Miguel A. F. Sanjuán. A test for fractal boundaries based on the basin entropy. Commun Nonlinear Sci Numer Simulat, 95, 105588, 2021.\n\nKeyword arguments\n\nε = 20: size of the ball for the test of basin. The result of the test may change with the size.\nNtotal = 1000: number of balls to test in the boundary for the computation of Sbb\n\n\n\n\n\n","category":"function"},{"location":"basins/#Attractors.uncertainty_exponent","page":"Basins of Attraction","title":"Attractors.uncertainty_exponent","text":"uncertainty_exponent(basins; kwargs...) -> ε, N_ε ,α\n\nEstimate the uncertainty exponent[Grebogi1983] of the basins of attraction. This exponent is related to the final state sensitivity of the trajectories in the phase space. An exponent close to 1 means basins with smooth boundaries whereas an exponent close to 0 represent completely fractalized basins, also called riddled basins.\n\nThe output N_ε is a vector with the number of the balls of radius ε (in pixels) that contain at least two initial conditions that lead to different attractors. The ouput α is the estimation of the uncertainty exponent using the box-counting dimension of the boundary by fitting a line in the log.(N_ε) vs log.(1/ε) curve. However it is recommended to analyze the curve directly for more accuracy.\n\nKeyword arguments\n\nrange_ε = 2:maximum(size(basins))÷20 is the range of sizes of the ball to test (in pixels).\n\nDescription\n\nA phase space with a fractal boundary may cause a uncertainty on the final state of the dynamical system for a given initial condition. A measure of this final state sensitivity is the uncertainty exponent. The algorithm probes the basin of attraction with balls of size ε at random. If there are a least two initial conditions that lead to different attractors, a ball is tagged \"uncertain\". f_ε is the fraction of \"uncertain balls\" to the total number of tries in the basin. In analogy to the fractal dimension, there is a scaling law between, f_ε ~ ε^α. The number that characterizes this scaling is called the uncertainty exponent α.\n\nNotice that the uncertainty exponent and the box counting dimension of the boundary are related. We have Δ₀ = D - α where Δ₀ is the box counting dimension computed with basins_fractal_dimension and D is the dimension of the phase space. The algorithm first estimates the box counting dimension of the boundary and returns the uncertainty exponent.\n\n[Grebogi1983]: C. Grebogi, S. W. McDonald, E. Ott and J. A. Yorke, Final state sensitivity:\n\nAn obstruction to predictability, Physics Letters A, 99, 9, 1983\n\n\n\n\n\n","category":"function"},{"location":"basins/#Tipping-points","page":"Basins of Attraction","title":"Tipping points","text":"","category":"section"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"This page discusses functionality related with tipping points in dynamical systems with known rule. If instead you are interested in identifying tipping points in measured timeseries, have a look at TransitionIndicators.jl.","category":"page"},{"location":"basins/","page":"Basins of Attraction","title":"Basins of Attraction","text":"tipping_probabilities","category":"page"},{"location":"basins/#Attractors.tipping_probabilities","page":"Basins of Attraction","title":"Attractors.tipping_probabilities","text":"tipping_probabilities(basins_before, basins_after) → P\n\nReturn the tipping probabilities of the computed basins before and after a change in the system parameters (or time forcing), according to the definition of[Kaszás2019].\n\nThe input basins are integer-valued arrays, where the integers enumerate the attractor, e.g. the output of basins_of_attraction.\n\nDescription\n\nLet mathcalB_i(p) denote the basin of attraction of attractor A_i at parameter(s) p. Kaszás et al[Kaszás2019] define the tipping probability from A_i to A_j, given a parameter change in the system of p_- to p_+, as\n\nP(A_i to A_j  p_- to p_+) =\nfracmathcalB_j(p_+) cap mathcalB_i(p_-)mathcalB_i(p_-)\n\nwhere cdot is simply the volume of the enclosed set. The value of P(A_i to A_j  p_- to p_+) is P[i, j]. The equation describes something quite simple: what is the overlap of the basin of attraction of A_i at p_- with that of the attractor A_j at p_+. If basins_before, basins_after contain values of -1, corresponding to trajectories that diverge, this is considered as the last attractor of the system in P.\n\n[Kaszás2019]: Kaszás, Feudel & Tél. Tipping phenomena in typical dynamical systems subjected to parameter drift. Scientific Reports, 9(1)\n\n\n\n\n\n","category":"function"},{"location":"continuation/#Attractor-and-Basins-Continuation","page":"Attractor & Basins Continuation","title":"Attractor & Basins Continuation","text":"","category":"section"},{"location":"continuation/#Basins-continuation-API","page":"Attractor & Basins Continuation","title":"Basins continuation API","text":"","category":"section"},{"location":"continuation/","page":"Attractor & Basins Continuation","title":"Attractor & Basins Continuation","text":"continuation","category":"page"},{"location":"continuation/#Attractors.continuation","page":"Attractor & Basins Continuation","title":"Attractors.continuation","text":"continuation(abc::AttractorsBasinsContinuation, prange, pidx, ics; kwargs...)\n\nFind and continue attractors and the fractions of their basins of attraction across a parameter range.\n\nThe continuation type abc is a subtype of AttractorsBasinsContinuation and contains an AttractorMapper. The mapper contains information on how to find the attractors and basins of a dynamical system. Additional arguments and keyword arguments given when creating abc further tune the continuation.\n\nIn the continuation function, the basin fractions and the attractors (or some representation of them in the case of featurizing) are continued across the parameter range prange, for the parameter of the system with index pidx. ics is as in basins_fractions, i.e., it is either a function generating initial conditions or a set containing them.\n\nReturn\n\nfractions_curves :: Vector{Dict{Int, Float64}}. The fractions of basins of attraction. fractions_curves[i] is a dictionary mapping attractor IDs to their basin fraction at the i-th parameter.\nattractors_info <: Vector{Dict{Int, <:Any}}. Information about the attractors. attractors_info[i] is a dictionary mapping attractor ID to information about the attractor at the i-th parameter. The type of information stored depends on the chosen continuation type.\n\nKeyword arguments\n\nshow_progress = true: display a progress bar of the computation.\nsamples_per_parameter = 100: amount of initial conditions sampled at each parameter.\ncont_method = :grouping: selects the method to perform the continuation. :grouping is meant to group the features accross the parameter range while :matching will match the clusters of attractors from one parameter slice to the next.\n\n\n\n\n\n","category":"function"},{"location":"continuation/#Recurrences-continuation-(best)","page":"Attractor & Basins Continuation","title":"Recurrences continuation (best)","text":"","category":"section"},{"location":"continuation/","page":"Attractor & Basins Continuation","title":"Attractor & Basins Continuation","text":"RecurrencesContinuation","category":"page"},{"location":"continuation/#Attractors.RecurrencesContinuation","page":"Attractor & Basins Continuation","title":"Attractors.RecurrencesContinuation","text":"RecurrencesContinuation(mapper::AttractorsViaRecurrences; kwargs...)\n\nA method for continuation. It performs a continuation using a mapper from AttractorsViaRecurrences. The method uses two different continuation method:\n\nAttractors are grouped across a parameor a single parameter slice. The continuation\n\nis performed by matching the labelled attractors from one parameter slice to the next using the special distance method. The threshold\n\nThe attractors are grouped over the full parameter range. Said differently, all\n\nattractors of all initial conditions across all parameter values are put into the same \"pool\" and then grouped using the DBSCAN algorithm. After the grouping is finished the feature label fractions are distributedi to each parameter value they came from. The optimal radius parameter for the DBSCAN algorithm is set though the threshold keyword argument.\n\nIt uses seeding of previous attractors to find new ones, which is the main performance bottleneck. The method uses match_attractor_ids! to match attractors as the system parameter is increased.\n\nKeyword Arguments\n\nmethod, threshold: Given to match_attractor_ids! which is the function used to match attractors between each parameter slice.\ninfo_extraction = identity: A function that takes as an input an attractor (Dataset) and outputs whatever information should be stored. It is used to return the attractors_info in continuation.\nseeds_from_attractor: A function that takes as an input an attractor and returns an iterator of initial conditions to be seeded from the attractor for the next parameter slice. By default, we sample some points from existing attractors according to how many points the attractors themselves contain. A maximum of 10 seeds is done per attractor.\n\n\n\n\n\n","category":"type"},{"location":"continuation/#Matching-attractors","page":"Attractor & Basins Continuation","title":"Matching attractors","text":"","category":"section"},{"location":"continuation/","page":"Attractor & Basins Continuation","title":"Attractor & Basins Continuation","text":"match_attractor_ids!\nreplacement_map\ndataset_distance\nsetsofsets_distance\nmatch_basins_ids!","category":"page"},{"location":"continuation/#Attractors.match_attractor_ids!","page":"Attractor & Basins Continuation","title":"Attractors.match_attractor_ids!","text":"match_attractor_ids!(a₊::AbstractDict, a₋; method = Centroid(), threshold = Inf)\n\nGiven dictionaries a₊, a₋ mapping IDs to attractors (Dataset instances), match attractor IDs in dictionary a₊ so that its attractors that are the closest to those in dictionary a₋ get assigned the same key as in a₋. Typically the +,- mean after and before some change of parameter of a system.\n\nReturn the replacement map, a dictionary mapping old keys of a₊ to the new ones that they were mapped to. You can obtain this map, without modifying the dictionaries, by directly calling the replacement_map function directly.\n\nDescription\n\nWhen finding attractors and their fractions in DynamicalSystems.jl, different attractors get assigned different IDs. However which attractor gets which ID is somewhat arbitrary. Finding the attractors of the same system for slightly different parameters could label \"similar\" attractors (at the different parameters) with different IDs. match_attractors_ids! tries to \"match\" them by modifying the attractor IDs, i.e., the keys of the given dictionaries.\n\nThe matching happens according to the output of the setsofsets_distance function with the keyword method. method` can be whatever that function accepts. Attractors are then match according to distance, with unique mapping. The closest attractors (before and after) are mapped to each other, and are removed from the matching pool, and then the next pair with least remaining distance is matched, and so on.\n\nAdditionally, you can provide a threshold value. If the distance between two attractors is larger than this threshold, then it is guaranteed that the attractors will get assigned different key in the dictionary a₊.\n\n\n\n\n\n","category":"function"},{"location":"continuation/#Attractors.replacement_map","page":"Attractor & Basins Continuation","title":"Attractors.replacement_map","text":"replacement_map(a₊, a₋; method = Centroid(), threshold = Inf) → rmap\n\nReturn a dictionary mapping keys in a₊ to new keys in a₋, as explained in match_attractor_ids!.\n\n\n\n\n\n","category":"function"},{"location":"continuation/#StateSpaceSets.setsofsets_distance","page":"Attractor & Basins Continuation","title":"StateSpaceSets.setsofsets_distance","text":"setsofsets_distance(a₊, a₋ [, method]) → distances\n\nCalculate distances between sets of StateSpaceSets. Here  a₊, a₋ are containers of StateSpaceSets, and the returned distances are dictionaries of of distances. Specifically, distances[i][j] is the distance of the set in the i key of a₊ to the j key of a₋. Notice that distances from a₋ to a₊ are not computed at all (assumming symmetry in the distance function).\n\nThe method can be as in set_distance. However, method can also be any arbitrary user function that takes as input two datasets and returns any positive-definite number as their \"distance\".\n\n\n\n\n\n","category":"function"},{"location":"continuation/#Attractors.match_basins_ids!","page":"Attractor & Basins Continuation","title":"Attractors.match_basins_ids!","text":"match_basins_ids!(b₊::AbstractArray, b₋; threshold = Inf)\n\nSimilar to match_attractor_ids! but operate on basin arrays instead (the arrays typically returned by basins_of_attraction).\n\nThis method matches IDs of attractors whose basins of attraction before and after b₋,b₊ have the most overlap (in pixels). This overlap is normalized in 0-1 (with 1 meaning 100% overlap of pixels). The threshold in this case is compared to the inverse of the overlap (so, for threshold = 2 attractors that have less than 50% overlap get different IDs guaranteed).\n\n\n\n\n\n","category":"function"},{"location":"continuation/#Aggregating-attractors-and-fractions","page":"Attractor & Basins Continuation","title":"Aggregating attractors and fractions","text":"","category":"section"},{"location":"continuation/","page":"Attractor & Basins Continuation","title":"Attractor & Basins Continuation","text":"aggregate_attractor_fractions","category":"page"},{"location":"continuation/#Attractors.aggregate_attractor_fractions","page":"Attractor & Basins Continuation","title":"Attractors.aggregate_attractor_fractions","text":"aggregate_attractor_fractions(\n    fractions_curves, attractors_info, featurizer, group_config [, info_extraction]\n)\n\nAggregate the already-estimated curves of fractions of basins of attraction of similar attractors using the same pipeline used by GroupingConfig. The most typical application of this function is to transform the output of RecurrencesContinuation so that similar attractors, even across parameter space, are grouped into one \"attractor\". Thus, the fractions of their basins are aggregated.\n\nYou could also use this function to aggregate attractors and their fractions even in a single parameter configuration, i.e., using the output of basins_fractions.\n\nThis function is useful in cases where you want the accuracy and performance of AttractorsViaRecurrences, but you also want the convenience of \"grouping\" similar attractrors like in AttractorsViaFeaturizing for presentation or analysis purposes. For example, a high dimesional model of competition dynamics across multispecies may have extreme multistability. After finding this multistability However, one may care about aggregating all attractors into two groups: where a given species is extinct or not. This is the example highlighted in our documentation, in Extinction of a species in a multistable competition model.\n\nInput\n\nfractions_curves: a vector of dictionaries mapping labels to basin fractions.\nattractors_info: a vector of dictionaries mapping labels to attractors. 1st and 2nd argument are exactly like the return values of continuation with RecurrencesContinuation (or, they can be the return of basins_fractions).\nfeaturizer: a 1-argument function to map an attractor into a feature SVector. Notice that you can use identity if the input \"attractors\" aren't actually attractors but already features or something else that can be grouped directly.\ngroup_config: a subtype of GroupingConfig.\ninfo_extraction: a function accepting a vector of features and returning a description of the features. I.e., exactly as in FeaturizingContinuation. The 5th argument is optional and defaults to the centroid of the features.\n\nReturn\n\naggregated_fractions: same as fractions_curves but now contains the fractions of the aggregated attractors.\naggregated_info: dictionary mapping the new labels of aggregated_fractions to the extracted information using info_extraction.\n\n\n\n\n\n","category":"function"},{"location":"continuation/#Grouping-continuation","page":"Attractor & Basins Continuation","title":"Grouping continuation","text":"","category":"section"},{"location":"continuation/","page":"Attractor & Basins Continuation","title":"Attractor & Basins Continuation","text":"FeaturizingContinuation","category":"page"},{"location":"continuation/#Attractors.FeaturizingContinuation","page":"Attractor & Basins Continuation","title":"Attractors.FeaturizingContinuation","text":"FeaturizingContinuation(mapper::AttractorsViaFeaturizing; kwargs...)\n\nA method for continuation. It uses the featurizing approach discussed in AttractorsViaFeaturizing and hence requires an instance of that mapper as an input. When used in continuation, features are extracted in order to aproximate a continuation of the attractors accross the parameter space.\n\nDifferent methods of continuation are implemented namely:\n\nFeatures are grouped across a parameter range. Said differently, all features\n\nof all initial conditions across all parameter values are put into the same \"pool\" and then grouped as dictated by the group_config of the mapper. After the grouping is finished the feature label fractions are distributed to each parameter value they came from.\n\nThe features are grouped and labeled for a single parameter slice. The continuation\n\nis performed by matching the labelled features from one parameter slice to the next using the special distance method.\n\nThe labelled features are grouped using an histogram binning. TODO\n\nKeyword arguments\n\ninfo_extraction::Function a function that takes as an input a vector of features (corresponding to a cluster) and returns a description of the cluster. By default, the centroid of the cluster is used.\npar_weight = 0: See below the section on MCBB.\nmethod = Centroid(): the default distance to compute the distance between two groups\n\nof features. TODO: With what function? What is used to compute the distance?\n\nthreshold = Inf: this is the threshold set to match the clusters of features between them.\n\nWhen set to Inf the smallest distance is selected between them.\n\nTODO: this defualt choice of threhsold is really bad. You must use a different\n\ntype. Here Inf makes perfect sense to be used as an actual value, so why forbit it...?\n\nMCBB special version\n\nIf the chosen grouping method is GroupViaClustering, the additional keyword par_weight::Real can be used. If it is ≠ 0, the distance matrix between features obtains an extra weight that is proportional to the distance par_weight*|p[i] - p[j]| between the parameters used when extracting features. The range of parameters is normalized to 0-1 such that the largest distance in the parameter space is 1. The normalization is done because the feature space is also (by default) normalized to 0-1.\n\nThis version of the algorithm is the original \"MCBB\" continuation method described in [Gelbrecht2020], besides the improvements of clustering accuracy and performance done by the developer team of Attractors.jl.\n\n[Gelbrecht2021]: Maximilian Gelbrecht et al 2021, Monte Carlo basin bifurcation analysis, New J. Phys.22 03303\n\n\n\n\n\n","category":"type"},{"location":"examples/#Examples-for-Attractors.jl","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"","category":"section"},{"location":"examples/#Newton's-fractal-(basins-of-2D-map)","page":"Examples for Attractors.jl","title":"Newton's fractal (basins of 2D map)","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using Attractors\nfunction newton_map(z, p, n)\n    z1 = z[1] + im*z[2]\n    dz1 = newton_f(z1, p[1])/newton_df(z1, p[1])\n    z1 = z1 - dz1\n    return SVector(real(z1), imag(z1))\nend\nnewton_f(x, p) = x^p - 1\nnewton_df(x, p)= p*x^(p-1)\n\nds = DiscreteDynamicalSystem(newton_map, [0.1, 0.2], [3.0])\nxg = yg = range(-1.5, 1.5; length = 400)\n# Use non-sparse for using `basins_of_attraction`\nmapper = AttractorsViaRecurrences(ds, (xg, yg); sparse = false)\nbasins, attractors = basins_of_attraction(mapper; show_progress = false)\nbasins","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"attractors","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Now let's plot this as a heatmap","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using CairoMakie\n# Set up some code for plotting attractors\nfunction scatter_attractors!(ax, attractors)\n    for k ∈ keys(attractors)\n        x, y = columns(attractors[k])\n        scatter!(ax, vec(attractors[k]);\n            color = Cycled(k),\n            strokewidth = 3, strokecolor = :white\n        )\n    end\nend\n\ngenerate_cmap(n) = cgrad(Main.COLORS[1:n], n; categorical = true)\nids = sort!(unique(basins))\ncmap = generate_cmap(length(ids))\n\nfig, ax = heatmap(xg, yg, basins;\n    colormap = cmap, colorrange = (ids[1] - 0.5, ids[end]+0.5),\n)\nscatter_attractors!(ax, attractors)\nfig","category":"page"},{"location":"examples/#Fractality-of-2D-basins-of-the-(4D)-magnetic-pendulum","page":"Examples for Attractors.jl","title":"Fractality of 2D basins of the (4D) magnetic pendulum","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"In this section we will calculate the basins of attraction of the four-dimensional magnetic pendulum. We know that the attractors of this system are all individual fixed points on the (x, y) plane so we will only compute the basins there. We can also use this opportunity to highlight a different method, the AttractorsViaProximity which works when we already know where the attractors are. Furthermore we will also use a projected_integrator to project the 4D system onto a 2D plane, saving a lot of computational time!","category":"page"},{"location":"examples/#Computing-the-basins","page":"Examples for Attractors.jl","title":"Computing the basins","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"ds = Systems.magnetic_pendulum(d=0.2, α=0.2, ω=0.8, N=3)\npsys = ProjectedDynamicalSystem(ds, [1, 2], [0.0, 0.0])","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"For this systems we know the attractors are close to the magnet positions, so we can just do","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"attractors = Dict(i => Dataset([dynamic_rule(ds).magnets[i]]) for i in 1:3)\nmapper = AttractorsViaProximity(psys, attractors)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"and as before, get the basins of attraction","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"xg = yg = range(-4, 4; length=150)\ngrid = (xg, yg)\nbasins, = basins_of_attraction(mapper, grid; show_progress = false)\nids = sort!(unique(basins))\ncmap = generate_cmap(length(ids))\nfig, ax = heatmap(xg, yg, basins;\n    colormap = cmap, colorrange = (ids[1] - 0.5, ids[end]+0.5),\n)\nscatter_attractors!(ax, attractors)\nfig","category":"page"},{"location":"examples/#Computing-the-uncertainty-exponent","page":"Examples for Attractors.jl","title":"Computing the uncertainty exponent","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Let's now calculate the uncertainty_exponent for this system as well. The calculation is straightforward:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"ε, f_ε, α = uncertainty_exponent(basins)\nfig, ax = lines(log.(ε), log.(f_ε))\nax.title = \"α = $(round(α; digits=3))\"\nfig","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"The actual uncertainty exponent is the slope of the curve (α) and indeed we get an exponent near 0 as we know a-priory the basins have fractal boundaries for the magnetic pendulum.","category":"page"},{"location":"examples/#Computing-the-tipping-probabilities","page":"Examples for Attractors.jl","title":"Computing the tipping probabilities","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"We will compute the tipping probabilities using the magnetic pendulum's example as the \"before\" state. For the \"after\" state we will change the γ parameter of the third magnet to be so small, its basin of attraction will virtually disappear. As we don't know when the basin of the third magnet will disappear, we switch the attractor finding algorithm back to AttractorsViaRecurrences.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"ds = Systems.magnetic_pendulum(d=0.2, α=0.2, ω=0.8, N=3, γs = [1.0, 1.0, 0.1])\npsys = projected_integrator(ds, [1, 2], [0.0, 0.0]; diffeq = (reltol = 1e-9,))\nmapper = AttractorsViaRecurrences(psys, (xg, yg); Δt = 1)\nbasins_after, attractors_after = basins_of_attraction(\n    mapper, (xg, yg); show_progress = false\n)\n# matching attractors is important!\nmatch_attractor_ids!(attractors_after, attractors)\n\n# now plot\nids = sort!(unique(basins_after))\ncmap = generate_cmap(length(ids))\nfig, ax = heatmap(xg, yg, basins_after;\n    colormap = cmap, colorrange = (ids[1] - 0.5, ids[end]+0.5),\n)\nscatter_attractors!(ax, attractors_after)\nfig","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"P = tipping_probabilities(basins, basins_after)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"As you can see P has size 3×2, as after the change only 2 attractors have been identified in the system (3 still exist but our state space discretization isn't accurate enough to find the 3rd because it has such a small basin). Also, the first row of P is 50% probability to each other magnet, as it should be due to the system's symmetry.","category":"page"},{"location":"examples/#Basin-fractions-continuation-in-the-magnetic-pendulum","page":"Examples for Attractors.jl","title":"Basin fractions continuation in the magnetic pendulum","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Perhaps the simplest application of continuation is to produce a plot of how the fractions of attractors change as we continuously change the parameter we changed above to calculate tipping probabilities.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"TODO: Write it.","category":"page"},{"location":"examples/#D-basins-via-recurrences","page":"Examples for Attractors.jl","title":"3D basins via recurrences","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"To showcase the true power of AttractorsViaRecurrences we need to use a system whose attractors span higher-dimensional space. An example is","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"ds = Systems.thomas_cyclical(b = 0.1665)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"which, for this parameter, contains 5 coexisting attractors. 3 of them are entangled periodic orbits that span across all three dimensions, and the remaining 2 are fixed points.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"To compute the basins we define a three-dimensional grid and call on it basins_of_attraction.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"# This computation takes about an hour\nxg = yg = zg = range(-6.0, 6.0; length = 251)\nmapper = AttractorsViaRecurrences(ds, (xg, yg, zg))\nbasins, attractors = basins_of_attraction(mapper)\nattractors","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Dict{Int16, Dataset{3, Float64}} with 5 entries:\n  5 => 3-dimensional Dataset{Float64} with 1 points\n  4 => 3-dimensional Dataset{Float64} with 379 points\n  6 => 3-dimensional Dataset{Float64} with 1 points\n  2 => 3-dimensional Dataset{Float64} with 538 points\n  3 => 3-dimensional Dataset{Float64} with 537 points\n  1 => 3-dimensional Dataset{Float64} with 1 points","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"The basins of attraction are very complicated. We can try to visualize them by animating the 2D slices at each z value, to obtain:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"<video width=\"75%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/attractors/cyclical_basins.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Then, we visualize the attractors to obtain:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"<video width=\"75%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/attractors/cyclical_attractors.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"In the animation above, the scattered points are the attractor values the function AttractorsViaRecurrences found by itself. Of course, for the periodic orbits these points are incomplete. Once the function's logic understood we are on an attractor, it stops computing. However, we also simulated lines, by evolving initial conditions colored appropriately with the basins output.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"The animation was produced with the code:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using GLMakie\nfig = Figure()\ndisplay(fig)\nax = fig[1,1] = Axis3(fig; title = \"found attractors\")\ncmap = cgrad(:dense, 6; categorical = true)\n\nfor i in keys(attractors)\n    tr = attractors[i]\n    markersize = length(attractors[i]) > 10 ? 2000 : 6000\n    marker = length(attractors[i]) > 10 ? :circle : :rect\n    scatter!(ax, columns(tr)...; markersize, marker, transparency = true, color = cmap[i])\n    j = findfirst(isequal(i), bsn)\n    x = xg[j[1]]\n    y = yg[j[2]]\n    z = zg[j[3]]\n    tr = trajectory(ds, 100, SVector(x,y,z); Ttr = 100)\n    lines!(ax, columns(tr)...; linewidth = 1.0, color = cmap[i])\nend\n\na = range(0, 2π; length = 200) .+ π/4\n\nrecord(fig, \"cyclical_attractors.mp4\", 1:length(a)) do i\n    ax.azimuth = a[i]\nend","category":"page"},{"location":"examples/#Extinction-of-a-species-in-a-multistable-competition-model","page":"Examples for Attractors.jl","title":"Extinction of a species in a multistable competition model","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"In this advanced example we utilize both RecurrencesSeededContinuation and aggregate_attractor_fractions in analyzing species extinction in a dynamical model of competition between multiple species. The final goal is to show the percentage of how much of the state space leads to the extinction or not of a pre-determined species, as we vary a parameter. The model however displays extreme multistability, a feature we want to measure and preserve before aggregating information into \"extinct or not\".","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"To measure and preserve this we will apply RecurrencesSeededContinuation as-is first. Then we can aggregate information. First we have","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"using Attractors, OrdinaryDiffEq\nusing Random: Xoshiro\n# arguments to algorithms\nsamples_per_parameter = 1000\ntotal_parameter_values = 101\ndiffeq = (alg = Vern9(), reltol = 1e-9, abstol = 1e-9, maxiters = Inf)\nrecurrences_kwargs = (; Δt= 1.0, mx_chk_fnd_att=9, diffeq);\n# initialize dynamical systerm and sampler\nds = Systems.multispecies_competition() # 8-dimensional by default\nxg = range(0, 60; length = 300)\ngrid = ntuple(x -> xg, 8)\nprange = range(0.2, 0.3; length = total_parameter_values)\npidx = :D\nsampler, = statespace_sampler(Xoshiro(1234);\n    min_bounds = minimum.(grid), max_bounds = maximum.(grid)\n)\n# initialize mapper\nmapper = AttractorsViaRecurrences(ds, grid; recurrences_kwargs...)\n# perform continuation of attractors and their basins\n# NOTE: in a realistic applicaiton the threshold should not be infinite,\n# but some sensible distance in state space units\ncontinuation = RecurrencesContinuation(mapper; threshold = Inf)\nfractions_curves, attractors_info = continuation(\n    continuation, prange, pidx, sampler;\n    show_progress = true, samples_per_parameter\n);\nMain.basins_fractions_plot(fractions_curves, prange; separatorwidth = 1)","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"this  example is not actually run when building the docs, because it takes about 30 minutes to complete depending on the computer; we load precomputed results instead","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"As you can see, the system has extreme multistability with 64 unique attractors (according to the default matching behavior in RecurrencesSeededContinuation; a stricter matching with less than Inf threshold would generate more \"distinct\" attractors). One could also isolate a specific parameter slice, and to the same as what we do in the Fractality of 2D basins of the (4D) magnetic pendulum example, to prove that the basin boundaries are fractal, thereby indeed confirming the paper title \"Fundamental Unpredictability\".","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Regardless, we now want to continue our analysis to provide a figure similar to the above but only with two colors: fractions of attractors where a species is extinct or not. Here's how:","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"species = 3 # species we care about its existence\n\nfeaturizer = (A) -> begin\n    i = isextinct(A, species)\n    return SVector(Int32(i))\nend\nisextinct(A, idx = unitidxs) = all(a -> a <= 1e-2, A[:, idx])\n\n# `minneighbors = 1` is crucial for grouping single attractors\ngroupingconfig = GroupViaClustering(; min_neighbors=1, optimal_radius_method=0.5)\n\naggregated_fractions, aggregated_info = aggregate_attractor_fractions(\n    fractions_curves, attractors_info, featurizer, groupingconfig\n)\n\nbasins_fractions_plot(aggregated_fractions, prange; separatorwidth = 1,\nlabels = Dict(1 => \"extinct\", 2 => \"alive\"), colors = [\"green\", \"black\"])","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"(in hindsight, the labels are reversed; attractor 1 is the alive one)","category":"page"},{"location":"examples/#Featurizing-and-grouping-across-parameters-(MCBB)","page":"Examples for Attractors.jl","title":"Featurizing and grouping across parameters (MCBB)","text":"","category":"section"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"Here we showcase the example of the Monte Carlo Basin Bifurcation publication using a network of 2nd order Kuramoto oscillators (as done in the paper by Gelbrecht et al.) For this, we will use GroupAcrossParametersContinuation while also providing a par_weight keyword.","category":"page"},{"location":"examples/","page":"Examples for Attractors.jl","title":"Examples for Attractors.jl","text":"TODO: Write the example.","category":"page"},{"location":"attractors/#Finding-Attractors","page":"Finding Attractors","title":"Finding Attractors","text":"","category":"section"},{"location":"attractors/","page":"Finding Attractors","title":"Finding Attractors","text":"Attractors.jl defines a generic interface for finding attractors of dynamical systems. One first decides the instance of GeneralizedDynamicalSystem they need. Then, an instance of AttractorMapper is created from this dynamical system. This mapper instance can be used to compute e.g., basins_of_attraction, and the output can be further analyzed to get e.g., the basin_entropy.","category":"page"},{"location":"attractors/","page":"Finding Attractors","title":"Finding Attractors","text":"AttractorMapper","category":"page"},{"location":"attractors/#Attractors.AttractorMapper","page":"Finding Attractors","title":"Attractors.AttractorMapper","text":"AttractorMapper(ds::DynamicalSystem, args...; kwargs...) → mapper\n\nSubtypes of AttractorMapper are structures that map initial conditions of ds to attractors. The type of ds cannot be ParallelDynamicalSystem or TangentDynamicalSystem (because it doesn't make sense).\n\nCurrently available mapping methods:\n\nAttractorsViaProximity\nAttractorsViaRecurrences\nAttractorsViaFeaturizing\n\nAll AttractorMapper subtypes can be used with basins_fractions or basins_of_attraction.\n\nIn addition, some mappers can be called as a function of an initial condition:\n\nlabel = mapper(u0)\n\nand this will on the fly compute and return the label of the attractor u0 converges at. The mappers that can do this are:\n\nAttractorsViaProximity\nAttractorsViaRecurrences\nAttractorsViaFeaturizing with the GroupViaHistogram configuration.\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Recurrences","page":"Finding Attractors","title":"Recurrences","text":"","category":"section"},{"location":"attractors/","page":"Finding Attractors","title":"Finding Attractors","text":"AttractorsViaRecurrences\nautomatic_Δt_basins","category":"page"},{"location":"attractors/#Attractors.AttractorsViaRecurrences","page":"Finding Attractors","title":"Attractors.AttractorsViaRecurrences","text":"AttractorsViaRecurrences(ds::DynamicalSystem, grid::Tuple; kwargs...)\n\nMap initial conditions of ds to attractors by identifying attractors on the fly based on recurrences in the state space, as outlined by Datseris & Wagemakers[Datseris2022].\n\ngrid is a tuple of ranges partitioning the state space so that a finite state machine can operate on top of it. For example grid = (xg, yg) where xg = yg = range(-5, 5; length = 100) for a two-dimensional system. The grid has to be the same dimensionality as the state space, use a ProjectedDynamicalSystem if you want to search for attractors in a lower dimensional subspace.\n\nKeyword arguments\n\nsparse = true: control the interval representation of the state space grid. If true,  uses a sparse array, whose memory usage is in general more efficient than a regular  array obtained with sparse=false. In practice, the sparse representation should  always be preferred when searching for basins_fractions. Only for very low  dimensional systems and for computing the full basins_of_attraction the  non-sparse version should be used.\n\nTime evolution configuration\n\nTtr = 0: Skip a transient before the recurrence routine begins.\nΔt: Approximate integration time step (second argument of the step! function). It is 1 for discrete time systems. For continuous systems, an automatic value is calculated using automatic_Δt_basins. For very fine grids, this can become very small, much smaller than the typical integrator internal step size in case of adaptive integrators. In such cases, it is much better to use non-adaptive ODE solvers with a small step size, e.g., diffeq = (alg = Tsit5(), adaptive = false, dt = 0.001) (and also give Δt = dt in this case for best performance)\n\nFinite state machine configuration\n\nmx_chk_att = 2: Μaximum checks of consecutives hits of an existing attractor cell before declaring convergence to that existing attractor.\nmx_chk_hit_bas = 10: Maximum check of consecutive visits of the same basin of attraction before declaring convergence to an existing attractor.\nmx_chk_fnd_att = 100: Maximum check of consecutive visits to a previously visited unlabeled cell before declaring we have found a new attractor.\nmx_chk_loc_att = 100: Maximum check of consecutive visits to cells marked as a new attractor, during the attractor identification phase, before declaring we that we have identified the new attractor with sufficient cells.\nstore_once_per_cell = true: Control if multiple points in state space that belong to the same cell are stored or not in the attractor, after an attractor is found. If true, each visited cell will only store a point once, which is desirable for fixed points and limit cycles. If false, at least mx_chk_loc_att points are stored per attractor, leading to more densely stored attractors, which may be desirable for instance in chaotic attractors.\nmx_chk_lost = 20: Maximum check of iterations outside the defined grid before we declare the orbit lost outside and hence assign it label -1.\nhorizon_limit = 1e6: If the norm of the integrator state reaches this limit we declare that the orbit diverged to infinity.\nmx_chk_safety = Int(1e6): A safety counter that is always increasing for each initial condition. Once exceeded, the algorithm assigns -1 and throws a warning. This clause exists to stop the algorithm never haulting for innappropriate grids, where a found attractor may intersect in the same cell with a new attractor the orbit traces (which leads to infinite resetting of all counters).\n\nDescription\n\nAn initial condition given to an instance of AttractorsViaRecurrences is iterated based on the integrator corresponding to ds. A recurrence in the state space means that the trajectory has converged to an attractor. This is the basis for finding attractors.\n\nA finite state machine (FSM) follows the trajectory in the state space, and constantly maps it to the given grid. The FSM decides when an initial condition has successfully converged into an attractor. An array, internally called \"basins\", stores the state of the FSM on the grid, according to the indexing system described in [Datseris2022]. As the system is integrated more and more, the information of the \"basins\" becomes richer and richer with more identified attractors or with grid cells that belong to basins of already found attractors. Notice that only in the special method basins_of_attraction(mapper::AttractorsViaRecurrences) the information of the attraction or exit basins is utilized. In other functions like basins_fractions only the attractor locations are utilized, as the basins themselves are not stored.\n\nThe iteration of a given initial condition continues until one of the following happens:\n\nThe trajectory hits mx_chk_fnd_att times in a row grid cells previously visited:  it is considered that an attractor is found and is labelled with a new ID. Then,  iteration continues a bit more until we have identified the attractor with sufficient  accuracy, i.e., until mx_chk_loc_att cells with the new ID have been visited.\nThe trajectory hits an already identified attractor mx_chk_att consecutive times:  the initial condition is numbered with the attractor's ID.\nThe trajectory hits a known basin mx_chk_hit_bas times in a row: the initial condition  belongs to that basin and is numbered accordingly. Notice that basins are stored and  used only when sparse = false.\nThe trajectory spends mx_chk_lost steps outside the defined grid or the norm  of the integrator state becomes > than horizon_limit: the initial  condition's label is set to -1.\nIf none of the above happens, the initial condition is labelled -1 after  and mx_chk_safety integrator steps.\n\n[Datseris2022]: G. Datseris and A. Wagemakers, Effortless estimation of basins of attraction, Chaos 32, 023104 (2022)\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Attractors.automatic_Δt_basins","page":"Finding Attractors","title":"Attractors.automatic_Δt_basins","text":"automatic_Δt_basins(ds::DynamicalSystem, grid; N = 5000) → Δt\n\nCalculate an optimal Δt value for basins_of_attraction. This is done by evaluating the dynamic rule f (vector field) at N randomly chosen points of the grid. The average f is then compared with the diagonal length of a grid cell and their ratio provides Δt.\n\nNotice that Δt should not be too small which happens typically if the grid resolution is high. It is okay for basins_of_attraction if the trajectory skips a few cells. But if Δt is too small the default values for all other keywords such as mx_chk_hit_bas need to be increased drastically.\n\nAlso, Δt that is smaller than the internal step size of the integrator will cause a performance drop.\n\n\n\n\n\n","category":"function"},{"location":"attractors/#Proximity","page":"Finding Attractors","title":"Proximity","text":"","category":"section"},{"location":"attractors/","page":"Finding Attractors","title":"Finding Attractors","text":"AttractorsViaProximity","category":"page"},{"location":"attractors/#Attractors.AttractorsViaProximity","page":"Finding Attractors","title":"Attractors.AttractorsViaProximity","text":"AttractorsViaProximity(ds::DynamicalSystem, attractors::Dict [, ε]; kwargs...)\n\nMap initial conditions to attractors based on whether the trajectory reaches ε-distance close to any of the user-provided attractors. They have to be in a form of a dictionary mapping attractor labels to Datasets containing the attractors.\n\nThe system gets stepped, and at each step the minimum distance to all attractors is computed. If any of these distances is < ε, then the label of the nearest attractor is returned.\n\nIf an ε::Real is not provided by the user, a value is computed automatically as half of the minimum distance between all attractors. This operation can be expensive for large attractor datasets. If length(attractors) == 1, then ε becomes 1/10 of the diagonal of the box containing the attractor. If length(attractors) == 1 and the attractor is a single point, an error is thrown.\n\nBecause in this method the attractors are already known to the user, the method can also be called supervised.\n\nKeywords\n\nTtr = 100: Transient time to first evolve the system for before checking for proximity.\nΔt = 1: Step time given to step!.\nhorizon_limit = 1e3: If the maximum distance of the trajectory from any of the given attractors exceeds this limit, it is assumed that the trajectory diverged (gets labelled as -1).\nmx_chk_lost = 1000: If the integrator has been stepped this many times without coming ε-near to any attractor,  it is assumed that the trajectory diverged (gets labelled as -1).\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Featurizing","page":"Finding Attractors","title":"Featurizing","text":"","category":"section"},{"location":"attractors/","page":"Finding Attractors","title":"Finding Attractors","text":"AttractorsViaFeaturizing","category":"page"},{"location":"attractors/#Attractors.AttractorsViaFeaturizing","page":"Finding Attractors","title":"Attractors.AttractorsViaFeaturizing","text":"AttractorsViaFeaturizing(\n    ds::DynamicalSystem, featurizer::Function,\n    grouping_config = GroupViaClustering(); kwargs...\n)\n\nInitialize a mapper that maps initial conditions to attractors using a featurizing and grouping approach. This is a supercase of the featurizing and clustering approach that is utilized by bSTAB[Stender2021] and MCBB[Gelbrecht2021]. See AttractorMapper for how to use the mapper. This mapper also allows the syntax mapper(u0) but only if the grouping_config is not GroupViaClustering.\n\nfeaturizer is a function that takes as an input an integrated trajectory A::Dataset and the corresponding time vector t and returns an SVector{<:Real} of features describing the trajectory. It is important to use static vectors for better performance.\n\ngrouping_config is an instance of any subtype of GroupingConfig and decides how features will be grouped into attractors, see below.\n\nSee also the intermediate functions extract_features and group_features, which can be utilized when wanting to work directly with features.\n\nKeyword arguments\n\nT=100, Ttr=100, Δt=1: Propagated to trajectory.\nthreaded = true: Whether to run the generation of features over threads by integrating trajectories in parallel.\n\nDescription\n\nThe trajectory X of an initial condition is transformed into features. Each feature is a number useful in characterizing the attractor the initial condition ends up at, and distinguishing it from other attractors. Example features are the mean or standard deviation of some the dimensions of the trajectory, the entropy of some of the dimensions, the fractal dimension of X, or anything else you may fancy.\n\nAll feature vectors (each initial condition = 1 vector) are then grouped using one of the sevaral available grouping configurations. Each group is assumed to be a unique attractor, and hence each initial condition is labelled according to the group it is part of. The method thus relies on the user having at least some basic idea about what attractors to expect in order to pick the right features, and the right way to group them, in contrast to AttractorsViaRecurrences.\n\n[Stender2021]: Stender & Hoffmann 2021, bSTAB: an open-source software for computing the basin stability of multi-stable dynamical systems\n\n[Gelbrecht2021]: Maximilian Gelbrecht et al 2021, Monte Carlo basin bifurcation analysis, New J. Phys.22 03303\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Grouping-configurations","page":"Finding Attractors","title":"Grouping configurations","text":"","category":"section"},{"location":"attractors/#Grouping-types","page":"Finding Attractors","title":"Grouping types","text":"","category":"section"},{"location":"attractors/","page":"Finding Attractors","title":"Finding Attractors","text":"GroupingConfig\nGroupViaClustering\nGroupViaHistogram\nGroupViaNearestFeature","category":"page"},{"location":"attractors/#Attractors.GroupingConfig","page":"Finding Attractors","title":"Attractors.GroupingConfig","text":"GroupingConfig\n\nSupertype for configuration structs on how to group features together. Used in several occasions such as AttractorsViaFeaturizing or aggregate_attractor_fractions.\n\nCurrently available grouping configurations are:\n\nGroupViaClustering\nGroupViaNearestFeature\nGroupViaHistogram\n\nGroupingConfig defines an extendable interface. The only thing necessary for a new grouping configuration is to:\n\nMake a new type and subtype GroupingConfig.\nIf the grouping allows for mapping individual initial conditions to IDs, then instead extend the internal function feature_to_group(feature, config). This will allow doing id = mapper(u0) with AttractorsViaFeaturizing.\nElse, extend the function group_features(features, config). You could still extend group_features even if (2.) is satisfied, if there are any performance benefits.\nInclude the new grouping file in the grouping/all_grouping_configs.jl and list it in this documentation string.\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Attractors.GroupViaClustering","page":"Finding Attractors","title":"Attractors.GroupViaClustering","text":"GroupViaClustering(; kwargs...)\n\nInitialize a struct that contains instructions on how to group features in AttractorsViaFeaturizing. GroupViaClustering clusters features into groups using DBSCAN, similar to the original work by bSTAB[Stender2021] and MCBB[Gelbrecht2021]. Several options on clustering are available, see keywords below.\n\nThe defaults are a significant improvement over existing literature, see Description.\n\nKeyword arguments\n\nclust_distance_metric = Euclidean(): metric to be used in the clustering.\nrescale_features = true: if true, rescale each dimension of the extracted features separately into the range [0,1]. This typically leads to more accurate clustering.\nmin_neighbors = 10: minimum number of neighbors (i.e. of similar features) each feature needs to have, including counting its own self, in order to be considered in a cluster (fewer than this, it is labeled as an outlier, -1).\nuse_mmap = false: whether to use an on-disk map for creating the distance matrix of the features. Useful when the features are so many where a matrix with side their length would not fit to memory.\n\nKeywords for optimal radius estimation\n\noptimal_radius_method::Union{Real, String} = \"silhouettes_optim\": if a real number, it is the radius used to cluster features. Otherwise, it determines the method used to automatically determine that radius. Possible values are:\n\"silhouettes\": Performs a linear (sequential) search for the radius that maximizes a   statistic of the silhouette values of clusters (typically the mean). This can be chosen   with silhouette_statistic. The linear search may take some time to finish. To   increase speed, the number of radii iterated through can be reduced by decreasing   num_attempts_radius (see its entry below).\n\"silhouettes_optim\": Same as \"silhouettes\" but performs an optimized search via   Optim.jl. It's faster than \"silhouettes\", with typically the same accuracy (the   search here is not guaranteed to always find the global maximum, though it typically   gets close).\n\"knee\": chooses the the radius according to the knee (a.k.a. elbow,   highest-derivative method) and is quicker, though generally leading to much worse   clustering. It requires that min_neighbors > 1.\nnum_attempts_radius = 100: number of radii that the optimal_radius_method will try out in its iterative procedure. Higher values increase the accuracy of clustering, though not necessarily much, while always reducing speed.\nsilhouette_statistic::Function = mean: statistic (e.g. mean or minimum) of the silhouettes that is maximized in the \"optimal\" clustering. The original implementation in [Stender2021] used the minimum of the silhouettes, and typically performs less accurately than the mean.\nmax_used_features = 0: if not 0, it should be an Int denoting the max amount of features to be used when finding the optimal radius. Useful when clustering a very large number of features (e.g., high accuracy estimation of fractions of basins of attraction).\n\nDescription\n\nThe DBSCAN clustering algorithm is used to automatically identify clusters of similar features. Each feature vector is a point in a feature space. Each cluster then basically groups points that are closely packed together. Closely packed means that the points have at least min_neighbors inside a ball of radius optimal_radius centered on them. This method typically works well if the radius is chosen well, which is not necessarily an easy task. Currently, three methods are implemented to automatically estimate an \"optimal\" radius.\n\nEstimating the optimal radius\n\nThe default method is the silhouettes method, which includes keywords silhouette and silhouette_optim. Both of them search for the radius that optimizes the clustering, meaning the one that maximizes a statistic silhouette_statistic (e.g. mean value) of a quantifier for the quality of each cluster. This quantifier is the silhouette value of each identified cluster. A silhouette value measures how similar a point is to the cluster it currently belongs to, compared to the other clusters, and ranges from -1 (worst matching) to +1 (ideal matching). If only one cluster is found, the assigned silhouette is zero. So for each attempted radius in the search the clusters are computed, their silhouettes calculated, and the statistic of these silhouettes computed. The algorithm then finds the radius that leads to the maximum such statistic. For optimal_radius_method = \"silhouettes\", the search is done linearly, from a minimum to a maximum candidate radius for optimal_radius_method = \"silhouettes\"; optimal_radius_method = silhouettes_optim, it is done via an optimized search performed by Optim.jl which is typically faster and with similar accuracy. A third alternative is the\"elbow\" method, which works by calculating the distance of each point to its k-nearest-neighbors (with k=min_neighbors) and finding the distance corresponding to the highest derivative in the curve of the distances, sorted in ascending order. This distance is chosen as the optimal radius. It is described in [Kriegel1996] and [Schubert2017]. It typically performs considerably worse than the \"silhouette\" methods.\n\n[Stender2021]: Stender & Hoffmann 2021, bSTAB: an open-source software for computing the basin stability of multi-stable dynamical systems\n\n[Gelbrecht2021]: Maximilian Gelbrecht et al 2021, Monte Carlo basin bifurcation analysis, 2020 New J. Phys.22 03303\n\n[Kriegel1996]: Ester, Kriegel, Sander and Xu: A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise\n\n[Schubert2017]: Schubert, Sander, Ester, Kriegel and Xu: DBSCAN Revisited, Revisited: Why and How You Should (Still) Use DBSCAN\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Attractors.GroupViaHistogram","page":"Finding Attractors","title":"Attractors.GroupViaHistogram","text":"GroupViaHistogram(binning::FixedRectangularBinning)\n\nInitialize a struct that contains instructions on how to group features in AttractorsViaFeaturizing. GroupViaHistogram performs a histogram in feature space. Then, all features that are in the same histogram bin get the same label. The binning is an instance of FixedRectangularBinning from ComplexityMeasures.jl. (the reason to not allow RectangularBinning is because during continuation we need to ensure that bins remain identical).\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Attractors.GroupViaNearestFeature","page":"Finding Attractors","title":"Attractors.GroupViaNearestFeature","text":"GroupViaNearestFeature(templates; kwargs...)\n\nInitialize a struct that contains instructions on how to group features in AttractorsViaFeaturizing. GroupViaNearestFeature accepts a template, which is a vector of features. Then, generated features from initial conditions in AttractorsViaFeaturizing are labelled according to the feature in templates that is closest (the label is the index of the closest template).\n\ntemplates can be a vector or dictionary mapping keys to templates. Internally all templates are converted to SVector for performance. Hence, it is strongly recommended that both templates and the output of the featurizer function in AttractorsViaFeaturizing return SVector types.\n\nKeyword arguments\n\nmetric = Euclidean(): metric to be used to quantify distances in the feature space.\nmax_distance = Inf: Maximum allowed distance between a feature and its nearest template for it to be assigned to that template. By default, Inf guarantees that a feature is assigned to its nearest template regardless of the distance. Features that exceed max_distance to their nearest template get labelled -1.\n\n\n\n\n\n","category":"type"},{"location":"attractors/#Grouping-utility-functions","page":"Finding Attractors","title":"Grouping utility functions","text":"","category":"section"},{"location":"attractors/","page":"Finding Attractors","title":"Finding Attractors","text":"group_features\nextract_features","category":"page"},{"location":"attractors/#Attractors.group_features","page":"Finding Attractors","title":"Attractors.group_features","text":"group_features(features, group_config::GroupingConfig) → labels\n\nGroup the given vector of feature vectors according to the configuration and return the labels (vector of equal length as features). See AttractorsViaFeaturizing for possible configurations.\n\n\n\n\n\n","category":"function"},{"location":"attractors/#Attractors.extract_features","page":"Finding Attractors","title":"Attractors.extract_features","text":"extract_features(mapper, ics; N = 1000, show_progress = true)\n\nReturn a vector of the features of each initial condition in ics (as in basins_fractions), using the configuration of mapper::AttractorsViaFeaturizing. Keyword N is ignored if ics isa Dataset.\n\n\n\n\n\n","category":"function"},{"location":"#Attractors.jl","page":"Attractors.jl","title":"Attractors.jl","text":"","category":"section"},{"location":"","page":"Attractors.jl","title":"Attractors.jl","text":"Attractors","category":"page"},{"location":"#Attractors","page":"Attractors.jl","title":"Attractors","text":"A module for finding attractors of dynamical systems, their basins and their boundaries, and continuing attractors and their basins across parameters.\n\nPart of DynamicalSystems.jl.\n\n\n\n\n\n","category":"module"},{"location":"","page":"Attractors.jl","title":"Attractors.jl","text":"using CairoMakie, Attractors\ninclude(\"../style.jl\")","category":"page"},{"location":"#map-of-the-package","page":"Attractors.jl","title":"map of the package","text":"","category":"section"},{"location":"","page":"Attractors.jl","title":"Attractors.jl","text":"say about mapping, then about finding fractions/basins, then continuation.","category":"page"}]
}
