<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Attractors.jl Tutorial · Attractors.jl</title><meta name="title" content="Attractors.jl Tutorial · Attractors.jl"/><meta property="og:title" content="Attractors.jl Tutorial · Attractors.jl"/><meta property="twitter:title" content="Attractors.jl Tutorial · Attractors.jl"/><meta name="description" content="Documentation for Attractors.jl."/><meta property="og:description" content="Documentation for Attractors.jl."/><meta property="twitter:description" content="Documentation for Attractors.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Attractors.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Attractors.jl</a></li><li class="is-active"><a class="tocitem" href>Attractors.jl Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Input:-a-DynamicalSystem"><span>Input: a <code>DynamicalSystem</code></span></a></li><li><a class="tocitem" href="#Finding-attractors"><span>Finding attractors</span></a></li><li><a class="tocitem" href="#Different-Attractor-Mapper"><span>Different Attractor Mapper</span></a></li><li><a class="tocitem" href="#global_cont_tutorial"><span>Global continuation</span></a></li><li><a class="tocitem" href="#Different-matching-procedures"><span>Different matching procedures</span></a></li><li><a class="tocitem" href="#Enhancing-the-continuation"><span>Enhancing the continuation</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../examples/">Examples for Attractors.jl</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Attractors.jl Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Attractors.jl Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Attractors.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Attractors.jl/blob/main/docs/src/tutorial.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="tutorial"><a class="docs-heading-anchor" href="#tutorial">Attractors.jl Tutorial</a><a id="tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial" title="Permalink"></a></h1><p><a href="../#Attractors"><code>Attractors</code></a> is a submodule of the <strong>DynamicalSystems.jl</strong> library. This tutorial will walk you through its main functionality. That is, given a <code>DynamicalSystem</code> instance, find all its attractors and their basins of attraction. Then, continue these attractors, and their stability properties, across a parameter value. It also offers various functions that compute nonlocal stability properties for an attractor, any of which can be used in the continuation to quantify stability.</p><p>Besides this main functionality, there are plenty of other stuff, like for example <a href="@ref"><code>edgestate</code></a> or <a href="../api/#Attractors.basins_fractal_dimension"><code>basins_fractal_dimension</code></a>, but we won&#39;t cover anything else in this introductory tutorial. See the <a href="@ref examples">examples</a> page instead.</p><h2 id="Input:-a-DynamicalSystem"><a class="docs-heading-anchor" href="#Input:-a-DynamicalSystem">Input: a <code>DynamicalSystem</code></a><a id="Input:-a-DynamicalSystem-1"></a><a class="docs-heading-anchor-permalink" href="#Input:-a-DynamicalSystem" title="Permalink"></a></h2><p>The key input for most functionality of Attractors.jl is an instance of a <code>DynamicalSystem</code>. If you don&#39;t know how to make a <code>DynamicalSystem</code>, you need to consult the main tutorial of the <a href="https://juliadynamics.github.io/DynamicalSystemsDocs.jl/dynamicalsystems/stable/tutorial/">DynamicalSystems.jl library</a>. For this tutorial we will use a modified Lorenz-like system with equations</p><p class="math-container">\[\begin{align*}
\dot{x} &amp; = y - x \\
\dot{y}  &amp;= -x*z + b*|z| \\
\dot{z}  &amp;= x*y - a \\
\end{align*}\]</p><p>which we define in code as</p><pre><code class="language-julia hljs">using Attractors # part of `DynamicalSystems`, so it re-exports functionality for making them!
using OrdinaryDiffEq # for accessing advanced ODE Solvers

function modified_lorenz_rule(u, p, t)
    x, y, z = u; a, b = p
    dx = y - x
    dy = - x*z + b*abs(z)
    dz = x*y - a
    return SVector(dx, dy, dz)
end

p0 = [5.0, 0.1] # parameters
u0 = [-4.0, 5, 0] # state
diffeq = (alg = Vern9(), abstol = 1e-9, reltol = 1e-9, dt = 0.01) # solver options
ds = CoupledODEs(modified_lorenz_rule, u0, p0; diffeq)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-dimensional CoupledODEs
 deterministic: true
 discrete time: false
 in-place:      false
 dynamic rule:  modified_lorenz_rule
 ODE solver:    Vern9
 ODE kwargs:    (abstol = 1.0e-9, reltol = 1.0e-9, dt = 0.01)
 parameters:    [5.0, 0.1]
 time:          0.0
 state:         [-4.0, 5.0, 0.0]
</code></pre><h2 id="Finding-attractors"><a class="docs-heading-anchor" href="#Finding-attractors">Finding attractors</a><a id="Finding-attractors-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-attractors" title="Permalink"></a></h2><p>There are two major methods for finding attractors in dynamical systems. Explanation of how they work is in their respective docs.</p><ol><li><a href="../api/#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a>.</li><li><a href="../api/#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a>.</li></ol><p>You can consult (<a href="../references/#Datseris2023">Datseris <em>et al.</em>, 2023</a>) for a comparison between the two.</p><p>As far as the user is concerned, both algorithms are part of the same interface, and can be used in the same way. The interface is extendable as well, and works as follows.</p><p>First, we create an instance of such an &quot;attractor finding algorithm&quot;, which we call <code>AttractorMapper</code>. For example, <a href="../api/#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a> requires a tesselated grid of the state space to search for attractors in. It also allows the user to tune some meta parameters, but in our example they are already tuned for the dynamical system at hand. So we initialize</p><pre><code class="language-julia hljs">grid = (
    range(-10.0, 10.0; length = 100), # x
    range(-15.0, 15.0; length = 100), # y
    range(-15.0, 15.0; length = 100), # z
)

mapper = AttractorsViaRecurrences(ds, grid;
    consecutive_recurrences = 1000, attractor_locate_steps = 1000,
    consecutive_lost_steps = 100,
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AttractorsViaRecurrences
 system:      CoupledODEs
 grid:        (-10.0:0.20202020202020202:10.0, -15.0:0.30303030303030304:15.0, -15.0:0.30303030303030304:15.0)
 attractors:  Dict{Int64, StateSpaceSet{3, Float64}}()
</code></pre><p>This <code>mapper</code> can map any initial condition to the corresponding attractor ID, for example</p><pre><code class="language-julia hljs">mapper([-4.0, 5, 0])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><p>while</p><pre><code class="language-julia hljs">mapper([4.0, 2, 0])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2</code></pre><p>the fact that these two different initial conditions got assigned different IDs means that they converged to a different attractor. The attractors are stored in the mapper internally, to obtain them we use the function</p><pre><code class="language-julia hljs">attractors = extract_attractors(mapper)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Int64, StateSpaceSet{3, Float64}} with 2 entries:
  2 =&gt; 3-dimensional StateSpaceSet{Float64} with 208 points
  1 =&gt; 3-dimensional StateSpaceSet{Float64} with 783 points</code></pre><p>In Attractors.jl, all information regarding attractors is always a standard Julia <code>Dict</code>, which maps attractor IDs (positive integers) to the corresponding quantity. Here the quantity are the attractors themselves, represented as <code>StateSpaceSet</code>.</p><p>We can visualize them with the convenience plotting function</p><pre><code class="language-julia hljs">using CairoMakie
plot_attractors(attractors)</code></pre><img src="cdc124f7.png" alt="Example block output"/><p>(this convenience function is a simple loop over scattering the values of the <code>attractors</code> dictionary)</p><p>In our example system we see that for the chosen parameters there are two coexisting attractors: a limit cycle and a chaotic attractor. There may be more attractors though! We&#39;ve only checked two initial conditions, so we could have found at most two attractors! However, it can get tedious to manually iterate over initial conditions, which is why this <code>mapper</code> is typically given to higher level functions for finding attractors and their basins of attraction. The simplest one is <a href="../api/#Attractors.basins_fractions"><code>basins_fractions</code></a>. Using the <code>mapper</code>, it finds &quot;all&quot; attractors of the dynamical system and reports the state space fraction each attractors attracts. The search is probabilistic, so &quot;all&quot; attractors means those that at least one initial condition converged to.</p><p>We can provide explicitly initial conditions to <a href="@ref"><code>basins_fraction</code></a>, however it is typically simpler to provide it with with a state space sampler instead: a function that generates random initial conditions in the region of the state space that we are interested in. Here this region coincides with <code>grid</code>, so we can simply do:</p><pre><code class="language-julia hljs">sampler, = statespace_sampler(grid)

sampler() # random i.c.</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float64}:
  -6.703304745075491
  -1.2923949076236934
 -14.674203317836753</code></pre><pre><code class="language-julia hljs">sampler() # another random i.c.</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float64}:
  -2.231156031123678
  13.314140268496928
 -10.22659701163666</code></pre><p>and finally call</p><pre><code class="language-julia hljs">fs = basins_fractions(mapper, sampler)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Int64, Float64} with 2 entries:
  2 =&gt; 0.342
  1 =&gt; 0.658</code></pre><p>The returned <code>fs</code> is a dictionary mapping each attractor ID to the fraction of the state space the corresponding basin occupies. With this we can confirm that there are (likely) only two attractors and that both attractors are robust as both have sufficiently large basin fractions.</p><p>To obtain the full basins, which is computationally much more expensive, use <a href="../api/#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>.</p><p>You can use alternative algorithms in <a href="../api/#Attractors.basins_fractions"><code>basins_fractions</code></a>, see the documentation of <a href="../api/#Attractors.AttractorMapper"><code>AttractorMapper</code></a> for possible subtypes. <a href="../api/#Attractors.AttractorMapper"><code>AttractorMapper</code></a> defines an extendable interface and can be enriched with other methods in the future!</p><h2 id="Different-Attractor-Mapper"><a class="docs-heading-anchor" href="#Different-Attractor-Mapper">Different Attractor Mapper</a><a id="Different-Attractor-Mapper-1"></a><a class="docs-heading-anchor-permalink" href="#Different-Attractor-Mapper" title="Permalink"></a></h2><p>Attractors.jl utilizes composable interfaces throughout its functionality. In the above example we used one particular method to find attractors, via recurrences in the state space. An alternative is <a href="../api/#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a>.</p><p>For this method, we need to provide a &quot;featurizing&quot; function that given an trajectory (which is likely an attractor), it returns some features that will hopefully distinguish different attractors in a subsequent grouping step. Finding good features is typically a trial-and-error process, but for our system we already have some good features:</p><pre><code class="language-julia hljs">using Statistics: mean

function featurizer(A, t) # t is the time vector associated with trajectory A
    xmin = minimum(A[:, 1])
    ycen = mean(A[:, 2])
    return SVector(xmin, ycen)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">featurizer (generic function with 1 method)</code></pre><p>from which we initialize</p><pre><code class="language-julia hljs">mapper2 = AttractorsViaFeaturizing(ds, featurizer; Δt = 0.1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AttractorsViaFeaturizing
 system:      CoupledODEs
 Ttr:         100.0
 Δt:          0.1
 T:           100.0
 group via:   GroupViaClustering
 featurizer:  featurizer
</code></pre><p><a href="../api/#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a> allows for a third input, which is a &quot;grouping configuration&quot;, that dictates how features will be grouped into attractors, as features are extracted from (randomly) sampled state space trajectories. In this tutorial we leave it at its default value, which is clustering using the DBSCAN algorithm. The keyword arguments are meta parameters which control how long to integrate each initial condition for, and what sampling time, to produce a trajectory <code>A</code> given to the <code>featurizer</code> function. Because one of the two attractors is chaotic, we need denser sampling time than the default.</p><p>We can use <code>mapper2</code> exactly as <code>mapper</code>:</p><pre><code class="language-julia hljs">fs2 = basins_fractions(mapper2, sampler)

attractors2 = extract_attractors(mapper2)

plot_attractors(attractors2)</code></pre><img src="24a59c38.png" alt="Example block output"/><p>This mapper also found the attractors, but we should warn you: this mapper is less robust than <a href="../api/#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a>. One of the reasons for this is that <a href="../api/#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a> is not auto-terminating. For example, if we do not have enough transient integration time, the two attractors will get confused into one:</p><pre><code class="language-julia hljs">mapper3 = AttractorsViaFeaturizing(ds, featurizer; Ttr = 10, Δt = 0.1)
fs3 = basins_fractions(mapper3, sampler)
attractors3 = extract_attractors(mapper3)
plot_attractors(attractors3)</code></pre><img src="5c30e518.png" alt="Example block output"/><p>On the other hand, the downside of <a href="../api/#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a> is that it can take quite a while to converge for chaotic high dimensional systems.</p><h2 id="global_cont_tutorial"><a class="docs-heading-anchor" href="#global_cont_tutorial">Global continuation</a><a id="global_cont_tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#global_cont_tutorial" title="Permalink"></a></h2><p>If you have heard before the word &quot;continuation&quot;, then you are likely aware of the <strong>traditional continuation-based bifurcation analysis (CBA)</strong> offered by many software, such as AUTO, MatCont, and in Julia <a href="https://github.com/bifurcationkit/BifurcationKit.jl">BifurcationKit.jl</a>. Here we offer a completely different kind of continuation called <strong>global continuation</strong>.</p><p>A direct comparison of the two approaches is not truly possible, because they do different things. The traditional continuation analysis continues the curves of individual fixed points across the joint state-parameter space and tracks their <em>local (linear) stability</em>. The global continuation in Attractors.jl finds all attractors, including chaotic ones, in the whole of the state space (that it searches in), and continues all of these attractors concurrently along a parameter axis. Additionally, this global continuation tracks a <em>nonlocal</em> stability property which by default is the basin fraction.</p><p>This is a fundamental difference. Because all attractors are simultaneously tracked across the parameter axis, the user may arbitrarily estimate <em>any</em> property of the attractors and how it varies as the parameter varies. A more detailed comparison between these two approaches can be found in (<a href="../references/#Datseris2023">Datseris <em>et al.</em>, 2023</a>). See also the <a href="@ref bfkit_comparison">comparison page</a> in our docs that attempts to do the same analysis of our Tutorial with traditional continuation software.</p><p>To perform the continuation is extremely simple. First, we decide what parameter, and what range, to continue over:</p><pre><code class="language-julia hljs">prange = 4.7:0.02:6
pidx = 1 # index of the parameter</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><p>Then, we may call the <a href="../api/#Attractors.global_continuation"><code>global_continuation</code></a> function. We have to provide a continuation algorithm, which itself references an <a href="../api/#Attractors.AttractorMapper"><code>AttractorMapper</code></a>. In this example we will re-use the <code>mapper</code> to create the &quot;flagship product&quot; of Attractors.jl which is the generic <a href="../api/#Attractors.AttractorSeedContinueMatch"><code>AttractorSeedContinueMatch</code></a>. This algorithm uses the <code>mapper</code> to find all attractors at each parameter value and from the found attractors it continues them along a parameter axis using a seeding process (see its documentation string). Then, it performs a &quot;matching&quot; step, ensuring a &quot;continuity&quot; of the attractor label across the parameter axis. For now we ignore the matching step, leaving it to the default value. We&#39;ll use the <code>mapper</code> we created above and define</p><pre><code class="language-julia hljs">ascm = AttractorSeedContinueMatch(mapper)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AttractorSeedContinueMatch{AttractorsViaRecurrences{CoupledODEs{false, 3, OrdinaryDiffEq.ODEIntegrator{OrdinaryDiffEq.Vern9{typeof(OrdinaryDiffEq.trivial_limiter!), typeof(OrdinaryDiffEq.trivial_limiter!), Static.False}, false, SVector{3, Float64}, Nothing, Float64, Vector{Float64}, Float64, Float64, Float64, Float64, Vector{SVector{3, Float64}}, SciMLBase.ODESolution{Float64, 2, Vector{SVector{3, Float64}}, Nothing, Nothing, Vector{Float64}, Vector{Vector{SVector{3, Float64}}}, SciMLBase.ODEProblem{SVector{3, Float64}, Tuple{Float64, Float64}, false, Vector{Float64}, SciMLBase.ODEFunction{false, SciMLBase.AutoSpecialize, typeof(Main.modified_lorenz_rule), LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing, Nothing, Nothing, Nothing}, Base.Pairs{Symbol, Union{}, Tuple{}, @NamedTuple{}}, SciMLBase.StandardODEProblem}, OrdinaryDiffEq.Vern9{typeof(OrdinaryDiffEq.trivial_limiter!), typeof(OrdinaryDiffEq.trivial_limiter!), Static.False}, OrdinaryDiffEq.InterpolationData{SciMLBase.ODEFunction{false, SciMLBase.AutoSpecialize, typeof(Main.modified_lorenz_rule), LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing, Nothing, Nothing, Nothing}, Vector{SVector{3, Float64}}, Vector{Float64}, Vector{Vector{SVector{3, Float64}}}, Nothing, OrdinaryDiffEq.Vern9ConstantCache, Nothing}, SciMLBase.DEStats, Nothing, Nothing, Nothing}, SciMLBase.ODEFunction{false, SciMLBase.AutoSpecialize, typeof(Main.modified_lorenz_rule), LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing, Nothing, Nothing, Nothing}, OrdinaryDiffEq.Vern9ConstantCache, OrdinaryDiffEq.DEOptions{Float64, Float64, Float64, Float64, OrdinaryDiffEq.PIController{Rational{Int64}}, typeof(DiffEqBase.ODE_DEFAULT_NORM), typeof(LinearAlgebra.opnorm), Bool, SciMLBase.CallbackSet{Tuple{}, Tuple{}}, typeof(DiffEqBase.ODE_DEFAULT_ISOUTOFDOMAIN), typeof(DiffEqBase.ODE_DEFAULT_PROG_MESSAGE), typeof(DiffEqBase.ODE_DEFAULT_UNSTABLE_CHECK), DataStructures.BinaryHeap{Float64, DataStructures.FasterForward}, DataStructures.BinaryHeap{Float64, DataStructures.FasterForward}, Nothing, Nothing, Float64, Tuple{}, Tuple{}, Tuple{}}, SVector{3, Float64}, Float64, Nothing, OrdinaryDiffEq.DefaultInit, Nothing}, Vector{Float64}}, Attractors.BasinsInfo{3, Attractors.RegularGrid{3, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Float64, Float64, Attractors.SparseArray{Int64, 3}}, Attractors.RegularGrid{3, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Base.Pairs{Symbol, Int64, Tuple{Symbol, Symbol, Symbol}, @NamedTuple{consecutive_recurrences::Int64, attractor_locate_steps::Int64, consecutive_lost_steps::Int64}}}, MatchBySSSetDistance{Centroid{Euclidean}, Float64}, typeof(Attractors._default_seeding)}(AttractorsViaRecurrences
 system:      CoupledODEs
 grid:        (-10.0:0.20202020202020202:10.0, -15.0:0.30303030303030304:15.0, -15.0:0.30303030303030304:15.0)
 attractors:  Dict{Int64, StateSpaceSet{3, Float64}}(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 208 points, 1 =&gt; 3-dimensional StateSpaceSet{Float64} with 783 points)
, MatchBySSSetDistance{Centroid{Euclidean}, Float64}(Centroid{Euclidean}(Euclidean(0.0)), Inf, false), Attractors._default_seeding)</code></pre><p>and call</p><pre><code class="language-julia hljs">fractions_cont, attractors_cont = global_continuation(
	ascm, prange, pidx, sampler; samples_per_parameter = 1_000
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([Dict(1 =&gt; 1.0), Dict(1 =&gt; 1.0), Dict(1 =&gt; 1.0), Dict(1 =&gt; 1.0), Dict(1 =&gt; 1.0), Dict(1 =&gt; 1.0), Dict(1 =&gt; 1.0), Dict(1 =&gt; 1.0), Dict(1 =&gt; 1.0), Dict(1 =&gt; 1.0)  …  Dict(2 =&gt; 0.8661338661338661, 3 =&gt; 0.13386613386613386), Dict(2 =&gt; 0.8962075848303394, 3 =&gt; 0.10379241516966067), Dict(2 =&gt; 0.9111776447105788, 3 =&gt; 0.08882235528942116), Dict(2 =&gt; 0.8892215568862275, 3 =&gt; 0.11077844311377245), Dict(2 =&gt; 0.9021956087824351, 3 =&gt; 0.09780439121756487), Dict(2 =&gt; 1.0), Dict(2 =&gt; 1.0), Dict(2 =&gt; 1.0), Dict(2 =&gt; 1.0), Dict(2 =&gt; 1.0)], Dict{Int64, StateSpaceSet{3, Float64}}[Dict(1 =&gt; 3-dimensional StateSpaceSet{Float64} with 432 points), Dict(1 =&gt; 3-dimensional StateSpaceSet{Float64} with 406 points), Dict(1 =&gt; 3-dimensional StateSpaceSet{Float64} with 343 points), Dict(1 =&gt; 3-dimensional StateSpaceSet{Float64} with 352 points), Dict(1 =&gt; 3-dimensional StateSpaceSet{Float64} with 343 points), Dict(1 =&gt; 3-dimensional StateSpaceSet{Float64} with 355 points), Dict(1 =&gt; 3-dimensional StateSpaceSet{Float64} with 343 points), Dict(1 =&gt; 3-dimensional StateSpaceSet{Float64} with 332 points), Dict(1 =&gt; 3-dimensional StateSpaceSet{Float64} with 349 points), Dict(1 =&gt; 3-dimensional StateSpaceSet{Float64} with 303 points)  …  Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 387 points, 3 =&gt; 3-dimensional StateSpaceSet{Float64} with 513 points), Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 384 points, 3 =&gt; 3-dimensional StateSpaceSet{Float64} with 465 points), Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 356 points, 3 =&gt; 3-dimensional StateSpaceSet{Float64} with 406 points), Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 374 points, 3 =&gt; 3-dimensional StateSpaceSet{Float64} with 304 points), Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 376 points, 3 =&gt; 3-dimensional StateSpaceSet{Float64} with 336 points), Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 368 points), Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 314 points), Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 264 points), Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 244 points), Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 237 points)])</code></pre><p>the output is given as two vectors. Each vector is a dictionary mapping attractor IDs to their basin fractions, or their state space sets, respectively. Both vectors have the same size as the parameter range. For example, the attractors at the 34-th parameter value are:</p><pre><code class="language-julia hljs">attractors_cont[34]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Int64, StateSpaceSet{3, Float64}} with 2 entries:
  2 =&gt; 3-dimensional StateSpaceSet{Float64} with 559 points
  1 =&gt; 3-dimensional StateSpaceSet{Float64} with 225 points</code></pre><p>There is a fantastic convenience function for animating the attractors evolution, that utilizes things we have already defined:</p><pre><code class="language-julia hljs">animate_attractors_continuation(
    ds, attractors_cont, fractions_cont, prange, pidx;
);</code></pre><video width="auto" controls loop>
<source src="../attracont.mp4" type="video/mp4">
</video><p>Hah, how cool is that! The attractors pop in and out of existence like out of nowhere! It would be incredibly difficult to find these attractors in traditional continuation software where a rough estimate of the period is required! (It would also be too hard due to the presence of chaos for most of the parameter values, but that&#39;s another issue!)</p><p>Now typically a continuation is visualized in a 2D plot where the x axis is the parameter axis. We can do this with the convenience function:</p><pre><code class="language-julia hljs">fig = plot_basins_attractors_curves(
	fractions_cont, attractors_cont, A -&gt; minimum(A[:, 1]), prange,
)</code></pre><img src="8e55c62f.png" alt="Example block output"/><p>In the top panel are the basin fractions, by default plotted as stacked bars. Bottom panel is a visualization of the tracked attractors. The argument <code>A -&gt; minimum(A[:, 1])</code> is simply a function that maps an attractor into a real number for plotting.</p><h2 id="Different-matching-procedures"><a class="docs-heading-anchor" href="#Different-matching-procedures">Different matching procedures</a><a id="Different-matching-procedures-1"></a><a class="docs-heading-anchor-permalink" href="#Different-matching-procedures" title="Permalink"></a></h2><p>By default attractors are matched by their distance in state space. The default matcher is <a href="../api/#Attractors.MatchBySSSetDistance"><code>MatchBySSSetDistance</code></a>, and is given implicitly as a default 2nd argument when creating <a href="../api/#Attractors.AttractorSeedContinueMatch"><code>AttractorSeedContinueMatch</code></a>. But like anything else in Attractors.jl, &quot;matchers&quot; also follow a well-defined and extendable interface, see <a href="@ref"><code>IDMatchers</code></a> for that.</p><p>Let&#39;s say that the default matching that we chose above isn&#39;t desirable. For example, one may argue that the attractor that pops up at the end of the continuation should have been assigned the same ID as attractor 1, because they are both to the left (see the video above). In reality one wouldn&#39;t really request that, because looking the video of attractors above shows that the attractors labelled &quot;1&quot;, &quot;2&quot;, and &quot;3&quot; are all completely different. But we argue here for example that &quot;3&quot; should have been the same as &quot;1&quot;.</p><p>Thankfully during a global continuation the &quot;matching&quot; step is completely separated from the &quot;finding and continuing&quot; step. If we don&#39;t like the initial matching, we can call <a href="../api/#Attractors.match_sequentially!"><code>match_sequentially!</code></a> with a new instance of a matcher, and match again, without having to recompute the attractors and their basin fractions. For example, using this matcher:</p><pre><code class="language-julia hljs">matcher = MatchBySSSetDistance(use_vanished = true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MatchBySSSetDistance{Centroid{Euclidean}, Float64}(Centroid{Euclidean}(Euclidean(0.0)), Inf, true)</code></pre><p>will compare a new attractor with the latest instance of attractors with a given ID that have ever existed, irrespectively if they exist in the current parameter or not. This means, that the attractor &quot;3&quot; would in fact be compared with both attractor &quot;2&quot; and &quot;1&quot;, even if &quot;1&quot; doesn&#39;t exist in the parameter &quot;3&quot; started existing at. And because &quot;3&quot; is closer to &quot;1&quot; than to &quot;2&quot;, it will get matched to attractor &quot;1&quot; and get the same ID.</p><p>Let&#39;s see this in action:</p><pre><code class="language-julia hljs">attractors_cont2 = deepcopy(attractors_cont)

match_sequentially!(attractors_cont2, matcher)

fig = plot_attractors_curves(
	attractors_cont2, A -&gt; minimum(A[:, 1]), prange,
)</code></pre><img src="6a50e686.png" alt="Example block output"/><p>and as we can see, the new attractor at the end of the parameter range got assigned the same ID as the original attractor &quot;1&quot;. For more ways of matching attractors see <a href="../api/#Attractors.IDMatcher"><code>IDMatcher</code></a>.</p><h2 id="Enhancing-the-continuation"><a class="docs-heading-anchor" href="#Enhancing-the-continuation">Enhancing the continuation</a><a id="Enhancing-the-continuation-1"></a><a class="docs-heading-anchor-permalink" href="#Enhancing-the-continuation" title="Permalink"></a></h2><p>The biggest strength of Attractors.jl is that it is not an isolated software. It is part of <strong>DynamicalSystems.jl</strong>. Here, we will use the full power of <strong>DynamicalSystems.jl</strong> and enrich the above continuation with various other measures of nonlocal stability, in particular Lyapunov exponents and the minimal fatal shock. First, let&#39;s plot again the continuation and label some things or clarity</p><pre><code class="language-julia hljs">fig = plot_basins_attractors_curves(
	fractions_cont, attractors_cont, A -&gt; minimum(A[:, 1]), prange; add_legend = false
)

ax1 = content(fig[2,1])

ax1.ylabel = &quot;min(A₁)&quot;

fig</code></pre><img src="2e74826f.png" alt="Example block output"/><p>First, let&#39;s estimate the maximum Lyapunov exponent (MLE) for all attractors, using the <code>lyapunovspectrum</code> function that comes from the ChaosTools.jl submodule.</p><pre><code class="language-julia hljs">using ChaosTools: lyapunov

lis = map(enumerate(prange)) do (i, p) # loop over parameters
    set_parameter!(ds, pidx, p) # important! We use the dynamical system!
    attractors = attractors_cont[i]
    Dict(k =&gt; lyapunov(ds, 2000.0; u0 = A[1]) for (k, A) in attractors)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">66-element Vector{Dict{Int64, Float64}}:
 Dict(1 =&gt; 0.0007601275338498697)
 Dict(1 =&gt; 0.0001729147401323324)
 Dict(1 =&gt; 0.00040378291769435144)
 Dict(1 =&gt; -0.00014101286397705362)
 Dict(1 =&gt; 0.0005576964698765166)
 Dict(1 =&gt; -0.0007570103514839616)
 Dict(1 =&gt; 0.0006311840051251072)
 Dict(1 =&gt; 0.0006140900720551151)
 Dict(1 =&gt; 0.0005024179704775946)
 Dict(1 =&gt; 0.0007014160053057485)
 ⋮
 Dict(2 =&gt; 0.00021536675162705366, 3 =&gt; 0.008941820934455245)
 Dict(2 =&gt; -4.2199200259184954e-5, 3 =&gt; 0.001073570636028119)
 Dict(2 =&gt; -0.00018941674498528465, 3 =&gt; 0.0017891765595290923)
 Dict(2 =&gt; 0.000254116631378513, 3 =&gt; 0.0011529952304147315)
 Dict(2 =&gt; 0.00021766608156579246)
 Dict(2 =&gt; 0.0007914263207720186)
 Dict(2 =&gt; 0.000619750626705647)
 Dict(2 =&gt; 0.0006137976599985442)
 Dict(2 =&gt; -0.00019421069937765377)</code></pre><p>The above <code>map</code> loop may be intimidating if you are a beginner, but it is really just a shorter way to write a <code>for</code> loop for our example. We iterate over all parameters, and for each we first update the dynamical system with the correct parameter, and then extract the MLE for each attractor. <code>map</code> just means that we don&#39;t have to pre-allocate a new vector before the loop; it creates it for us.</p><p>We can visualize the LE with the other convenience function <a href="@ref"><code>plot_continuation_curves!</code></a>,</p><pre><code class="language-julia hljs">ax2 = Axis(fig[4, 1]; ylabel = &quot;MLE&quot;)
plot_continuation_curves!(ax2, lis, prange; add_legend = false)

fig</code></pre><img src="c025656a.png" alt="Example block output"/><p>This reveals crucial information for tha attractors, whether they are chaotic or not, that we would otherwise obtain only by visualizing the system dynamics at every single parameter. The story we can see now is that the dynamics start with a limit cycle (0 Lyapunov exponent), go into bi-stability of chaos and limit cycle, then there is only one limit cycle again, and then a chaotic attractor appears again, for a second bistable regime.</p><p>The last piece of information to add is yet another measure of nonlocal stability: the minimal fatal shock (MFS), which is provided by <a href="../api/#Attractors.minimal_fatal_shock"><code>minimal_fatal_shock</code></a>. The code to estimate this is similar with the <code>map</code> block for the MLE. Here however we re-use the created <code>mapper</code>, but now we must not forget to reset it inbetween parameter increments:</p><pre><code class="language-julia hljs">using LinearAlgebra: norm
search_area = collect(extrema.(grid ./ 2)) # smaller search = faster results
search_algorithm = MFSBlackBoxOptim(max_steps = 1000, guess = ones(3))

mfss = map(enumerate(prange)) do (i, p)
    set_parameter!(ds, pidx, p)
    reset_mapper!(mapper) # reset so that we don&#39;t have to re-initialize
    # We need a special clause here: if there is only 1 attractor,
    # then there is no MFS. It is undefined. We set it to `NaN`,
    # which conveniently, will result to nothing being plotted by Makie.
    attractors = attractors_cont[i]
    if length(attractors) == 1
        return Dict(k =&gt; NaN for (k, A) in attractors)
    end
    # otherwise, compute the actual MFS from the first point of each attractor
    Dict(k =&gt;
        norm(minimal_fatal_shock(mapper, A[1], search_area, search_algorithm))
        for (k, A) in attractors
    )
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">66-element Vector{Dict{Int64, Float64}}:
 Dict(1 =&gt; NaN)
 Dict(1 =&gt; NaN)
 Dict(1 =&gt; NaN)
 Dict(1 =&gt; NaN)
 Dict(1 =&gt; NaN)
 Dict(1 =&gt; NaN)
 Dict(1 =&gt; NaN)
 Dict(1 =&gt; NaN)
 Dict(1 =&gt; NaN)
 Dict(1 =&gt; NaN)
 ⋮
 Dict(2 =&gt; 0.6113740781958613, 3 =&gt; 0.3212447165734815)
 Dict(2 =&gt; 0.14832584461914963, 3 =&gt; 0.40869104034325116)
 Dict(2 =&gt; 0.12326775986029885, 3 =&gt; 0.3609119864185737)
 Dict(2 =&gt; 0.5888400948357922, 3 =&gt; 0.2549144471614294)
 Dict(2 =&gt; NaN)
 Dict(2 =&gt; NaN)
 Dict(2 =&gt; NaN)
 Dict(2 =&gt; NaN)
 Dict(2 =&gt; NaN)</code></pre><p>In a real application we wouldn&#39;t use the first point of each attractor, as the first point is completely random on the attractor (at least, for the [<code>AttractorsViaRecurrences</code>] mapper we use here). We would do this by examining the whole <code>A</code> object in the above block instead of just using <code>A[1]</code>. But this is a tutorial so we don&#39;t care!</p><p>Right, so now we can visualize the MFS with the rest of the other quantities:</p><pre><code class="language-julia hljs">ax3 = Axis(fig[5, 1]; ylabel = &quot;MFS&quot;, xlabel = &quot;parameter&quot;)
plot_continuation_curves!(ax3, mfss, prange; add_legend = false)

# make the figure prettier
for ax in (ax1, ax2,); hidexdecorations!(ax; grid = false); end
resize!(fig, 500, 500)
fig</code></pre><img src="aa1b904e.png" alt="Example block output"/><p>And that&#39;s the end of the tutorial! See the <a href="@ref examples">examples</a> for more runnable code, and see the <a href="../api/#API">API</a> for a list of all functions and algorithms! See also the <a href="@ref bfkit_comparison">comparison page</a> in our docs that attempts to do the same analysis of our Tutorial with traditional continuation software showing that (at least for this example) using Attractors.jl is clearly beneficial over the alternatives.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Attractors.jl</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Wednesday 3 July 2024 16:20">Wednesday 3 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
